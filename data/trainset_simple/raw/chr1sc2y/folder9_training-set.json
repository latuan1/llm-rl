[
    {
        "f": [],
        "fm": "int maxDepth(TreeNode *root) {\r         if (!root)\r             return 0;\r         return 1 + max(maxDepth(root->left), maxDepth(root->right));\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxDepth_TreeNodemul_random_1(void) {\n{\nAKA_test_case_name=\"Solution_maxDepth_TreeNodemul_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\104.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=1959501657;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=2080446711;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=0;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=879137603;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=1766200772;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxDepth_TreeNodemul_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxDepth(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_9\\\\104.cpp\\\\Solution\\\\maxDepth(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\104.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=1959501657;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=2080446711;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=0;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=879137603;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=1766200772;\nAKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     int maxDepth(TreeNode *root) {\r         if (!root)\r             return 0;\r         return 1 + max(maxDepth(root->left), maxDepth(root->right));\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "E:\\OneDrive - vnu.edu.vn\\test\\folder_9\\104.cpp\\Solution\\maxDepth(TreeNode*)"
    },
    {
        "f": [],
        "fm": "TreeNode(int x): val(x), left(NULL), right(NULL) {}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_TreeNode_int_random_0(void) {\n{\nAKA_test_case_name=\"TreeNode_int_random_0\";\n\n// set up\n;\n\n\n/* SubStructDataNode AKA_INSTANCE___TreeNode */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint AKA_INSTANCE___TreeNode_x=941179598;\nAKA_mark(\"<<PRE-CALLING>> Test TreeNode_int_random_0\");AKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\GLOBAL\\\\AKA_INSTANCE___TreeNode\\\\AKA_INSTANCE___TreeNode\\\\TreeNode(int)\");AKA_fCall++;AKA_INSTANCE___TreeNode = new ::TreeNode(AKA_INSTANCE___TreeNode_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nAKA_INSTANCE___TreeNode->left;\n/* PointerStructureDataNode right */\nAKA_INSTANCE___TreeNode->right;\n\n\n\n\n\n\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubStructDataNode AKA_INSTANCE___TreeNode */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint AKA_INSTANCE___TreeNode_x=941179598;\nAKA_mark(\"<<PRE-CALLING>> Test TreeNode_int_random_0\");AKA_mark(\"Calling: .\\\\folder_9\\\\104.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\104.cpp\\\\GLOBAL\\\\AKA_INSTANCE___TreeNode\\\\AKA_INSTANCE___TreeNode\\\\TreeNode(int)\");AKA_fCall++;AKA_INSTANCE___TreeNode = new ::TreeNode(AKA_INSTANCE___TreeNode_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nAKA_INSTANCE___TreeNode->left;\n/* PointerStructureDataNode right */\nAKA_INSTANCE___TreeNode->right;\n\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "",
        "c": [],
        "path_fm": "E:\\OneDrive - vnu.edu.vn\\test\\folder_9\\104.cpp\\TreeNode\\TreeNode(int)"
    },
    {
        "f": [
            "int n;",
            "int dir;",
            "int x;",
            "int y;"
        ],
        "fm": "bool isRobotBounded(string instructions) {\r         dir = 0, x = 0, y = 0;\r         n = instructions.size();\r         for (int i = 0; i < 4; ++i) {\r             Process(instructions);\r             if (x == 0 && y == 0)\r                 return true;\r         }\r         return false;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_isRobotBounded_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_isRobotBounded_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1041.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* NormalNumberDataNode n */\n/* n : null value -> no code */\n/* NormalNumberDataNode dir */\n/* dir : null value -> no code */\n/* NormalNumberDataNode x */\n/* x : null value -> no code */\n/* NormalNumberDataNode y */\n/* y : null value -> no code */\n\n\nchar* akaRandomName112640 = new char[2];akaRandomName112640[0] = -101;akaRandomName112640[1] = '\\0';string instructions=akaRandomName112640;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode instructions */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_isRobotBounded_string_random_0\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->isRobotBounded(instructions);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_9\\\\1041.cpp\\\\Solution\\\\isRobotBounded(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1041.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* NormalNumberDataNode n */\n/* n : null value -> no code */\n/* NormalNumberDataNode dir */\n/* dir : null value -> no code */\n/* NormalNumberDataNode x */\n/* x : null value -> no code */\n/* NormalNumberDataNode y */\n/* y : null value -> no code */\n\n\nchar* akaRandomName19398 = new char[2];akaRandomName19398[0] = -101;akaRandomName19398[1] = '\\0';string instructions=akaRandomName19398;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode instructions */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r     int n;\r     int dir, x, y;\r public:\r     bool isRobotBounded(string instructions) {\r         dir = 0, x = 0, y = 0;\r         n = instructions.size();\r         for (int i = 0; i < 4; ++i) {\r             Process(instructions);\r             if (x == 0 && y == 0)\r                 return true;\r         }\r         return false;\r     }\r \r     void Process(string &instructions) {\r         for (int i = 0; i < n; ++i) {\r             if (instructions[i] == 'L')\r                 dir = dir == 3 ? 0 : dir + 1;\r             else if (instructions[i] == 'R')\r                 dir = dir == 0 ? 3 : dir - 1;\r             else {\r                 if (dir == 0 || dir == 2)\r                     y += (dir - 1) * -1;\r                 else\r                     x += dir - 2;\r             }\r         }\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "E:\\OneDrive - vnu.edu.vn\\test\\folder_9\\1041.cpp\\Solution\\isRobotBounded(string)"
    },
    {
        "f": [
            "int n;",
            "int dir;",
            "int x;",
            "int y;"
        ],
        "fm": "void Process(string &instructions) {\r         for (int i = 0; i < n; ++i) {\r             if (instructions[i] == 'L')\r                 dir = dir == 3 ? 0 : dir + 1;\r             else if (instructions[i] == 'R')\r                 dir = dir == 0 ? 3 : dir - 1;\r             else {\r                 if (dir == 0 || dir == 2)\r                     y += (dir - 1) * -1;\r                 else\r                     x += dir - 2;\r             }\r         }\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_Process_string_random_3(void) {\n{\nAKA_test_case_name=\"Solution_Process_string_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1041.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* NormalNumberDataNode n */\n/* n : null value -> no code */\n/* NormalNumberDataNode dir */\n/* dir : null value -> no code */\n/* NormalNumberDataNode x */\n/* x : null value -> no code */\n/* NormalNumberDataNode y */\n/* y : null value -> no code */\n\n\nchar* akaRandomName153684 = new char[2];akaRandomName153684[0] = 82;akaRandomName153684[1] = '\\0';string instructions=akaRandomName153684;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode instructions */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_Process_string_random_3\");AKA_INSTANCE___Solution->Process(instructions);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_9\\\\1041.cpp\\\\Solution\\\\Process(string&)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1041.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* NormalNumberDataNode n */\n/* n : null value -> no code */\n/* NormalNumberDataNode dir */\n/* dir : null value -> no code */\n/* NormalNumberDataNode x */\n/* x : null value -> no code */\n/* NormalNumberDataNode y */\n/* y : null value -> no code */\n\n\nchar* akaRandomName290544 = new char[2];akaRandomName290544[0] = 82;akaRandomName290544[1] = '\\0';string instructions=akaRandomName290544;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode instructions */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r     int n;\r     int dir, x, y;\r public:\r     bool isRobotBounded(string instructions) {\r         dir = 0, x = 0, y = 0;\r         n = instructions.size();\r         for (int i = 0; i < 4; ++i) {\r             Process(instructions);\r             if (x == 0 && y == 0)\r                 return true;\r         }\r         return false;\r     }\r \r     void Process(string &instructions) {\r         for (int i = 0; i < n; ++i) {\r             if (instructions[i] == 'L')\r                 dir = dir == 3 ? 0 : dir + 1;\r             else if (instructions[i] == 'R')\r                 dir = dir == 0 ? 3 : dir - 1;\r             else {\r                 if (dir == 0 || dir == 2)\r                     y += (dir - 1) * -1;\r                 else\r                     x += dir - 2;\r             }\r         }\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "E:\\OneDrive - vnu.edu.vn\\test\\folder_9\\1041.cpp\\Solution\\Process(string&)"
    },
    {
        "f": [],
        "fm": "vector<int> gardenNoAdj(int N, vector<vector<int>> &paths) {\r         vector<int> res(N);\r         vector<vector<int>> adjacent(N);\r         for (auto path:paths) {\r             adjacent[path[0] - 1].push_back(path[1] - 1);\r             adjacent[path[1] - 1].push_back(path[0] - 1);\r         }\r         for (int i = 0; i < N; ++i) {\r             vector<bool> used(5);\r             auto &ad = adjacent[i];\r             for (auto &a:ad)\r                 used[res[a]] = true;\r             for (int j = 1; j <= 4; ++j) {\r                 if (!used[j]) {\r                     res[i] = j;\r                     break;\r                 }\r             }\r         }\r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_gardenNoAdj_int_vector_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_gardenNoAdj_int_vector_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1042.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint N=9;\nvector<vector<int>> paths;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode N */\n/* VectorDataNode paths */\nvector<int> paths_element0;\nint paths_element0_element0=-2016114293;\npaths_element0.push_back(paths_element0_element0);\nint paths_element0_element1=-329021490;\npaths_element0.push_back(paths_element0_element1);\npaths.push_back(paths_element0);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_gardenNoAdj_int_vector_vector_int_random_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->gardenNoAdj(N,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_9\\\\1042.cpp\\\\Solution\\\\gardenNoAdj(int,vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1042.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint N=9;\nvector<vector<int>> paths;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode N */\n/* VectorDataNode paths */\nvector<int> paths_element0;\nint paths_element0_element0=-2016114293;\npaths_element0.push_back(paths_element0_element0);\nint paths_element0_element1=-329021490;\npaths_element0.push_back(paths_element0_element1);\npaths.push_back(paths_element0);\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     vector<int> gardenNoAdj(int N, vector<vector<int>> &paths) {\r         vector<int> res(N);\r         vector<vector<int>> adjacent(N);\r         for (auto path:paths) {\r             adjacent[path[0] - 1].push_back(path[1] - 1);\r             adjacent[path[1] - 1].push_back(path[0] - 1);\r         }\r         for (int i = 0; i < N; ++i) {\r             vector<bool> used(5);\r             auto &ad = adjacent[i];\r             for (auto &a:ad)\r                 used[res[a]] = true;\r             for (int j = 1; j <= 4; ++j) {\r                 if (!used[j]) {\r                     res[i] = j;\r                     break;\r                 }\r             }\r         }\r         return res;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "E:\\OneDrive - vnu.edu.vn\\test\\folder_9\\1042.cpp\\Solution\\gardenNoAdj(int,vector<vector<int>>&)"
    },
    {
        "f": [],
        "fm": "int lastStoneWeight(vector<int> &stones) {\r         priority_queue<int> heap;\r         for (auto &stone:stones)\r             heap.push(stone);\r         while (!heap.empty()) {\r             int i = heap.top();\r             heap.pop();\r             if (heap.empty())\r                 return i;\r             int j = heap.top();\r             heap.pop();\r             heap.push(i - j);\r         }\r         return heap.top();\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_lastStoneWeight_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_lastStoneWeight_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1046.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> stones;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode stones */\nint stones_element0=1685595619;\nstones.push_back(stones_element0);\nint stones_element1=1485134824;\nstones.push_back(stones_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_lastStoneWeight_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->lastStoneWeight(stones);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_9\\\\1046.cpp\\\\Solution\\\\lastStoneWeight(vector<int>&)\");\n\n\nvector<int> EXPECTED_stones;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1046.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> stones;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode stones */\nint stones_element0=1685595619;\nstones.push_back(stones_element0);\nint stones_element1=1485134824;\nstones.push_back(stones_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     int lastStoneWeight(vector<int> &stones) {\r         priority_queue<int> heap;\r         for (auto &stone:stones)\r             heap.push(stone);\r         while (!heap.empty()) {\r             int i = heap.top();\r             heap.pop();\r             if (heap.empty())\r                 return i;\r             int j = heap.top();\r             heap.pop();\r             heap.push(i - j);\r         }\r         return heap.top();\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "E:\\OneDrive - vnu.edu.vn\\test\\folder_9\\1046.cpp\\Solution\\lastStoneWeight(vector<int>&)"
    },
    {
        "f": [],
        "fm": "string removeDuplicates(string S) {\r         string res;\r         for (int i = 0; i < S.size(); ++i) {\r             if (res.empty() || res.back() != S[i])\r                 res += S[i];\r             else\r                 res.pop_back();\r         }\r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_removeDuplicates_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_removeDuplicates_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1047.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName973836 = new char[2];akaRandomName973836[0] = -37;akaRandomName973836[1] = '\\0';string S=akaRandomName973836;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_removeDuplicates_string_random_0\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->removeDuplicates(S);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\folder_9\\\\1047.cpp\\\\Solution\\\\removeDuplicates(string)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1047.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName688799 = new char[2];akaRandomName688799[0] = -37;akaRandomName688799[1] = '\\0';string S=akaRandomName688799;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     string removeDuplicates(string S) {\r         string res;\r         for (int i = 0; i < S.size(); ++i) {\r             if (res.empty() || res.back() != S[i])\r                 res += S[i];\r             else\r                 res.pop_back();\r         }\r         return res;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "E:\\OneDrive - vnu.edu.vn\\test\\folder_9\\1047.cpp\\Solution\\removeDuplicates(string)"
    }
]