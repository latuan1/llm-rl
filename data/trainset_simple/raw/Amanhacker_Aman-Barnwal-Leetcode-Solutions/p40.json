[
    {
        "f": [],
        "fm": "int minOperations(vector<string>& logs) {\r     \r         int count = 0;\r         int n = logs.size();\r         \r         for(auto &x : logs) {\r             \r             if(x[0] != '.')                                     count++;\r             else if(x.size() == 3 && x[2] == '/') {\r                 if(count > 0)                                   count--;\r             }\r         }\r         \r         return count;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_minOperations_vector_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_minOperations_vector_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1598-crawler-log-folder.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> logs;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode logs */\nchar* akaRandomName749979 = new char[2];akaRandomName749979[0] = -110;akaRandomName749979[1] = '\\0';string logs_element0=akaRandomName749979;\nlogs.push_back(logs_element0);\nchar* akaRandomName777931 = new char[2];akaRandomName777931[0] = 12;akaRandomName777931[1] = '\\0';string logs_element1=akaRandomName777931;\nlogs.push_back(logs_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minOperations_vector_string_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minOperations(logs);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p40\\\\1598-crawler-log-folder\\\\1598-crawler-log-folder.cpp\\\\Solution\\\\minOperations(vector<string>&)\");\n\n\nvector<string> EXPECTED_logs;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1556-thousand-separator.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=1366375546;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     int minOperations(vector<string>& logs) {\r     \r         int count = 0;\r         int n = logs.size();\r         \r         for(auto &x : logs) {\r             \r             if(x[0] != '.')                                     count++;\r             else if(x.size() == 3 && x[2] == '/') {\r                 if(count > 0)                                   count--;\r             }\r         }\r         \r         return count;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p40\\1598-crawler-log-folder\\1598-crawler-log-folder.cpp\\Solution\\minOperations(vector<string>&)"
    },
    {
        "f": [],
        "fm": "int threeSumClosest(vector<int>& a, int tar) {\r     \r         int ans;\r         \r         int n = a.size();\r         sort(a.begin(), a.end());\r         \r         int prevSum = a[0] + a[1] + a[n-1];\r         \r         for(int i=0; i<n-2; i++) {\r             \r             // Now, use Binary Search\r             int start = i + 1;\r             int end = n - 1;\r             \r             while(start < end) {\r                 \r                 int curSum = a[i] + a[start] + a[end];\r                 \r                 if(curSum == tar)                       return curSum;\r                 else if(curSum < tar)                   start++;\r                 else                                    end--;\r                 \r                 if(abs(curSum - tar) < abs(prevSum - tar))          prevSum = curSum;\r             }\r         }\r         \r         ans = prevSum;\r         return ans;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_threeSumClosest_vector_int_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_threeSumClosest_vector_int_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\16-3sum-closest.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> a;\n\n\nint tar=-1736231508;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode a */\nint a_element0=-1406805296;\na.push_back(a_element0);\nint a_element1=1662563768;\na.push_back(a_element1);\nint a_element2=-1200074722;\na.push_back(a_element2);\n/* NormalNumberDataNode tar */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_threeSumClosest_vector_int_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->threeSumClosest(a,tar);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p40\\\\16-3sum-closest\\\\16-3sum-closest.cpp\\\\Solution\\\\threeSumClosest(vector<int>&,int)\");\n\n\nvector<int> EXPECTED_a;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1556-thousand-separator.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=1366375546;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_threeSumClosest_vector_int_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_threeSumClosest_vector_int_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\16-3sum-closest.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> a;\n\n\nint tar=1105195568;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode a */\nint a_element0=1225950667;\na.push_back(a_element0);\nint a_element1=1030963431;\na.push_back(a_element1);\nint a_element2=356037565;\na.push_back(a_element2);\n/* NormalNumberDataNode tar */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_threeSumClosest_vector_int_int_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->threeSumClosest(a,tar);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p40\\\\16-3sum-closest\\\\16-3sum-closest.cpp\\\\Solution\\\\threeSumClosest(vector<int>&,int)\");\n\n\nvector<int> EXPECTED_a;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1557-minimum-number-of-vertices-to-reach-all-nodes.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=5;\nvector<vector<int>> edges;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* VectorDataNode edges */\nvector<int> edges_element0;\nint edges_element0_element0=1589038942;\nedges_element0.push_back(edges_element0_element0);\nedges.push_back(edges_element0);\nvector<int> edges_element1;\nint edges_element1_element0=104046497;\nedges_element1.push_back(edges_element1_element0);\nedges.push_back(edges_element1);\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     int threeSumClosest(vector<int>& a, int tar) {\r     \r         int ans;\r         \r         int n = a.size();\r         sort(a.begin(), a.end());\r         \r         int prevSum = a[0] + a[1] + a[n-1];\r         \r         for(int i=0; i<n-2; i++) {\r             \r             // Now, use Binary Search\r             int start = i + 1;\r             int end = n - 1;\r             \r             while(start < end) {\r                 \r                 int curSum = a[i] + a[start] + a[end];\r                 \r                 if(curSum == tar)                       return curSum;\r                 else if(curSum < tar)                   start++;\r                 else                                    end--;\r                 \r                 if(abs(curSum - tar) < abs(prevSum - tar))          prevSum = curSum;\r             }\r         }\r         \r         ans = prevSum;\r         return ans;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p40\\16-3sum-closest\\16-3sum-closest.cpp\\Solution\\threeSumClosest(vector<int>&,int)"
    },
    {
        "f": [],
        "fm": "ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r     \r         set<ListNode*> w;\r         \r         while(headA != NULL) {\r             w.insert(headA);\r             headA = headA->next;\r         }\r         \r         while(headB != NULL) {\r             \r             if(w.find(headB) != w.end()) {\r                 return headB;    \r             }\r             \r             headB = headB->next;\r         }\r         \r         return NULL;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_getIntersectionNode_ListNodemul_ListNodemul_random_2(void) {\n{\nAKA_test_case_name=\"Solution_getIntersectionNode_ListNodemul_ListNodemul_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\160-intersection-of-two-linked-lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_headA;\n\n\n/* SubStructDataNode headA */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint headA0_x=226785445;\nAKA_mark(\"Calling: .\\\\p40\\\\160-intersection-of-two-linked-lists\\\\160-intersection-of-two-linked-lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\160-intersection-of-two-linked-lists.cpp\\\\getIntersectionNode(ListNode*,ListNode*)\\\\headA\\\\AKA_VECTOR_INIT_headA_0\\\\headA\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_headA_0 = new ::ListNode(headA0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_headA_0).next;\n\nAKA_VECTOR_INIT_headA.push_back(AKA_VECTOR_INIT_headA_0);\n\n\n/* SubStructDataNode headA */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint headA1_x=1007859203;\nAKA_mark(\"Calling: .\\\\p40\\\\160-intersection-of-two-linked-lists\\\\160-intersection-of-two-linked-lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\160-intersection-of-two-linked-lists.cpp\\\\getIntersectionNode(ListNode*,ListNode*)\\\\headA\\\\AKA_VECTOR_INIT_headA_1\\\\headA\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_headA_1 = new ::ListNode(headA1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_headA_1).next;\n\nAKA_VECTOR_INIT_headA.push_back(AKA_VECTOR_INIT_headA_1);\n\n\n/* SubStructDataNode headA */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint headA2_x=369032616;\nAKA_mark(\"Calling: .\\\\p40\\\\160-intersection-of-two-linked-lists\\\\160-intersection-of-two-linked-lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\160-intersection-of-two-linked-lists.cpp\\\\getIntersectionNode(ListNode*,ListNode*)\\\\headA\\\\AKA_VECTOR_INIT_headA_2\\\\headA\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_headA_2 = new ::ListNode(headA2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_headA_2).next;\n\nAKA_VECTOR_INIT_headA.push_back(AKA_VECTOR_INIT_headA_2);\n\nListNode* headA = AKA_VECTOR_INIT_headA[0];\nstd::vector<ListNode*> AKA_VECTOR_INIT_headB;\n\n\n/* SubStructDataNode headB */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint headB0_x=2070939707;\nAKA_mark(\"Calling: .\\\\p40\\\\160-intersection-of-two-linked-lists\\\\160-intersection-of-two-linked-lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\160-intersection-of-two-linked-lists.cpp\\\\getIntersectionNode(ListNode*,ListNode*)\\\\headB\\\\AKA_VECTOR_INIT_headB_0\\\\headB\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_headB_0 = new ::ListNode(headB0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_headB_0).next;\n\nAKA_VECTOR_INIT_headB.push_back(AKA_VECTOR_INIT_headB_0);\n\n\n/* SubStructDataNode headB */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint headB1_x=0;\nAKA_mark(\"Calling: .\\\\p40\\\\160-intersection-of-two-linked-lists\\\\160-intersection-of-two-linked-lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\160-intersection-of-two-linked-lists.cpp\\\\getIntersectionNode(ListNode*,ListNode*)\\\\headB\\\\AKA_VECTOR_INIT_headB_1\\\\headB\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_headB_1 = new ::ListNode(headB1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_headB_1).next;\n\nAKA_VECTOR_INIT_headB.push_back(AKA_VECTOR_INIT_headB_1);\n\nListNode* headB = AKA_VECTOR_INIT_headB[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode headA */\n/* PointerStructureDataNode headB */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getIntersectionNode_ListNodemul_ListNodemul_random_2\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->getIntersectionNode(headA,headB);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p40\\\\160-intersection-of-two-linked-lists\\\\160-intersection-of-two-linked-lists.cpp\\\\Solution\\\\getIntersectionNode(ListNode*,ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1556-thousand-separator.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=1366375546;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r     \r         set<ListNode*> w;\r         \r         while(headA != NULL) {\r             w.insert(headA);\r             headA = headA->next;\r         }\r         \r         while(headB != NULL) {\r             \r             if(w.find(headB) != w.end()) {\r                 return headB;    \r             }\r             \r             headB = headB->next;\r         }\r         \r         return NULL;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p40\\160-intersection-of-two-linked-lists\\160-intersection-of-two-linked-lists.cpp\\Solution\\getIntersectionNode(ListNode*,ListNode*)"
    },
    {
        "f": [],
        "fm": "void bfs(TreeNode* root, TreeNode* u, TreeNode* &res) {\r         \r         if(root == NULL)                                  return;\r         \r         queue<TreeNode*> q;\r         q.push(root);\r         \r         while(q.empty() == false) {\r             \r             int n = q.size();\r             \r             // At one level, it has n nodes\r             int i = 0, j = -1;\r             bool flag = false;\r             \r             for( ; i<n; i++) {\r                 \r                 TreeNode* temp = q.front();\r                 q.pop();\r                 \r                 // If u is the rightmost node at a level\r                 if(i == n-1 && temp == u) {\r                     res = NULL;\r                     return;\r                 }\r \r                 // if u is not the rightmost node at a level\r                 if(flag == true && i == j) {\r                     res = temp;\r                     return;\r                 }\r                 \r                 if(i < n-1 && temp == u) {\r                     j = i + 1;\r                     flag = true;\r                 }\r                 \r                 if(temp->left != NULL)                      q.push(temp->left);\r                 if(temp->right != NULL)                     q.push(temp->right);\r             }\r         }\r         \r         return;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_bfs_TreeNodemul_TreeNodemul_TreeNodemul_random_0(void) {\n{\nAKA_test_case_name=\"Solution_bfs_TreeNodemul_TreeNodemul_TreeNodemul_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int,TreeNode*,TreeNode*) */\n/* NormalNumberDataNode x */\nint root0_x=-662025350;\n/* PointerStructureDataNode left */\nTreeNode* root0_left;\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root0_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\bfs(TreeNode*,TreeNode*,TreeNode*&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int,TreeNode*,TreeNode*)\\\\right\\\\right[0]\\\\right\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root0_right_0 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root0_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root0_right_0).right;\nAKA_VECTOR_INIT_root0_right.push_back(AKA_VECTOR_INIT_root0_right_0);\nTreeNode* root0_right = AKA_VECTOR_INIT_root0_right[0];\nAKA_mark(\"Calling: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\TreeNode\\\\TreeNode(int,TreeNode*,TreeNode*)|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\bfs(TreeNode*,TreeNode*,TreeNode*&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int,TreeNode*,TreeNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x,root0_left,root0_right);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\bfs(TreeNode*,TreeNode*,TreeNode*&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\right\\\\right[0]\\\\right\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_right_0 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_right_0).right;\nAKA_VECTOR_INIT_root_0_DOT_right.push_back(AKA_VECTOR_INIT_root_0_DOT_right_0);\n(*AKA_VECTOR_INIT_root_0).right = AKA_VECTOR_INIT_root_0_DOT_right[0];\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int,TreeNode*,TreeNode*) */\n/* NormalNumberDataNode x */\nint root1_x=0;\n/* PointerStructureDataNode left */\nTreeNode* root1_left;\n/* PointerStructureDataNode right */\nTreeNode* root1_right;\nAKA_mark(\"Calling: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\TreeNode\\\\TreeNode(int,TreeNode*,TreeNode*)|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\bfs(TreeNode*,TreeNode*,TreeNode*&)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int,TreeNode*,TreeNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x,root1_left,root1_right);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nTreeNode* u;\nTreeNode* res;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* PointerStructureDataNode u */\n/* PointerStructureDataNode res */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_bfs_TreeNodemul_TreeNodemul_TreeNodemul_random_0\");AKA_INSTANCE___Solution->bfs(root,u,res);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\Solution\\\\bfs(TreeNode*,TreeNode*,TreeNode*&)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1556-thousand-separator.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=1366375546;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_bfs_TreeNodemul_TreeNodemul_TreeNodemul_random_4(void) {\n{\nAKA_test_case_name=\"Solution_bfs_TreeNodemul_TreeNodemul_TreeNodemul_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=168564471;\nAKA_mark(\"Calling: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\bfs(TreeNode*,TreeNode*,TreeNode*&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\bfs(TreeNode*,TreeNode*,TreeNode*&)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\bfs(TreeNode*,TreeNode*,TreeNode*&)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nTreeNode* u;\nTreeNode* res;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* PointerStructureDataNode u */\n/* PointerStructureDataNode res */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_bfs_TreeNodemul_TreeNodemul_TreeNodemul_random_4\");AKA_INSTANCE___Solution->bfs(root,u,res);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\Solution\\\\bfs(TreeNode*,TreeNode*,TreeNode*&)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1557-minimum-number-of-vertices-to-reach-all-nodes.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=5;\nvector<vector<int>> edges;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* VectorDataNode edges */\nvector<int> edges_element0;\nint edges_element0_element0=1589038942;\nedges_element0.push_back(edges_element0_element0);\nedges.push_back(edges_element0);\nvector<int> edges_element1;\nint edges_element1_element0=104046497;\nedges_element1.push_back(edges_element1_element0);\nedges.push_back(edges_element1);\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     void bfs(TreeNode* root, TreeNode* u, TreeNode* &res) {\r         \r         if(root == NULL)                                  return;\r         \r         queue<TreeNode*> q;\r         q.push(root);\r         \r         while(q.empty() == false) {\r             \r             int n = q.size();\r             \r             // At one level, it has n nodes\r             int i = 0, j = -1;\r             bool flag = false;\r             \r             for( ; i<n; i++) {\r                 \r                 TreeNode* temp = q.front();\r                 q.pop();\r                 \r                 // If u is the rightmost node at a level\r                 if(i == n-1 && temp == u) {\r                     res = NULL;\r                     return;\r                 }\r \r                 // if u is not the rightmost node at a level\r                 if(flag == true && i == j) {\r                     res = temp;\r                     return;\r                 }\r                 \r                 if(i < n-1 && temp == u) {\r                     j = i + 1;\r                     flag = true;\r                 }\r                 \r                 if(temp->left != NULL)                      q.push(temp->left);\r                 if(temp->right != NULL)                     q.push(temp->right);\r             }\r         }\r         \r         return;\r     }\r     \r     TreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {\r     \r         TreeNode* res = NULL;\r         \r         if(root == NULL)                                    return res;\r         \r         bfs(root, u, res);\r         return res;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p40\\1602-find-nearest-right-node-in-binary-tree\\1602-find-nearest-right-node-in-binary-tree.cpp\\Solution\\bfs(TreeNode*,TreeNode*,TreeNode*&)"
    },
    {
        "f": [],
        "fm": "TreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {\r     \r         TreeNode* res = NULL;\r         \r         if(root == NULL)                                    return res;\r         \r         bfs(root, u, res);\r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_findNearestRightNode_TreeNodemul_TreeNodemul_random_4(void) {\n{\nAKA_test_case_name=\"Solution_findNearestRightNode_TreeNodemul_TreeNodemul_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\findNearestRightNode(TreeNode*,TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int,TreeNode*,TreeNode*) */\n/* NormalNumberDataNode x */\nint root1_x=2026815051;\n/* PointerStructureDataNode left */\nTreeNode* root1_left;\n/* PointerStructureDataNode right */\nTreeNode* root1_right;\nAKA_mark(\"Calling: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\TreeNode\\\\TreeNode(int,TreeNode*,TreeNode*)|ROOT\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\findNearestRightNode(TreeNode*,TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int,TreeNode*,TreeNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x,root1_left,root1_right);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nTreeNode* u;\nTreeNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* PointerStructureDataNode u */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findNearestRightNode_TreeNodemul_TreeNodemul_random_4\");TreeNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findNearestRightNode(root,u);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p40\\\\1602-find-nearest-right-node-in-binary-tree\\\\1602-find-nearest-right-node-in-binary-tree.cpp\\\\Solution\\\\findNearestRightNode(TreeNode*,TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1556-thousand-separator.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=1366375546;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     void bfs(TreeNode* root, TreeNode* u, TreeNode* &res) {\r         \r         if(root == NULL)                                  return;\r         \r         queue<TreeNode*> q;\r         q.push(root);\r         \r         while(q.empty() == false) {\r             \r             int n = q.size();\r             \r             // At one level, it has n nodes\r             int i = 0, j = -1;\r             bool flag = false;\r             \r             for( ; i<n; i++) {\r                 \r                 TreeNode* temp = q.front();\r                 q.pop();\r                 \r                 // If u is the rightmost node at a level\r                 if(i == n-1 && temp == u) {\r                     res = NULL;\r                     return;\r                 }\r \r                 // if u is not the rightmost node at a level\r                 if(flag == true && i == j) {\r                     res = temp;\r                     return;\r                 }\r                 \r                 if(i < n-1 && temp == u) {\r                     j = i + 1;\r                     flag = true;\r                 }\r                 \r                 if(temp->left != NULL)                      q.push(temp->left);\r                 if(temp->right != NULL)                     q.push(temp->right);\r             }\r         }\r         \r         return;\r     }\r     \r     TreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {\r     \r         TreeNode* res = NULL;\r         \r         if(root == NULL)                                    return res;\r         \r         bfs(root, u, res);\r         return res;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p40\\1602-find-nearest-right-node-in-binary-tree\\1602-find-nearest-right-node-in-binary-tree.cpp\\Solution\\findNearestRightNode(TreeNode*,TreeNode*)"
    },
    {
        "f": [
            "vector<int> v;"
        ],
        "fm": "bool addCar(int carType) {\r              \r         if(v[carType] >= 1) {\r             v[carType]--;\r             return true;\r          }\r          \r         else                                          return false;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_ParkingSystem_addCar_int_random_0(void) {\n{\nAKA_test_case_name=\"ParkingSystem_addCar_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___ParkingSystem */\n/* ConstructorDataNode ParkingSystem(int,int,int) */\n/* NormalNumberDataNode big */\nint AKA_INSTANCE___ParkingSystem_big=-951657512;\n/* NormalNumberDataNode medium */\nint AKA_INSTANCE___ParkingSystem_medium=430068150;\n/* NormalNumberDataNode small */\nint AKA_INSTANCE___ParkingSystem_small=943303286;\nAKA_mark(\"Calling: .\\\\p40\\\\1603-design-parking-system\\\\1603-design-parking-system.cpp\\\\ParkingSystem\\\\ParkingSystem(int,int,int)|ROOT\\\\1603-design-parking-system.cpp\\\\GLOBAL\\\\AKA_INSTANCE___ParkingSystem\\\\AKA_INSTANCE___ParkingSystem\\\\ParkingSystem(int,int,int)\");AKA_fCall++;AKA_INSTANCE___ParkingSystem = new ::ParkingSystem(AKA_INSTANCE___ParkingSystem_big,AKA_INSTANCE___ParkingSystem_medium,AKA_INSTANCE___ParkingSystem_small);\n/* VectorDataNode v */\nint AKA_INSTANCE___ParkingSystem_v_element0=-841945291;\nAKA_INSTANCE___ParkingSystem->v.push_back(AKA_INSTANCE___ParkingSystem_v_element0);\nint AKA_INSTANCE___ParkingSystem_v_element1=-815538471;\nAKA_INSTANCE___ParkingSystem->v.push_back(AKA_INSTANCE___ParkingSystem_v_element1);\nint AKA_INSTANCE___ParkingSystem_v_element2=-94842767;\nAKA_INSTANCE___ParkingSystem->v.push_back(AKA_INSTANCE___ParkingSystem_v_element2);\n\n\n\n\nint carType=-241486486;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode carType */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test ParkingSystem_addCar_int_random_0\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___ParkingSystem->addCar(carType);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p40\\\\1603-design-parking-system\\\\1603-design-parking-system.cpp\\\\ParkingSystem\\\\addCar(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1556-thousand-separator.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=1366375546;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class ParkingSystem {\r public:\r     \r     vector<int> v;\r     \r     ParkingSystem(int big, int medium, int small) {\r     \r         v.resize(4);\r         \r         v[1] = big;\r         v[2] = medium;\r         v[3] = small;\r     }\r     \r     bool addCar(int carType) {\r              \r         if(v[carType] >= 1) {\r             v[carType]--;\r             return true;\r          }\r          \r         else                                          return false;\r     }\r     \r };",
        "c": [
            "ParkingSystem(int big, int medium, int small) {\r\n    \r\n        v.resize(4);\r\n        \r\n        v[1] = big;\r\n        v[2] = medium;\r\n        v[3] = small;\r\n    }"
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p40\\1603-design-parking-system\\1603-design-parking-system.cpp\\ParkingSystem\\addCar(int)"
    }
]