[
    {
        "f": [],
        "fm": "int minSubArrayLen(int target, vector<int>& a) {\r     \r         int res = INT_MAX;\r         int n = a.size();\r         \r         int start = 0, end = 0;\r         int sum = 0;\r         \r         while(start < n && end < n) {\r             \r             if(sum >= target) {\r                 \r                 end--;\r                 res = min(res, end - start + 1);\r                 \r                 sum -= a[start];\r                 \r                 start++;\r                 end++;\r             }\r             \r             else {\r                 \r                 // We need to add element to our search space\r                 sum += a[end];\r                 end++;\r             }\r         }\r         \r         end--;\r         \r         while(sum >= target) {\r             \r             res = min(res, end - start + 1);\r             \r             sum -= a[start];\r             start++;\r         }\r         \r         if(res == INT_MAX)                                      return 0;\r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_minSubArrayLen_int_vector_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_minSubArrayLen_int_vector_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\209-minimum-size-subarray-sum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint target=8;\nvector<int> a;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode target */\n/* VectorDataNode a */\nint a_element0=700387120;\na.push_back(a_element0);\nint a_element1=1125538713;\na.push_back(a_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minSubArrayLen_int_vector_int_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minSubArrayLen(target,a);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\209-minimum-size-subarray-sum\\\\209-minimum-size-subarray-sum.cpp\\\\Solution\\\\minSubArrayLen(int,vector<int>&)\");\n\n\nvector<int> EXPECTED_a;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\206-reverse-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-150005685;\nAKA_mark(\"Calling: .\\\\p63\\\\206-reverse-linked-list\\\\206-reverse-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\206-reverse-linked-list.cpp\\\\reverseList(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_minSubArrayLen_int_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_minSubArrayLen_int_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\209-minimum-size-subarray-sum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint target=0;\nvector<int> a;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode target */\n/* VectorDataNode a */\nint a_element0=-1727634157;\na.push_back(a_element0);\nint a_element1=1530351748;\na.push_back(a_element1);\nint a_element2=574870940;\na.push_back(a_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minSubArrayLen_int_vector_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minSubArrayLen(target,a);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\209-minimum-size-subarray-sum\\\\209-minimum-size-subarray-sum.cpp\\\\Solution\\\\minSubArrayLen(int,vector<int>&)\");\n\n\nvector<int> EXPECTED_a;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\2062-count-vowel-substrings-of-a-string.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName921319 = new char[2];akaRandomName921319[0] = 111;akaRandomName921319[1] = '\\0';string word=akaRandomName921319;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_minSubArrayLen_int_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_minSubArrayLen_int_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\209-minimum-size-subarray-sum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint target=1;\nvector<int> a;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode target */\n/* VectorDataNode a */\nint a_element0=-1638819485;\na.push_back(a_element0);\nint a_element1=873896918;\na.push_back(a_element1);\nint a_element2=-505762074;\na.push_back(a_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minSubArrayLen_int_vector_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minSubArrayLen(target,a);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\209-minimum-size-subarray-sum\\\\209-minimum-size-subarray-sum.cpp\\\\Solution\\\\minSubArrayLen(int,vector<int>&)\");\n\n\nvector<int> EXPECTED_a;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\2062-count-vowel-substrings-of-a-string.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName619384 = new char[2];akaRandomName619384[0] = -1;akaRandomName619384[1] = '\\0';string word=akaRandomName619384;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     int minSubArrayLen(int target, vector<int>& a) {\r     \r         int res = INT_MAX;\r         int n = a.size();\r         \r         int start = 0, end = 0;\r         int sum = 0;\r         \r         while(start < n && end < n) {\r             \r             if(sum >= target) {\r                 \r                 end--;\r                 res = min(res, end - start + 1);\r                 \r                 sum -= a[start];\r                 \r                 start++;\r                 end++;\r             }\r             \r             else {\r                 \r                 // We need to add element to our search space\r                 sum += a[end];\r                 end++;\r             }\r         }\r         \r         end--;\r         \r         while(sum >= target) {\r             \r             res = min(res, end - start + 1);\r             \r             sum -= a[start];\r             start++;\r         }\r         \r         if(res == INT_MAX)                                      return 0;\r         return res;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p65\\209-minimum-size-subarray-sum\\209-minimum-size-subarray-sum.cpp\\Solution\\minSubArrayLen(int,vector<int>&)"
    },
    {
        "f": [],
        "fm": "ListNode* deleteMiddle(ListNode* head) {\r     \r         // If len of LL = 1, then return NULL\r         if(head->next == NULL)                                      return NULL;\r         \r         ListNode* slow = head;\r         ListNode* fast = head->next->next;\r         \r         // Slow pointer goes node-by-node, and fast pointer skips a node. \r         // When the fast node reaches the end, the slow node will point to the middle.\r         \r         while(fast != NULL && fast->next != NULL) {\r             \r             fast = fast->next->next;\r             slow = slow->next;\r         }\r         \r         // Here, slow node is the one node before the middle node\r         slow->next = slow->next->next;\r        \r         return head;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_deleteMiddle_ListNodemul_random_3(void) {\n{\nAKA_test_case_name=\"Solution_deleteMiddle_ListNodemul_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-641990054;\nAKA_mark(\"Calling: .\\\\p65\\\\2095-delete-the-middle-node-of-a-linked-list\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\deleteMiddle(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next0_x=-1529773402;\nAKA_mark(\"Calling: .\\\\p65\\\\2095-delete-the-middle-node-of-a-linked-list\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\deleteMiddle(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode(head0_next0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head1_x=773456308;\n/* PointerStructureDataNode next */\nListNode* head1_next;\nAKA_mark(\"Calling: .\\\\p65\\\\2095-delete-the-middle-node-of-a-linked-list\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\deleteMiddle(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x,head1_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_deleteMiddle_ListNodemul_random_3\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->deleteMiddle(head);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\2095-delete-the-middle-node-of-a-linked-list\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\Solution\\\\deleteMiddle(ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\206-reverse-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-150005685;\nAKA_mark(\"Calling: .\\\\p63\\\\206-reverse-linked-list\\\\206-reverse-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\206-reverse-linked-list.cpp\\\\reverseList(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_deleteMiddle_ListNodemul_random_0(void) {\n{\nAKA_test_case_name=\"Solution_deleteMiddle_ListNodemul_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode() */\nAKA_mark(\"Calling: .\\\\p65\\\\2095-delete-the-middle-node-of-a-linked-list\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\ListNode\\\\ListNode()|ROOT\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\deleteMiddle(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head0_next0_x=1432399893;\n/* PointerStructureDataNode next */\nListNode* head0_next0_next;\nAKA_mark(\"Calling: .\\\\p65\\\\2095-delete-the-middle-node-of-a-linked-list\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\deleteMiddle(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[0]\\\\next\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode(head0_next0_x,head0_next0_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head1_x=1278513120;\n/* PointerStructureDataNode next */\nListNode* head1_next;\nAKA_mark(\"Calling: .\\\\p65\\\\2095-delete-the-middle-node-of-a-linked-list\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\deleteMiddle(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x,head1_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_deleteMiddle_ListNodemul_random_0\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->deleteMiddle(head);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\2095-delete-the-middle-node-of-a-linked-list\\\\2095-delete-the-middle-node-of-a-linked-list.cpp\\\\Solution\\\\deleteMiddle(ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\2062-count-vowel-substrings-of-a-string.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName921319 = new char[2];akaRandomName921319[0] = 111;akaRandomName921319[1] = '\\0';string word=akaRandomName921319;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     ListNode* deleteMiddle(ListNode* head) {\r     \r         // If len of LL = 1, then return NULL\r         if(head->next == NULL)                                      return NULL;\r         \r         ListNode* slow = head;\r         ListNode* fast = head->next->next;\r         \r         // Slow pointer goes node-by-node, and fast pointer skips a node. \r         // When the fast node reaches the end, the slow node will point to the middle.\r         \r         while(fast != NULL && fast->next != NULL) {\r             \r             fast = fast->next->next;\r             slow = slow->next;\r         }\r         \r         // Here, slow node is the one node before the middle node\r         slow->next = slow->next->next;\r        \r         return head;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p65\\2095-delete-the-middle-node-of-a-linked-list\\2095-delete-the-middle-node-of-a-linked-list.cpp\\Solution\\deleteMiddle(ListNode*)"
    },
    {
        "f": [],
        "fm": "vector<int> maxSubsequence(vector<int>& a, int k) {\r     \r         vector<int> res;\r         \r         // Our moto is to put the k largest element in pq of size k, where bottom being the greatest\r         \r         // Form Min heap\r         using pi = pair<int, int>;                               // 1st arg - element, 2nd arg - index\r         priority_queue<pi, vector<pi>, greater<pi>> pq;\r         \r         for(int i=0; i<a.size(); i++) {\r             pq.push({a[i], i});\r             if(pq.size() > k)                       pq.pop();\r         }\r         \r         // Order should not change\r         vector<pi> temp;                            // 1st arg - index, 2nd arg - element\r         \r         while(pq.empty() == false) {\r             temp.push_back({pq.top().second, pq.top().first});\r             pq.pop();\r         }\r         \r         // sort according to indexes\r         sort(temp.begin(), temp.end());\r         \r         for(auto &x : temp)                         res.push_back(x.second);\r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxSubsequence_vector_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxSubsequence_vector_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\2099-find-subsequence-of-length-k-with-the-largest-sum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> a;\n\n\nint k=-433332544;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode a */\nint a_element0=2106254197;\na.push_back(a_element0);\nint a_element1=-525432206;\na.push_back(a_element1);\n/* NormalNumberDataNode k */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxSubsequence_vector_int_int_random_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxSubsequence(a,k);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\2099-find-subsequence-of-length-k-with-the-largest-sum\\\\2099-find-subsequence-of-length-k-with-the-largest-sum.cpp\\\\Solution\\\\maxSubsequence(vector<int>&,int)\");\n\n\nvector<int> EXPECTED_a;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\206-reverse-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-150005685;\nAKA_mark(\"Calling: .\\\\p63\\\\206-reverse-linked-list\\\\206-reverse-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\206-reverse-linked-list.cpp\\\\reverseList(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     vector<int> maxSubsequence(vector<int>& a, int k) {\r     \r         vector<int> res;\r         \r         // Our moto is to put the k largest element in pq of size k, where bottom being the greatest\r         \r         // Form Min heap\r         using pi = pair<int, int>;                               // 1st arg - element, 2nd arg - index\r         priority_queue<pi, vector<pi>, greater<pi>> pq;\r         \r         for(int i=0; i<a.size(); i++) {\r             pq.push({a[i], i});\r             if(pq.size() > k)                       pq.pop();\r         }\r         \r         // Order should not change\r         vector<pi> temp;                            // 1st arg - index, 2nd arg - element\r         \r         while(pq.empty() == false) {\r             temp.push_back({pq.top().second, pq.top().first});\r             pq.pop();\r         }\r         \r         // sort according to indexes\r         sort(temp.begin(), temp.end());\r         \r         for(auto &x : temp)                         res.push_back(x.second);\r         return res;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p65\\2099-find-subsequence-of-length-k-with-the-largest-sum\\2099-find-subsequence-of-length-k-with-the-largest-sum.cpp\\Solution\\maxSubsequence(vector<int>&,int)"
    },
    {
        "f": [],
        "fm": "void addNodeAtBeginning(ListNode** head, int node) {\r         \r         ListNode* temp = new ListNode(node);\r         \r         if(head == NULL) {\r             *head = temp;    \r             return;\r         }\r         \r         temp->next = *head;\r         *head = temp;\r         \r         return;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_addNodeAtBeginning_ListNodemulmul_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_addNodeAtBeginning_ListNodemulmul_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\21-merge-two-sorted-lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode**> AKA_VECTOR_INIT_head;\nAKA_VECTOR_INIT_head_0;\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode** head = AKA_VECTOR_INIT_head[0];\n\n\nint node=-2094371603;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode node */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_addNodeAtBeginning_ListNodemulmul_int_random_0\");AKA_INSTANCE___Solution->addNodeAtBeginning(head,node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\21-merge-two-sorted-lists\\\\21-merge-two-sorted-lists.cpp\\\\Solution\\\\addNodeAtBeginning(ListNode**,int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\206-reverse-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-150005685;\nAKA_mark(\"Calling: .\\\\p63\\\\206-reverse-linked-list\\\\206-reverse-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\206-reverse-linked-list.cpp\\\\reverseList(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     // Add node at beginning\r     \r     void addNodeAtBeginning(ListNode** head, int node) {\r         \r         ListNode* temp = new ListNode(node);\r         \r         if(head == NULL) {\r             *head = temp;    \r             return;\r         }\r         \r         temp->next = *head;\r         *head = temp;\r         \r         return;\r     }\r     \r     ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\r     \r         ListNode* head = NULL;\r         vector<int> v;\r         \r         while(list1 != NULL) {\r             v.push_back(list1->val);\r             list1 = list1->next;\r         }\r         \r         while(list2 != NULL) {\r             v.push_back(list2->val);\r             list2 = list2->next;\r         }\r         \r         sort(v.begin(), v.end(), greater<int>());\r         \r         for(auto &x : v) {\r             addNodeAtBeginning(&head, x);      \r         }\r         \r         return head;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p65\\21-merge-two-sorted-lists\\21-merge-two-sorted-lists.cpp\\Solution\\addNodeAtBeginning(ListNode**,int)"
    },
    {
        "f": [],
        "fm": "ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\r     \r         ListNode* head = NULL;\r         vector<int> v;\r         \r         while(list1 != NULL) {\r             v.push_back(list1->val);\r             list1 = list1->next;\r         }\r         \r         while(list2 != NULL) {\r             v.push_back(list2->val);\r             list2 = list2->next;\r         }\r         \r         sort(v.begin(), v.end(), greater<int>());\r         \r         for(auto &x : v) {\r             addNodeAtBeginning(&head, x);      \r         }\r         \r         return head;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_mergeTwoLists_ListNodemul_ListNodemul_random_3(void) {\n{\nAKA_test_case_name=\"Solution_mergeTwoLists_ListNodemul_ListNodemul_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\21-merge-two-sorted-lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nListNode* list1;\nstd::vector<ListNode*> AKA_VECTOR_INIT_list2;\n\n\n/* SubStructDataNode list2 */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint list20_x=1498695985;\n/* PointerStructureDataNode next */\nListNode* list20_next;\nAKA_mark(\"Calling: .\\\\p65\\\\21-merge-two-sorted-lists\\\\21-merge-two-sorted-lists.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\21-merge-two-sorted-lists.cpp\\\\mergeTwoLists(ListNode*,ListNode*)\\\\list2\\\\AKA_VECTOR_INIT_list2_0\\\\list2\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_list2_0 = new ::ListNode(list20_x,list20_next);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_list2_0).val=-1262108694;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_list2_0).next;\n\nAKA_VECTOR_INIT_list2.push_back(AKA_VECTOR_INIT_list2_0);\n\n\n/* SubStructDataNode list2 */\n/* ConstructorDataNode ListNode() */\nAKA_mark(\"Calling: .\\\\p65\\\\21-merge-two-sorted-lists\\\\21-merge-two-sorted-lists.cpp\\\\ListNode\\\\ListNode()|ROOT\\\\21-merge-two-sorted-lists.cpp\\\\mergeTwoLists(ListNode*,ListNode*)\\\\list2\\\\AKA_VECTOR_INIT_list2_1\\\\list2\\\\ListNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_list2_1 = new ::ListNode();\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_list2_1).val=-1783254372;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_list2_1).next;\n\nAKA_VECTOR_INIT_list2.push_back(AKA_VECTOR_INIT_list2_1);\n\n\n/* SubStructDataNode list2 */\n/* ConstructorDataNode ListNode() */\nAKA_mark(\"Calling: .\\\\p65\\\\21-merge-two-sorted-lists\\\\21-merge-two-sorted-lists.cpp\\\\ListNode\\\\ListNode()|ROOT\\\\21-merge-two-sorted-lists.cpp\\\\mergeTwoLists(ListNode*,ListNode*)\\\\list2\\\\AKA_VECTOR_INIT_list2_2\\\\list2\\\\ListNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_list2_2 = new ::ListNode();\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_list2_2).val=1418590981;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_list2_2).next;\n\nAKA_VECTOR_INIT_list2.push_back(AKA_VECTOR_INIT_list2_2);\n\nListNode* list2 = AKA_VECTOR_INIT_list2[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode list1 */\n/* PointerStructureDataNode list2 */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_mergeTwoLists_ListNodemul_ListNodemul_random_3\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->mergeTwoLists(list1,list2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\21-merge-two-sorted-lists\\\\21-merge-two-sorted-lists.cpp\\\\Solution\\\\mergeTwoLists(ListNode*,ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\206-reverse-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-150005685;\nAKA_mark(\"Calling: .\\\\p63\\\\206-reverse-linked-list\\\\206-reverse-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\206-reverse-linked-list.cpp\\\\reverseList(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     // Add node at beginning\r     \r     void addNodeAtBeginning(ListNode** head, int node) {\r         \r         ListNode* temp = new ListNode(node);\r         \r         if(head == NULL) {\r             *head = temp;    \r             return;\r         }\r         \r         temp->next = *head;\r         *head = temp;\r         \r         return;\r     }\r     \r     ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\r     \r         ListNode* head = NULL;\r         vector<int> v;\r         \r         while(list1 != NULL) {\r             v.push_back(list1->val);\r             list1 = list1->next;\r         }\r         \r         while(list2 != NULL) {\r             v.push_back(list2->val);\r             list2 = list2->next;\r         }\r         \r         sort(v.begin(), v.end(), greater<int>());\r         \r         for(auto &x : v) {\r             addNodeAtBeginning(&head, x);      \r         }\r         \r         return head;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p65\\21-merge-two-sorted-lists\\21-merge-two-sorted-lists.cpp\\Solution\\mergeTwoLists(ListNode*,ListNode*)"
    },
    {
        "f": [],
        "fm": "void bfs(int n, unordered_map<int, vector<int>> &adj, vector<int> &indegree, vector<int> &res) {\r         \r         queue<int> q;\r         \r         for(int i=0; i<n; i++) {\r             if(indegree[i] == 0)            q.push(i);\r         }\r         \r         while(q.empty() == false) {\r             \r             int n = q.size();\r             \r             while(n--) {\r                 \r                 int temp = q.front();\r                 q.pop();\r                 \r                 res.push_back(temp);\r                 \r                 for(int j=0; j<adj[temp].size(); j++) {\r                     \r                     int child = adj[temp][j];\r                     indegree[child]--;\r                     \r                     if(indegree[child] == 0) {\r                         q.push(child);\r                     }\r                 }\r             }\r         }\r         \r         return;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_bfs_int_unordered_map_int_vector_int_vector_int_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_bfs_int_unordered_map_int_vector_int_vector_int_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\210-course-schedule-ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=7;\nunordered_map<int, vector<int>> adj;\nvector<int> indegree;\nvector<int> res;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* UnorderedMapDataNode adj */\n/* VectorDataNode indegree */\nint indegree_element0=-1971028696;\nindegree.push_back(indegree_element0);\nint indegree_element1=491175209;\nindegree.push_back(indegree_element1);\nint indegree_element2=9561196;\nindegree.push_back(indegree_element2);\n/* VectorDataNode res */\nint res_element0=746040984;\nres.push_back(res_element0);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_bfs_int_unordered_map_int_vector_int_vector_int_vector_int_random_4\");AKA_INSTANCE___Solution->bfs(n,adj,indegree,res);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\210-course-schedule-ii\\\\210-course-schedule-ii.cpp\\\\Solution\\\\bfs(int,unordered_map<int,vector<int>>&,vector<int>&,vector<int>&)\");\n\n/* error assertion */\nunordered_map<int, vector<int>> EXPECTED_adj;\n\nvector<int> EXPECTED_indegree;\n\nvector<int> EXPECTED_res;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\206-reverse-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-150005685;\nAKA_mark(\"Calling: .\\\\p63\\\\206-reverse-linked-list\\\\206-reverse-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\206-reverse-linked-list.cpp\\\\reverseList(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     void bfs(int n, unordered_map<int, vector<int>> &adj, vector<int> &indegree, vector<int> &res) {\r         \r         queue<int> q;\r         \r         for(int i=0; i<n; i++) {\r             if(indegree[i] == 0)            q.push(i);\r         }\r         \r         while(q.empty() == false) {\r             \r             int n = q.size();\r             \r             while(n--) {\r                 \r                 int temp = q.front();\r                 q.pop();\r                 \r                 res.push_back(temp);\r                 \r                 for(int j=0; j<adj[temp].size(); j++) {\r                     \r                     int child = adj[temp][j];\r                     indegree[child]--;\r                     \r                     if(indegree[child] == 0) {\r                         q.push(child);\r                     }\r                 }\r             }\r         }\r         \r         return;\r     }\r     \r     // Returns true if contains a cycle\r     bool dfs(vector<int> &vis, unordered_map<int, vector<int>> &adj, int node) {\r         \r         // 0 - unvisited, 1 - processing, 2 - processed\r         \r         if(vis[node] == 2)                              return true;\r         \r         vis[node] = 2;\r         \r         for(int i=0; i<adj[node].size(); i++) {\r             \r             int child = adj[node][i];\r             \r             if(vis[child] != 1) {\r                 if(dfs(vis, adj, child) == true)        return true;\r             }\r         }\r         \r         vis[node] = 1;\r         return false;\r     }\r     \r     vector<int> findOrder(int n, vector<vector<int>>& prereq) {\r     \r         vector<int> res;\r         \r         // Using Topological sorting\r         \r         vector<int> indegree(n, 0), vis(n, 0);\r         unordered_map<int, vector<int>> adj;\r         \r         for(auto &x : prereq) {\r             \r             int u = x[0];\r             int v = x[1];\r             \r             // v -> u\r             adj[v].push_back(u);\r             indegree[u]++;\r         }\r         \r         bool flag = false;      // if cycle is not present\r         \r         for(int i=0; i<n; i++) {\r             \r             if(flag == true)    break;\r             \r             if(vis[i] == 0) {\r                 if(dfs(vis, adj, i) == true) {\r                     flag = true;\r                     break;\r                 }\r             }\r         }\r         \r         if(flag == false)       bfs(n, adj, indegree, res);\r         \r         return res;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p65\\210-course-schedule-ii\\210-course-schedule-ii.cpp\\Solution\\bfs(int,unordered_map<int,vector<int>>&,vector<int>&,vector<int>&)"
    },
    {
        "f": [],
        "fm": "bool dfs(vector<int> &vis, unordered_map<int, vector<int>> &adj, int node) {\r         \r         // 0 - unvisited, 1 - processing, 2 - processed\r         \r         if(vis[node] == 2)                              return true;\r         \r         vis[node] = 2;\r         \r         for(int i=0; i<adj[node].size(); i++) {\r             \r             int child = adj[node][i];\r             \r             if(vis[child] != 1) {\r                 if(dfs(vis, adj, child) == true)        return true;\r             }\r         }\r         \r         vis[node] = 1;\r         return false;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_dfs_vector_int_unordered_map_int_vector_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_dfs_vector_int_unordered_map_int_vector_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\210-course-schedule-ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> vis;\nunordered_map<int, vector<int>> adj;\n\n\nint node=-1286323485;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode vis */\nint vis_element0=1443609751;\nvis.push_back(vis_element0);\n/* UnorderedMapDataNode adj */\n/* NormalNumberDataNode node */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_dfs_vector_int_unordered_map_int_vector_int_int_random_0\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->dfs(vis,adj,node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\210-course-schedule-ii\\\\210-course-schedule-ii.cpp\\\\Solution\\\\dfs(vector<int>&,unordered_map<int,vector<int>>&,int)\");\n\n\nvector<int> EXPECTED_vis;\n\nunordered_map<int, vector<int>> EXPECTED_adj;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\206-reverse-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-150005685;\nAKA_mark(\"Calling: .\\\\p63\\\\206-reverse-linked-list\\\\206-reverse-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\206-reverse-linked-list.cpp\\\\reverseList(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     void bfs(int n, unordered_map<int, vector<int>> &adj, vector<int> &indegree, vector<int> &res) {\r         \r         queue<int> q;\r         \r         for(int i=0; i<n; i++) {\r             if(indegree[i] == 0)            q.push(i);\r         }\r         \r         while(q.empty() == false) {\r             \r             int n = q.size();\r             \r             while(n--) {\r                 \r                 int temp = q.front();\r                 q.pop();\r                 \r                 res.push_back(temp);\r                 \r                 for(int j=0; j<adj[temp].size(); j++) {\r                     \r                     int child = adj[temp][j];\r                     indegree[child]--;\r                     \r                     if(indegree[child] == 0) {\r                         q.push(child);\r                     }\r                 }\r             }\r         }\r         \r         return;\r     }\r     \r     // Returns true if contains a cycle\r     bool dfs(vector<int> &vis, unordered_map<int, vector<int>> &adj, int node) {\r         \r         // 0 - unvisited, 1 - processing, 2 - processed\r         \r         if(vis[node] == 2)                              return true;\r         \r         vis[node] = 2;\r         \r         for(int i=0; i<adj[node].size(); i++) {\r             \r             int child = adj[node][i];\r             \r             if(vis[child] != 1) {\r                 if(dfs(vis, adj, child) == true)        return true;\r             }\r         }\r         \r         vis[node] = 1;\r         return false;\r     }\r     \r     vector<int> findOrder(int n, vector<vector<int>>& prereq) {\r     \r         vector<int> res;\r         \r         // Using Topological sorting\r         \r         vector<int> indegree(n, 0), vis(n, 0);\r         unordered_map<int, vector<int>> adj;\r         \r         for(auto &x : prereq) {\r             \r             int u = x[0];\r             int v = x[1];\r             \r             // v -> u\r             adj[v].push_back(u);\r             indegree[u]++;\r         }\r         \r         bool flag = false;      // if cycle is not present\r         \r         for(int i=0; i<n; i++) {\r             \r             if(flag == true)    break;\r             \r             if(vis[i] == 0) {\r                 if(dfs(vis, adj, i) == true) {\r                     flag = true;\r                     break;\r                 }\r             }\r         }\r         \r         if(flag == false)       bfs(n, adj, indegree, res);\r         \r         return res;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p65\\210-course-schedule-ii\\210-course-schedule-ii.cpp\\Solution\\dfs(vector<int>&,unordered_map<int,vector<int>>&,int)"
    },
    {
        "f": [],
        "fm": "vector<int> findOrder(int n, vector<vector<int>>& prereq) {\r     \r         vector<int> res;\r         \r         // Using Topological sorting\r         \r         vector<int> indegree(n, 0), vis(n, 0);\r         unordered_map<int, vector<int>> adj;\r         \r         for(auto &x : prereq) {\r             \r             int u = x[0];\r             int v = x[1];\r             \r             // v -> u\r             adj[v].push_back(u);\r             indegree[u]++;\r         }\r         \r         bool flag = false;      // if cycle is not present\r         \r         for(int i=0; i<n; i++) {\r             \r             if(flag == true)    break;\r             \r             if(vis[i] == 0) {\r                 if(dfs(vis, adj, i) == true) {\r                     flag = true;\r                     break;\r                 }\r             }\r         }\r         \r         if(flag == false)       bfs(n, adj, indegree, res);\r         \r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_findOrder_int_vector_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_findOrder_int_vector_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\210-course-schedule-ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=9;\nvector<vector<int>> prereq;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* VectorDataNode prereq */\nvector<int> prereq_element0;\nint prereq_element0_element0=-1794487361;\nprereq_element0.push_back(prereq_element0_element0);\nprereq.push_back(prereq_element0);\nvector<int> prereq_element1;\nint prereq_element1_element0=-238674996;\nprereq_element1.push_back(prereq_element1_element0);\nprereq.push_back(prereq_element1);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findOrder_int_vector_vector_int_random_2\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findOrder(n,prereq);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p65\\\\210-course-schedule-ii\\\\210-course-schedule-ii.cpp\\\\Solution\\\\findOrder(int,vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_prereq;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\206-reverse-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-150005685;\nAKA_mark(\"Calling: .\\\\p63\\\\206-reverse-linked-list\\\\206-reverse-linked-list.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\206-reverse-linked-list.cpp\\\\reverseList(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     void bfs(int n, unordered_map<int, vector<int>> &adj, vector<int> &indegree, vector<int> &res) {\r         \r         queue<int> q;\r         \r         for(int i=0; i<n; i++) {\r             if(indegree[i] == 0)            q.push(i);\r         }\r         \r         while(q.empty() == false) {\r             \r             int n = q.size();\r             \r             while(n--) {\r                 \r                 int temp = q.front();\r                 q.pop();\r                 \r                 res.push_back(temp);\r                 \r                 for(int j=0; j<adj[temp].size(); j++) {\r                     \r                     int child = adj[temp][j];\r                     indegree[child]--;\r                     \r                     if(indegree[child] == 0) {\r                         q.push(child);\r                     }\r                 }\r             }\r         }\r         \r         return;\r     }\r     \r     // Returns true if contains a cycle\r     bool dfs(vector<int> &vis, unordered_map<int, vector<int>> &adj, int node) {\r         \r         // 0 - unvisited, 1 - processing, 2 - processed\r         \r         if(vis[node] == 2)                              return true;\r         \r         vis[node] = 2;\r         \r         for(int i=0; i<adj[node].size(); i++) {\r             \r             int child = adj[node][i];\r             \r             if(vis[child] != 1) {\r                 if(dfs(vis, adj, child) == true)        return true;\r             }\r         }\r         \r         vis[node] = 1;\r         return false;\r     }\r     \r     vector<int> findOrder(int n, vector<vector<int>>& prereq) {\r     \r         vector<int> res;\r         \r         // Using Topological sorting\r         \r         vector<int> indegree(n, 0), vis(n, 0);\r         unordered_map<int, vector<int>> adj;\r         \r         for(auto &x : prereq) {\r             \r             int u = x[0];\r             int v = x[1];\r             \r             // v -> u\r             adj[v].push_back(u);\r             indegree[u]++;\r         }\r         \r         bool flag = false;      // if cycle is not present\r         \r         for(int i=0; i<n; i++) {\r             \r             if(flag == true)    break;\r             \r             if(vis[i] == 0) {\r                 if(dfs(vis, adj, i) == true) {\r                     flag = true;\r                     break;\r                 }\r             }\r         }\r         \r         if(flag == false)       bfs(n, adj, indegree, res);\r         \r         return res;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p65\\210-course-schedule-ii\\210-course-schedule-ii.cpp\\Solution\\findOrder(int,vector<vector<int>>&)"
    }
]