[
    {
        "f": [],
        "fm": "string longestPalindrome(string s) {\r     int len = s.size();\r     int P[len][len];\r     memset(P, 0, len * len * sizeof(int));\r     int maxL = 0, start = 0, end = 0;\r     for (int i = 0; i < s.size(); i++)\r     {\r       for (int j = 0; j < i; j++)\r       {\r         P[j][i] = (s[j] == s[i] && (i - j < 2 || P[j + 1][i - 1]));\r         if (P[j][i] && maxL < (i - j + 1))\r         {\r           maxL = i - j + 1;\r           start = j;\r           end = i;\r         }\r       }\r       P[i][i] = 1;\r     }\r     return s.substr(start, end - start + 1);\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_longestPalindrome_string_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_longestPalindrome_string_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Palindromic_Substring.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring s=\"\";\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_longestPalindrome_string_directed_0\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->longestPalindrome(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Longest_Palindromic_Substring.cpp\\\\Solution\\\\longestPalindrome(string)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Palindromic_Substring.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring s=\"\";\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_longestPalindrome_string_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_longestPalindrome_string_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Palindromic_Substring.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring s=\"\";\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_longestPalindrome_string_directed_1\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->longestPalindrome(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Longest_Palindromic_Substring.cpp\\\\Solution\\\\longestPalindrome(string)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Palindromic_Substring.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring s=\"\";\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_longestPalindrome_string_random_3(void) {\n{\nAKA_test_case_name=\"Solution_longestPalindrome_string_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Palindromic_Substring.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName468355 = new char[2];akaRandomName468355[0] = -51;akaRandomName468355[1] = '\\0';string s=akaRandomName468355;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_longestPalindrome_string_random_3\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->longestPalindrome(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Longest_Palindromic_Substring.cpp\\\\Solution\\\\longestPalindrome(string)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Palindromic_Substring.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName599057 = new char[2];akaRandomName599057[0] = -51;akaRandomName599057[1] = '\\0';string s=akaRandomName599057;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   string longestPalindrome(string s) {\r     int len = s.size();\r     int P[len][len];\r     memset(P, 0, len * len * sizeof(int));\r     int maxL = 0, start = 0, end = 0;\r     for (int i = 0; i < s.size(); i++)\r     {\r       for (int j = 0; j < i; j++)\r       {\r         P[j][i] = (s[j] == s[i] && (i - j < 2 || P[j + 1][i - 1]));\r         if (P[j][i] && maxL < (i - j + 1))\r         {\r           maxL = i - j + 1;\r           start = j;\r           end = i;\r         }\r       }\r       P[i][i] = 1;\r     }\r     return s.substr(start, end - start + 1);\r   }\r \r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Longest_Palindromic_Substring.cpp\\Solution\\longestPalindrome(string)"
    },
    {
        "f": [],
        "fm": "int lengthOfLongestSubstring(string s) {\r     int count[256];\r     memset(count, -1, 256 * sizeof(int));\r     int len = 0, maxL = 0;\r     for (int i = 0; i < s.size(); i++, len++)\r     {\r       if (count[s[i]] >= 0)\r       {\r         maxL = max(len, maxL);\r         len = 0;\r         i = count[s[i]] + 1;\r         memset(count, -1, 256 * sizeof(int));\r       }\r       count[s[i]] = i;\r     }\r     return max(len, maxL);\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_lengthOfLongestSubstring_string_random_3(void) {\n{\nAKA_test_case_name=\"Solution_lengthOfLongestSubstring_string_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Substring_Without_Repeating_Characters.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName938404 = new char[2];akaRandomName938404[0] = -104;akaRandomName938404[1] = '\\0';string s=akaRandomName938404;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_lengthOfLongestSubstring_string_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->lengthOfLongestSubstring(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Longest_Substring_Without_Repeating_Characters.cpp\\\\Solution\\\\lengthOfLongestSubstring(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Substring_Without_Repeating_Characters.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName362146 = new char[2];akaRandomName362146[0] = -104;akaRandomName362146[1] = '\\0';string s=akaRandomName362146;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_lengthOfLongestSubstring_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_lengthOfLongestSubstring_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Substring_Without_Repeating_Characters.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName953879 = new char[2];akaRandomName953879[0] = 85;akaRandomName953879[1] = '\\0';string s=akaRandomName953879;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_lengthOfLongestSubstring_string_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->lengthOfLongestSubstring(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Longest_Substring_Without_Repeating_Characters.cpp\\\\Solution\\\\lengthOfLongestSubstring(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Substring_Without_Repeating_Characters.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName829048 = new char[2];akaRandomName829048[0] = 85;akaRandomName829048[1] = '\\0';string s=akaRandomName829048;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_lengthOfLongestSubstring_string_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_lengthOfLongestSubstring_string_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Substring_Without_Repeating_Characters.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName873968 = new char[2];akaRandomName873968[0] = 0;akaRandomName873968[1] = '\\0';string s=akaRandomName873968;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_lengthOfLongestSubstring_string_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->lengthOfLongestSubstring(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Longest_Substring_Without_Repeating_Characters.cpp\\\\Solution\\\\lengthOfLongestSubstring(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Longest_Substring_Without_Repeating_Characters.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName902620 = new char[2];akaRandomName902620[0] = 0;akaRandomName902620[1] = '\\0';string s=akaRandomName902620;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   int lengthOfLongestSubstring(string s) {\r     int count[256];\r     memset(count, -1, 256 * sizeof(int));\r     int len = 0, maxL = 0;\r     for (int i = 0; i < s.size(); i++, len++)\r     {\r       if (count[s[i]] >= 0)\r       {\r         maxL = max(len, maxL);\r         len = 0;\r         i = count[s[i]] + 1;\r         memset(count, -1, 256 * sizeof(int));\r       }\r       count[s[i]] = i;\r     }\r     return max(len, maxL);\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Longest_Substring_Without_Repeating_Characters.cpp\\Solution\\lengthOfLongestSubstring(string)"
    },
    {
        "f": [],
        "fm": "CacheEntry(int k, int v) : key(k), value(v) {}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_CacheEntry_int_int_random_0(void) {\n{\nAKA_test_case_name=\"CacheEntry_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubStructDataNode AKA_INSTANCE_LRUCache__CacheEntry */\n/* ConstructorDataNode CacheEntry(int,int) */\n/* NormalNumberDataNode k */\nint AKA_INSTANCE_LRUCache__CacheEntry_k=-1459244832;\n/* NormalNumberDataNode v */\nint AKA_INSTANCE_LRUCache__CacheEntry_v=1046156249;\nAKA_mark(\"<<PRE-CALLING>> Test CacheEntry_int_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\CacheEntry\\\\CacheEntry(int,int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE_LRUCache__CacheEntry\\\\AKA_INSTANCE_LRUCache__CacheEntry\\\\CacheEntry(int,int)\");AKA_fCall++;AKA_INSTANCE_LRUCache__CacheEntry = new LRUCache::CacheEntry(AKA_INSTANCE_LRUCache__CacheEntry_k,AKA_INSTANCE_LRUCache__CacheEntry_v);\n/* NormalNumberDataNode key */\nAKA_INSTANCE_LRUCache__CacheEntry->key=-206086359;\n/* NormalNumberDataNode value */\nAKA_INSTANCE_LRUCache__CacheEntry->value=-523543884;\n\n\n\n\n\n\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubStructDataNode AKA_INSTANCE_LRUCache__CacheEntry */\n/* ConstructorDataNode CacheEntry(int,int) */\n/* NormalNumberDataNode k */\nint AKA_INSTANCE_LRUCache__CacheEntry_k=-1459244832;\n/* NormalNumberDataNode v */\nint AKA_INSTANCE_LRUCache__CacheEntry_v=1046156249;\nAKA_mark(\"<<PRE-CALLING>> Test CacheEntry_int_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\CacheEntry\\\\CacheEntry(int,int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE_LRUCache__CacheEntry\\\\AKA_INSTANCE_LRUCache__CacheEntry\\\\CacheEntry(int,int)\");AKA_fCall++;AKA_INSTANCE_LRUCache__CacheEntry = new LRUCache::CacheEntry(AKA_INSTANCE_LRUCache__CacheEntry_k,AKA_INSTANCE_LRUCache__CacheEntry_v);\n/* NormalNumberDataNode key */\nAKA_INSTANCE_LRUCache__CacheEntry->key=-206086359;\n/* NormalNumberDataNode value */\nAKA_INSTANCE_LRUCache__CacheEntry->value=-523543884;\n\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "",
        "c": [],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\LRU_Cache.cpp\\LRUCache\\CacheEntry\\CacheEntry(int,int)"
    },
    {
        "f": [
            "unordered_map<int, list<CacheEntry>::iterator> m_map;",
            "list<CacheEntry> m_LRU_cache;",
            "int m_capacity;"
        ],
        "fm": "LRUCache(int capacity) {\r \t\tm_capacity = capacity;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_LRUCache_LRUCache_int_random_1(void) {\n{\nAKA_test_case_name=\"LRUCache_LRUCache_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=322493379;\nAKA_mark(\"<<PRE-CALLING>> Test LRUCache_LRUCache_int_random_1\");AKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n\n\n\n\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=322493379;\nAKA_mark(\"<<PRE-CALLING>> Test LRUCache_LRUCache_int_random_1\");AKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class LRUCache {\r public:\r \tstruct CacheEntry\r \t{\r \tpublic:\r \t\tint key;\r \t\tint value;\r \t\tCacheEntry(int k, int v) : key(k), value(v) {}\r \t};\r \r \tLRUCache(int capacity) {\r \t\tm_capacity = capacity;\r \t}\r \r \tint get(int key) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t\treturn -1;\r \r \t\tMoveToHead(key);\r \t\treturn m_map[key]->value;\r \t}\r \r \tvoid set(int key, int value) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t{\r \t\t\tCacheEntry newItem(key, value);\r \t\t\tif (m_LRU_cache.size() >= m_capacity)\r \t\t\t{\r \t\t\t\t//remove from tail\r \t\t\t\tm_map.erase(m_LRU_cache.back().key);\r \t\t\t\tm_LRU_cache.pop_back();\r \t\t\t}\r \r \t\t\t// insert in head.\r \t\t\tm_LRU_cache.push_front(newItem);\r \t\t\tm_map[key] = m_LRU_cache.begin();\r \t\t\treturn;\r \t\t}\r \r \t\tm_map[key]->value = value;\r \t\tMoveToHead(key);\r \t}\r \r private:\r \tunordered_map<int, list<CacheEntry>::iterator> m_map;\r \tlist<CacheEntry> m_LRU_cache;\r \tint m_capacity;\r \r \tvoid MoveToHead(int key)\r \t{\r \t\t//Move key from current location to head\r \t\tauto updateEntry = *m_map[key];\r \t\tm_LRU_cache.erase(m_map[key]);\r \t\tm_LRU_cache.push_front(updateEntry);\r \t\tm_map[key] = m_LRU_cache.begin();\r \t}\r };",
        "c": [
            "LRUCache(int capacity) {\r\n\t\tm_capacity = capacity;\r\n\t}"
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\LRU_Cache.cpp\\LRUCache\\LRUCache(int)"
    },
    {
        "f": [
            "unordered_map<int, list<CacheEntry>::iterator> m_map;",
            "list<CacheEntry> m_LRU_cache;",
            "int m_capacity;"
        ],
        "fm": "int get(int key) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t\treturn -1;\r \r \t\tMoveToHead(key);\r \t\treturn m_map[key]->value;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_LRUCache_get_int_random_2(void) {\n{\nAKA_test_case_name=\"LRUCache_get_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=1530703831;\nAKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n\n\nint key=2102074450;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode key */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test LRUCache_get_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___LRUCache->get(key);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\get(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=1530703831;\nAKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n\n\nint key=2102074450;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode key */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_LRUCache_get_int_directed_0(void) {\n{\nAKA_test_case_name=\"LRUCache_get_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=0;\nAKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n\n\nint key=0;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode key */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test LRUCache_get_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___LRUCache->get(key);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\get(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=0;\nAKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n\n\nint key=0;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode key */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class LRUCache {\r public:\r \tstruct CacheEntry\r \t{\r \tpublic:\r \t\tint key;\r \t\tint value;\r \t\tCacheEntry(int k, int v) : key(k), value(v) {}\r \t};\r \r \tLRUCache(int capacity) {\r \t\tm_capacity = capacity;\r \t}\r \r \tint get(int key) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t\treturn -1;\r \r \t\tMoveToHead(key);\r \t\treturn m_map[key]->value;\r \t}\r \r \tvoid set(int key, int value) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t{\r \t\t\tCacheEntry newItem(key, value);\r \t\t\tif (m_LRU_cache.size() >= m_capacity)\r \t\t\t{\r \t\t\t\t//remove from tail\r \t\t\t\tm_map.erase(m_LRU_cache.back().key);\r \t\t\t\tm_LRU_cache.pop_back();\r \t\t\t}\r \r \t\t\t// insert in head.\r \t\t\tm_LRU_cache.push_front(newItem);\r \t\t\tm_map[key] = m_LRU_cache.begin();\r \t\t\treturn;\r \t\t}\r \r \t\tm_map[key]->value = value;\r \t\tMoveToHead(key);\r \t}\r \r private:\r \tunordered_map<int, list<CacheEntry>::iterator> m_map;\r \tlist<CacheEntry> m_LRU_cache;\r \tint m_capacity;\r \r \tvoid MoveToHead(int key)\r \t{\r \t\t//Move key from current location to head\r \t\tauto updateEntry = *m_map[key];\r \t\tm_LRU_cache.erase(m_map[key]);\r \t\tm_LRU_cache.push_front(updateEntry);\r \t\tm_map[key] = m_LRU_cache.begin();\r \t}\r };",
        "c": [
            "LRUCache(int capacity) {\r\n\t\tm_capacity = capacity;\r\n\t}"
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\LRU_Cache.cpp\\LRUCache\\get(int)"
    },
    {
        "f": [
            "unordered_map<int, list<CacheEntry>::iterator> m_map;",
            "list<CacheEntry> m_LRU_cache;",
            "int m_capacity;"
        ],
        "fm": "void set(int key, int value) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t{\r \t\t\tCacheEntry newItem(key, value);\r \t\t\tif (m_LRU_cache.size() >= m_capacity)\r \t\t\t{\r \t\t\t\t//remove from tail\r \t\t\t\tm_map.erase(m_LRU_cache.back().key);\r \t\t\t\tm_LRU_cache.pop_back();\r \t\t\t}\r \r \t\t\t// insert in head.\r \t\t\tm_LRU_cache.push_front(newItem);\r \t\t\tm_map[key] = m_LRU_cache.begin();\r \t\t\treturn;\r \t\t}\r \r \t\tm_map[key]->value = value;\r \t\tMoveToHead(key);\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_LRUCache_set_int_int_directed_0(void) {\n{\nAKA_test_case_name=\"LRUCache_set_int_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=0;\nAKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n\n\nint key=0;\n\n\nint value=0;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode key */\n/* NormalNumberDataNode value */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test LRUCache_set_int_int_directed_0\");AKA_INSTANCE___LRUCache->set(key,value);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\set(int,int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=0;\nAKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n\n\nint key=0;\n\n\nint value=0;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode key */\n/* NormalNumberDataNode value */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_LRUCache_set_int_int_random_3(void) {\n{\nAKA_test_case_name=\"LRUCache_set_int_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=421159086;\nAKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n\n\nint key=-149595269;\n\n\nint value=-793026850;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode key */\n/* NormalNumberDataNode value */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test LRUCache_set_int_int_random_3\");AKA_INSTANCE___LRUCache->set(key,value);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\set(int,int)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___LRUCache */\n/* ConstructorDataNode LRUCache(int) */\n/* NormalNumberDataNode capacity */\nint AKA_INSTANCE___LRUCache_capacity=421159086;\nAKA_mark(\"Calling: .\\\\eight\\\\LRU_Cache.cpp\\\\LRUCache\\\\LRUCache(int)|ROOT\\\\LRU_Cache.cpp\\\\GLOBAL\\\\AKA_INSTANCE___LRUCache\\\\AKA_INSTANCE___LRUCache\\\\LRUCache(int)\");AKA_fCall++;AKA_INSTANCE___LRUCache = new ::LRUCache(AKA_INSTANCE___LRUCache_capacity);\n\n\n\n\nint key=-149595269;\n\n\nint value=-793026850;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode key */\n/* NormalNumberDataNode value */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class LRUCache {\r public:\r \tstruct CacheEntry\r \t{\r \tpublic:\r \t\tint key;\r \t\tint value;\r \t\tCacheEntry(int k, int v) : key(k), value(v) {}\r \t};\r \r \tLRUCache(int capacity) {\r \t\tm_capacity = capacity;\r \t}\r \r \tint get(int key) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t\treturn -1;\r \r \t\tMoveToHead(key);\r \t\treturn m_map[key]->value;\r \t}\r \r \tvoid set(int key, int value) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t{\r \t\t\tCacheEntry newItem(key, value);\r \t\t\tif (m_LRU_cache.size() >= m_capacity)\r \t\t\t{\r \t\t\t\t//remove from tail\r \t\t\t\tm_map.erase(m_LRU_cache.back().key);\r \t\t\t\tm_LRU_cache.pop_back();\r \t\t\t}\r \r \t\t\t// insert in head.\r \t\t\tm_LRU_cache.push_front(newItem);\r \t\t\tm_map[key] = m_LRU_cache.begin();\r \t\t\treturn;\r \t\t}\r \r \t\tm_map[key]->value = value;\r \t\tMoveToHead(key);\r \t}\r \r private:\r \tunordered_map<int, list<CacheEntry>::iterator> m_map;\r \tlist<CacheEntry> m_LRU_cache;\r \tint m_capacity;\r \r \tvoid MoveToHead(int key)\r \t{\r \t\t//Move key from current location to head\r \t\tauto updateEntry = *m_map[key];\r \t\tm_LRU_cache.erase(m_map[key]);\r \t\tm_LRU_cache.push_front(updateEntry);\r \t\tm_map[key] = m_LRU_cache.begin();\r \t}\r };",
        "c": [
            "LRUCache(int capacity) {\r\n\t\tm_capacity = capacity;\r\n\t}"
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\LRU_Cache.cpp\\LRUCache\\set(int,int)"
    },
    {
        "f": [
            "unordered_map<int, list<CacheEntry>::iterator> m_map;",
            "list<CacheEntry> m_LRU_cache;",
            "int m_capacity;"
        ],
        "fm": "void MoveToHead(int key)\r \t{\r \t\t//Move key from current location to head\r \t\tauto updateEntry = *m_map[key];\r \t\tm_LRU_cache.erase(m_map[key]);\r \t\tm_LRU_cache.push_front(updateEntry);\r \t\tm_map[key] = m_LRU_cache.begin();\r \t}",
        "datatest": [],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class LRUCache {\r public:\r \tstruct CacheEntry\r \t{\r \tpublic:\r \t\tint key;\r \t\tint value;\r \t\tCacheEntry(int k, int v) : key(k), value(v) {}\r \t};\r \r \tLRUCache(int capacity) {\r \t\tm_capacity = capacity;\r \t}\r \r \tint get(int key) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t\treturn -1;\r \r \t\tMoveToHead(key);\r \t\treturn m_map[key]->value;\r \t}\r \r \tvoid set(int key, int value) {\r \t\tif (m_map.find(key) == m_map.end())\r \t\t{\r \t\t\tCacheEntry newItem(key, value);\r \t\t\tif (m_LRU_cache.size() >= m_capacity)\r \t\t\t{\r \t\t\t\t//remove from tail\r \t\t\t\tm_map.erase(m_LRU_cache.back().key);\r \t\t\t\tm_LRU_cache.pop_back();\r \t\t\t}\r \r \t\t\t// insert in head.\r \t\t\tm_LRU_cache.push_front(newItem);\r \t\t\tm_map[key] = m_LRU_cache.begin();\r \t\t\treturn;\r \t\t}\r \r \t\tm_map[key]->value = value;\r \t\tMoveToHead(key);\r \t}\r \r private:\r \tunordered_map<int, list<CacheEntry>::iterator> m_map;\r \tlist<CacheEntry> m_LRU_cache;\r \tint m_capacity;\r \r \tvoid MoveToHead(int key)\r \t{\r \t\t//Move key from current location to head\r \t\tauto updateEntry = *m_map[key];\r \t\tm_LRU_cache.erase(m_map[key]);\r \t\tm_LRU_cache.push_front(updateEntry);\r \t\tm_map[key] = m_LRU_cache.begin();\r \t}\r };",
        "c": [
            "LRUCache(int capacity) {\r\n\t\tm_capacity = capacity;\r\n\t}"
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\LRU_Cache.cpp\\LRUCache\\MoveToHead(int)"
    },
    {
        "f": [],
        "fm": "TreeNode(int x) : val(x), left(NULL), right(NULL) {}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_TreeNode_int_random_0(void) {\n{\nAKA_test_case_name=\"TreeNode_int_random_0\";\n\n// set up\n;\n\n\n/* SubStructDataNode AKA_INSTANCE___TreeNode */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint AKA_INSTANCE___TreeNode_x=-1453116835;\nAKA_mark(\"<<PRE-CALLING>> Test TreeNode_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___TreeNode\\\\AKA_INSTANCE___TreeNode\\\\TreeNode(int)\");AKA_fCall++;AKA_INSTANCE___TreeNode = new ::TreeNode(AKA_INSTANCE___TreeNode_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nAKA_INSTANCE___TreeNode->left;\n/* PointerStructureDataNode right */\nAKA_INSTANCE___TreeNode->right;\n\n\n\n\n\n\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubStructDataNode AKA_INSTANCE___TreeNode */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint AKA_INSTANCE___TreeNode_x=-1453116835;\nAKA_mark(\"<<PRE-CALLING>> Test TreeNode_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___TreeNode\\\\AKA_INSTANCE___TreeNode\\\\TreeNode(int)\");AKA_fCall++;AKA_INSTANCE___TreeNode = new ::TreeNode(AKA_INSTANCE___TreeNode_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nAKA_INSTANCE___TreeNode->left;\n/* PointerStructureDataNode right */\nAKA_INSTANCE___TreeNode->right;\n\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "",
        "c": [],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Maximum_Depth_of_Binary_Tree.cpp\\TreeNode\\TreeNode(int)"
    },
    {
        "f": [],
        "fm": "int maxDepth(TreeNode *root) {\r \t\tif (root == NULL)\r \t\t\treturn 0;\r \t\tint lmax = maxDepth(root->left);\r \t\tint rmax = maxDepth(root->right);\r \t\treturn max(lmax, rmax) + 1;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxDepth_TreeNodemul_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxDepth_TreeNodemul_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-2013784104;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-1782798536;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=0;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=1915779079;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=-2091253768;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxDepth_TreeNodemul_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxDepth(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\Solution\\\\maxDepth(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-2013784104;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-1782798536;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=0;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=1915779079;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=-2091253768;\nAKA_mark(\"Calling: .\\\\eight\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Maximum_Depth_of_Binary_Tree.cpp\\\\maxDepth(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint maxDepth(TreeNode *root) {\r \t\tif (root == NULL)\r \t\t\treturn 0;\r \t\tint lmax = maxDepth(root->left);\r \t\tint rmax = maxDepth(root->right);\r \t\treturn max(lmax, rmax) + 1;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Maximum_Depth_of_Binary_Tree.cpp\\Solution\\maxDepth(TreeNode*)"
    },
    {
        "f": [],
        "fm": "int maxSubArray(vector<int>& nums) {\r     int maxV = INT_MIN;\r     return maxArray(nums, 0, nums.size() - 1, maxV);\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxSubArray_vector_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_maxSubArray_vector_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Subarray.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-107706632;\nnums.push_back(nums_element0);\nint nums_element1=706200659;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxSubArray_vector_int_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxSubArray(nums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Maximum_Subarray.cpp\\\\Solution\\\\maxSubArray(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Subarray.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-107706632;\nnums.push_back(nums_element0);\nint nums_element1=706200659;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxSubArray_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxSubArray_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Subarray.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=2124521513;\nnums.push_back(nums_element0);\nint nums_element1=457078041;\nnums.push_back(nums_element1);\nint nums_element2=-2066208218;\nnums.push_back(nums_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxSubArray_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxSubArray(nums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Maximum_Subarray.cpp\\\\Solution\\\\maxSubArray(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Subarray.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=2124521513;\nnums.push_back(nums_element0);\nint nums_element1=457078041;\nnums.push_back(nums_element1);\nint nums_element2=-2066208218;\nnums.push_back(nums_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   int maxSubArray(vector<int>& nums) {\r     int maxV = INT_MIN;\r     return maxArray(nums, 0, nums.size() - 1, maxV);\r   }\r \r   int maxArray(vector<int>& A, int left, int right, int& maxV)\r   {\r     if (left > right)\r       return INT_MIN;\r     int mid = (left + right) / 2;\r     int lmax = maxArray(A, left, mid - 1, maxV);\r     int rmax = maxArray(A, mid + 1, right, maxV);\r     maxV = max(maxV, lmax);\r     maxV = max(maxV, rmax);\r     int sum = 0, mlmax = 0;\r     for (int i = mid - 1; i >= left; i--)\r     {\r       sum += A[i];\r       if (sum > mlmax)\r         mlmax = sum;\r     }\r     sum = 0; int mrmax = 0;\r     for (int i = mid + 1; i <= right; i++)\r     {\r       sum += A[i];\r       if (sum > mrmax)\r         mrmax = sum;\r     }\r     maxV = max(maxV, mlmax + mrmax + A[mid]);\r     return maxV;\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Maximum_Subarray.cpp\\Solution\\maxSubArray(vector<int>&)"
    },
    {
        "f": [],
        "fm": "int maxArray(vector<int>& A, int left, int right, int& maxV)\r   {\r     if (left > right)\r       return INT_MIN;\r     int mid = (left + right) / 2;\r     int lmax = maxArray(A, left, mid - 1, maxV);\r     int rmax = maxArray(A, mid + 1, right, maxV);\r     maxV = max(maxV, lmax);\r     maxV = max(maxV, rmax);\r     int sum = 0, mlmax = 0;\r     for (int i = mid - 1; i >= left; i--)\r     {\r       sum += A[i];\r       if (sum > mlmax)\r         mlmax = sum;\r     }\r     sum = 0; int mrmax = 0;\r     for (int i = mid + 1; i <= right; i++)\r     {\r       sum += A[i];\r       if (sum > mrmax)\r         mrmax = sum;\r     }\r     maxV = max(maxV, mlmax + mrmax + A[mid]);\r     return maxV;\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxArray_vector_int_int_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxArray_vector_int_int_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Subarray.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> A;\n\n\nint left=0;\n\n\nint right=2;\n\n\nint maxV=-364076725;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode A */\nint A_element0=917874501;\nA.push_back(A_element0);\n/* NormalNumberDataNode left */\n/* NormalNumberDataNode right */\n/* NormalNumberDataNode maxV */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxArray_vector_int_int_int_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxArray(A,left,right,maxV);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Maximum_Subarray.cpp\\\\Solution\\\\maxArray(vector<int>&,int,int,int&)\");\n\n\nvector<int> EXPECTED_A;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Subarray.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> A;\n\n\nint left=0;\n\n\nint right=2;\n\n\nint maxV=-364076725;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode A */\nint A_element0=917874501;\nA.push_back(A_element0);\n/* NormalNumberDataNode left */\n/* NormalNumberDataNode right */\n/* NormalNumberDataNode maxV */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxArray_vector_int_int_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_maxArray_vector_int_int_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Subarray.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> A;\n\n\nint left=2;\n\n\nint right=5;\n\n\nint maxV=2246818;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode A */\nint A_element0=-856765338;\nA.push_back(A_element0);\nint A_element1=-2123523865;\nA.push_back(A_element1);\n/* NormalNumberDataNode left */\n/* NormalNumberDataNode right */\n/* NormalNumberDataNode maxV */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxArray_vector_int_int_int_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxArray(A,left,right,maxV);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Maximum_Subarray.cpp\\\\Solution\\\\maxArray(vector<int>&,int,int,int&)\");\n\n\nvector<int> EXPECTED_A;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Maximum_Subarray.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> A;\n\n\nint left=2;\n\n\nint right=5;\n\n\nint maxV=2246818;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode A */\nint A_element0=-856765338;\nA.push_back(A_element0);\nint A_element1=-2123523865;\nA.push_back(A_element1);\n/* NormalNumberDataNode left */\n/* NormalNumberDataNode right */\n/* NormalNumberDataNode maxV */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   int maxSubArray(vector<int>& nums) {\r     int maxV = INT_MIN;\r     return maxArray(nums, 0, nums.size() - 1, maxV);\r   }\r \r   int maxArray(vector<int>& A, int left, int right, int& maxV)\r   {\r     if (left > right)\r       return INT_MIN;\r     int mid = (left + right) / 2;\r     int lmax = maxArray(A, left, mid - 1, maxV);\r     int rmax = maxArray(A, mid + 1, right, maxV);\r     maxV = max(maxV, lmax);\r     maxV = max(maxV, rmax);\r     int sum = 0, mlmax = 0;\r     for (int i = mid - 1; i >= left; i--)\r     {\r       sum += A[i];\r       if (sum > mlmax)\r         mlmax = sum;\r     }\r     sum = 0; int mrmax = 0;\r     for (int i = mid + 1; i <= right; i++)\r     {\r       sum += A[i];\r       if (sum > mrmax)\r         mrmax = sum;\r     }\r     maxV = max(maxV, mlmax + mrmax + A[mid]);\r     return maxV;\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Maximum_Subarray.cpp\\Solution\\maxArray(vector<int>&,int,int,int&)"
    },
    {
        "f": [],
        "fm": "Point() : x(0), y(0) {}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Point_random_0(void) {\n{\nAKA_test_case_name=\"Point_random_0\";\n\n// set up\n;\n\n\n/* SubStructDataNode AKA_INSTANCE___Point */\n/* ConstructorDataNode Point() */\nAKA_mark(\"<<PRE-CALLING>> Test Point_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Point\\\\Point()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Point\\\\AKA_INSTANCE___Point\\\\Point()\");AKA_fCall++;AKA_INSTANCE___Point = new ::Point();\n/* NormalNumberDataNode x */\n/* x : null value -> no code */\n/* NormalNumberDataNode y */\n/* y : null value -> no code */\n\n\n\n\n\n\n\n/* error assertion */\n\n\n/* SubStructDataNode AKA_INSTANCE___Point */\n/* ConstructorDataNode Point() */\nAKA_mark(\"<<PRE-CALLING>>\");AKA_mark(\"Calling: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Point\\\\Point()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Point\\\\AKA_INSTANCE___Point\\\\Point()\");AKA_fCall++;auto EXPECTED_AKA_GLOBAL_AKA_INSTANCE___Point = new ::Point();\n/* NormalNumberDataNode x */\n/* x : null value -> no code */\n/* NormalNumberDataNode y */\n/* y : null value -> no code */\n\n\n\n\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubStructDataNode AKA_INSTANCE___Point */\n/* ConstructorDataNode Point() */\nAKA_mark(\"<<PRE-CALLING>> Test Point_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Point\\\\Point()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Point\\\\AKA_INSTANCE___Point\\\\Point()\");AKA_fCall++;AKA_INSTANCE___Point = new ::Point();\n/* NormalNumberDataNode x */\n/* x : null value -> no code */\n/* NormalNumberDataNode y */\n/* y : null value -> no code */\n\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "",
        "c": [],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Max_Points_on_a_Line.cpp\\Point\\Point()"
    },
    {
        "f": [],
        "fm": "Point(int a, int b) : x(a), y(b) {}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Point_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Point_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubStructDataNode AKA_INSTANCE___Point */\n/* ConstructorDataNode Point(int,int) */\n/* NormalNumberDataNode a */\nint AKA_INSTANCE___Point_a=796986837;\n/* NormalNumberDataNode b */\nint AKA_INSTANCE___Point_b=1991977381;\nAKA_mark(\"<<PRE-CALLING>> Test Point_int_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Point\\\\Point(int,int)|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Point\\\\AKA_INSTANCE___Point\\\\Point(int,int)\");AKA_fCall++;AKA_INSTANCE___Point = new ::Point(AKA_INSTANCE___Point_a,AKA_INSTANCE___Point_b);\n/* NormalNumberDataNode x */\n/* x : null value -> no code */\n/* NormalNumberDataNode y */\n/* y : null value -> no code */\n\n\n\n\n\n\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubStructDataNode AKA_INSTANCE___Point */\n/* ConstructorDataNode Point(int,int) */\n/* NormalNumberDataNode a */\nint AKA_INSTANCE___Point_a=796986837;\n/* NormalNumberDataNode b */\nint AKA_INSTANCE___Point_b=1991977381;\nAKA_mark(\"<<PRE-CALLING>> Test Point_int_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Point\\\\Point(int,int)|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Point\\\\AKA_INSTANCE___Point\\\\Point(int,int)\");AKA_fCall++;AKA_INSTANCE___Point = new ::Point(AKA_INSTANCE___Point_a,AKA_INSTANCE___Point_b);\n/* NormalNumberDataNode x */\n/* x : null value -> no code */\n/* NormalNumberDataNode y */\n/* y : null value -> no code */\n\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "",
        "c": [],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Max_Points_on_a_Line.cpp\\Point\\Point(int,int)"
    },
    {
        "f": [],
        "fm": "int maxPoints(vector<Point> &points) {\r \t\tunordered_map<float, int> statistic;\r \r \t\tint maxNum = 0;\r \t\tfor (int i = 0; i < points.size(); i++)\r \t\t{\r \t\t\tstatistic.clear();\r \t\t\tstatistic[INT_MIN] = 0; // for processing duplicate point\r \t\t\tint duplicate = 1;\r \t\t\tfor (int j = 0; j < points.size(); j++)\r \t\t\t{\r \t\t\t\tif (j == i) continue;\r \t\t\t\tif (points[j].x == points[i].x && points[j].y == points[i].y) // count duplicate\r \t\t\t\t{\r \t\t\t\t\tduplicate++;\r \t\t\t\t\tcontinue;\r \t\t\t\t}\r \t\t\t\tfloat key = (points[j].x - points[i].x) == 0 ?\r \t\t\t\t            INT_MAX : // key for vertical line\r \t\t\t\t            (float) (points[j].y - points[i].y) / (points[j].x - points[i].x);\r \t\t\t\tstatistic[key]++;\r \t\t\t}\r \r \t\t\tfor (unordered_map<float, int>::iterator it = statistic.begin(); it != statistic.end(); ++it)\r \t\t\t{\r \t\t\t\tif (it->second + duplicate > maxNum)\r \t\t\t\t{\r \t\t\t\t\tmaxNum = it->second + duplicate;\r \t\t\t\t}\r \t\t\t}\r \t\t}\r \r \t\treturn maxNum;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxPoints_vector_Point_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_maxPoints_vector_Point_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxPoints_vector_Point_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxPoints(points);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Solution\\\\maxPoints(vector<Point>&)\");\n\n\nvector<Point> EXPECTED_points;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxPoints_vector_Point_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_maxPoints_vector_Point_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxPoints_vector_Point_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxPoints(points);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Solution\\\\maxPoints(vector<Point>&)\");\n\n\nvector<Point> EXPECTED_points;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxPoints_vector_Point_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_maxPoints_vector_Point_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxPoints_vector_Point_directed_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxPoints(points);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Solution\\\\maxPoints(vector<Point>&)\");\n\n\nvector<Point> EXPECTED_points;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxPoints_vector_Point_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_maxPoints_vector_Point_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxPoints_vector_Point_directed_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxPoints(points);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Solution\\\\maxPoints(vector<Point>&)\");\n\n\nvector<Point> EXPECTED_points;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxPoints_vector_Point_random_2(void) {\n{\nAKA_test_case_name=\"Solution_maxPoints_vector_Point_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Point() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Point\\\\Point()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\maxPoints(vector<Point>&)\\\\points\\\\element #0\\\\Point()\");AKA_fCall++;::Point points_element0 = ::Point();\n/* NormalNumberDataNode x */\npoints_element0.x=238929224;\n/* NormalNumberDataNode y */\npoints_element0.y=262966041;\npoints.push_back(points_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Point() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Point\\\\Point()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\maxPoints(vector<Point>&)\\\\points\\\\element #1\\\\Point()\");AKA_fCall++;::Point points_element1 = ::Point();\n/* NormalNumberDataNode x */\npoints_element1.x=589400358;\n/* NormalNumberDataNode y */\npoints_element1.y=1616433256;\npoints.push_back(points_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxPoints_vector_Point_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxPoints(points);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Solution\\\\maxPoints(vector<Point>&)\");\n\n\nvector<Point> EXPECTED_points;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Point> points;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode points */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Point() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Point\\\\Point()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\maxPoints(vector<Point>&)\\\\points\\\\element #0\\\\Point()\");AKA_fCall++;::Point points_element0 = ::Point();\n/* NormalNumberDataNode x */\npoints_element0.x=238929224;\n/* NormalNumberDataNode y */\npoints_element0.y=262966041;\npoints.push_back(points_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Point() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Max_Points_on_a_Line.cpp\\\\Point\\\\Point()|ROOT\\\\Max_Points_on_a_Line.cpp\\\\maxPoints(vector<Point>&)\\\\points\\\\element #1\\\\Point()\");AKA_fCall++;::Point points_element1 = ::Point();\n/* NormalNumberDataNode x */\npoints_element1.x=589400358;\n/* NormalNumberDataNode y */\npoints_element1.y=1616433256;\npoints.push_back(points_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint maxPoints(vector<Point> &points) {\r \t\tunordered_map<float, int> statistic;\r \r \t\tint maxNum = 0;\r \t\tfor (int i = 0; i < points.size(); i++)\r \t\t{\r \t\t\tstatistic.clear();\r \t\t\tstatistic[INT_MIN] = 0; // for processing duplicate point\r \t\t\tint duplicate = 1;\r \t\t\tfor (int j = 0; j < points.size(); j++)\r \t\t\t{\r \t\t\t\tif (j == i) continue;\r \t\t\t\tif (points[j].x == points[i].x && points[j].y == points[i].y) // count duplicate\r \t\t\t\t{\r \t\t\t\t\tduplicate++;\r \t\t\t\t\tcontinue;\r \t\t\t\t}\r \t\t\t\tfloat key = (points[j].x - points[i].x) == 0 ?\r \t\t\t\t            INT_MAX : // key for vertical line\r \t\t\t\t            (float) (points[j].y - points[i].y) / (points[j].x - points[i].x);\r \t\t\t\tstatistic[key]++;\r \t\t\t}\r \r \t\t\tfor (unordered_map<float, int>::iterator it = statistic.begin(); it != statistic.end(); ++it)\r \t\t\t{\r \t\t\t\tif (it->second + duplicate > maxNum)\r \t\t\t\t{\r \t\t\t\t\tmaxNum = it->second + duplicate;\r \t\t\t\t}\r \t\t\t}\r \t\t}\r \r \t\treturn maxNum;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Max_Points_on_a_Line.cpp\\Solution\\maxPoints(vector<Point>&)"
    },
    {
        "f": [],
        "fm": "double findMedianSortedArrays(int A[], int m, int B[], int n) {\r     if ((n + m) % 2 == 0)\r     {\r       return (GetMedian(A, m, B, n, (m + n) / 2)\r               + GetMedian(A, m, B, n, (m + n) / 2 + 1)) / 2.0;\r     }\r     else\r       return GetMedian(A, m, B, n, (m + n) / 2 + 1);\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_findMedianSortedArrays_int_int_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_findMedianSortedArrays_int_int_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint A[1];;\n\n\nint m=462375842;\nint B[3];;\n\n\nint n=86233502;\n\n\ndouble AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode A */\n/* NormalNumberDataNode A[0] */\nA[0]=-135313794;\n/* NormalNumberDataNode m */\n/* OneDimensionNumberDataNode B */\n/* NormalNumberDataNode B[0] */\nB[0]=-1497005615;\n/* NormalNumberDataNode B[1] */\nB[1]=-1762212726;\n/* NormalNumberDataNode B[2] */\nB[2]=-1906083201;\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findMedianSortedArrays_int_int_int_int_random_4\");double AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findMedianSortedArrays(A,m,B,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Median_of_Two_Sorted_Arrays.cpp\\\\Solution\\\\findMedianSortedArrays(int[],int,int[],int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint A[1];;\n\n\nint m=462375842;\nint B[3];;\n\n\nint n=86233502;\n\n\ndouble AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode A */\n/* NormalNumberDataNode A[0] */\nA[0]=-135313794;\n/* NormalNumberDataNode m */\n/* OneDimensionNumberDataNode B */\n/* NormalNumberDataNode B[0] */\nB[0]=-1497005615;\n/* NormalNumberDataNode B[1] */\nB[1]=-1762212726;\n/* NormalNumberDataNode B[2] */\nB[2]=-1906083201;\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_findMedianSortedArrays_int_int_int_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_findMedianSortedArrays_int_int_int_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint A[2];;\n\n\nint m=1126877405;\nint B[1];;\n\n\nint n=-82839453;\n\n\ndouble AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode A */\n/* NormalNumberDataNode A[0] */\nA[0]=-61039100;\n/* NormalNumberDataNode A[1] */\nA[1]=181957032;\n/* NormalNumberDataNode m */\n/* OneDimensionNumberDataNode B */\n/* NormalNumberDataNode B[0] */\nB[0]=1263274216;\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findMedianSortedArrays_int_int_int_int_random_1\");double AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findMedianSortedArrays(A,m,B,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Median_of_Two_Sorted_Arrays.cpp\\\\Solution\\\\findMedianSortedArrays(int[],int,int[],int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint A[2];;\n\n\nint m=1126877405;\nint B[1];;\n\n\nint n=-82839453;\n\n\ndouble AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode A */\n/* NormalNumberDataNode A[0] */\nA[0]=-61039100;\n/* NormalNumberDataNode A[1] */\nA[1]=181957032;\n/* NormalNumberDataNode m */\n/* OneDimensionNumberDataNode B */\n/* NormalNumberDataNode B[0] */\nB[0]=1263274216;\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_findMedianSortedArrays_int_int_int_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_findMedianSortedArrays_int_int_int_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint A[1];;\n\n\nint m=2147483647;\nint B[1];;\n\n\nint n=-2147483644;\n\n\ndouble AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode A */\n/* NormalNumberDataNode A[0] */\n/* A[0] : null value -> no code */\n/* NormalNumberDataNode m */\n/* OneDimensionNumberDataNode B */\n/* NormalNumberDataNode B[0] */\n/* B[0] : null value -> no code */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findMedianSortedArrays_int_int_int_int_directed_0\");double AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findMedianSortedArrays(A,m,B,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Median_of_Two_Sorted_Arrays.cpp\\\\Solution\\\\findMedianSortedArrays(int[],int,int[],int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint A[1];;\n\n\nint m=2147483647;\nint B[1];;\n\n\nint n=-2147483644;\n\n\ndouble AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode A */\n/* NormalNumberDataNode A[0] */\n/* A[0] : null value -> no code */\n/* NormalNumberDataNode m */\n/* OneDimensionNumberDataNode B */\n/* NormalNumberDataNode B[0] */\n/* B[0] : null value -> no code */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_findMedianSortedArrays_int_int_int_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_findMedianSortedArrays_int_int_int_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint A[3];;\n\n\nint m=-2011240091;\nint B[1];;\n\n\nint n=454675093;\n\n\ndouble AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode A */\n/* NormalNumberDataNode A[0] */\nA[0]=-329012106;\n/* NormalNumberDataNode A[1] */\nA[1]=-1741948354;\n/* NormalNumberDataNode A[2] */\nA[2]=-1383896128;\n/* NormalNumberDataNode m */\n/* OneDimensionNumberDataNode B */\n/* NormalNumberDataNode B[0] */\nB[0]=1836909610;\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findMedianSortedArrays_int_int_int_int_random_2\");double AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findMedianSortedArrays(A,m,B,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Median_of_Two_Sorted_Arrays.cpp\\\\Solution\\\\findMedianSortedArrays(int[],int,int[],int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint A[3];;\n\n\nint m=-2011240091;\nint B[1];;\n\n\nint n=454675093;\n\n\ndouble AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode A */\n/* NormalNumberDataNode A[0] */\nA[0]=-329012106;\n/* NormalNumberDataNode A[1] */\nA[1]=-1741948354;\n/* NormalNumberDataNode A[2] */\nA[2]=-1383896128;\n/* NormalNumberDataNode m */\n/* OneDimensionNumberDataNode B */\n/* NormalNumberDataNode B[0] */\nB[0]=1836909610;\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   double findMedianSortedArrays(int A[], int m, int B[], int n) {\r     if ((n + m) % 2 == 0)\r     {\r       return (GetMedian(A, m, B, n, (m + n) / 2)\r               + GetMedian(A, m, B, n, (m + n) / 2 + 1)) / 2.0;\r     }\r     else\r       return GetMedian(A, m, B, n, (m + n) / 2 + 1);\r   }\r \r   int GetMedian(int a[], int n, int b[], int m, int k)\r   {\r     assert(a && b);\r     if (n <= 0) return b[k - 1];\r     if (m <= 0) return a[k - 1];\r     if (k <= 1) return min(a[0], b[0]);\r     if (b[m / 2] >= a[n / 2])\r     {\r       if ((n / 2 + 1 + m / 2) >= k)\r         return GetMedian(a, n, b, m / 2, k);\r       else\r         return GetMedian(\r                  a + n / 2 + 1, n - (n / 2 + 1), b, m, k - (n / 2 + 1));\r     }\r     else\r     {\r       if ((m / 2 + 1 + n / 2) >= k)\r         return GetMedian( a, n / 2, b, m, k);\r       else\r         return GetMedian(\r                  a, n, b + m / 2 + 1, m - (m / 2 + 1), k - (m / 2 + 1));\r     }\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Median_of_Two_Sorted_Arrays.cpp\\Solution\\findMedianSortedArrays(int[],int,int[],int)"
    },
    {
        "f": [],
        "fm": "int GetMedian(int a[], int n, int b[], int m, int k)\r   {\r     assert(a && b);\r     if (n <= 0) return b[k - 1];\r     if (m <= 0) return a[k - 1];\r     if (k <= 1) return min(a[0], b[0]);\r     if (b[m / 2] >= a[n / 2])\r     {\r       if ((n / 2 + 1 + m / 2) >= k)\r         return GetMedian(a, n, b, m / 2, k);\r       else\r         return GetMedian(\r                  a + n / 2 + 1, n - (n / 2 + 1), b, m, k - (n / 2 + 1));\r     }\r     else\r     {\r       if ((m / 2 + 1 + n / 2) >= k)\r         return GetMedian( a, n / 2, b, m, k);\r       else\r         return GetMedian(\r                  a, n, b + m / 2 + 1, m - (m / 2 + 1), k - (m / 2 + 1));\r     }\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_GetMedian_int_int_int_int_int_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_GetMedian_int_int_int_int_int_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint a[2];;\n\n\nint n=2;\nint b[1];;\n\n\nint m=1;\n\n\nint k=2;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode a */\n/* NormalNumberDataNode a[0] */\n/* a[0] : null value -> no code */\n/* NormalNumberDataNode a[1] */\n/* a[1] : null value -> no code */\n/* NormalNumberDataNode n */\n/* OneDimensionNumberDataNode b */\n/* NormalNumberDataNode b[0] */\n/* b[0] : null value -> no code */\n/* NormalNumberDataNode m */\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_GetMedian_int_int_int_int_int_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->GetMedian(a,n,b,m,k);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Median_of_Two_Sorted_Arrays.cpp\\\\Solution\\\\GetMedian(int[],int,int[],int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint a[2];;\n\n\nint n=2;\nint b[1];;\n\n\nint m=1;\n\n\nint k=2;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode a */\n/* NormalNumberDataNode a[0] */\n/* a[0] : null value -> no code */\n/* NormalNumberDataNode a[1] */\n/* a[1] : null value -> no code */\n/* NormalNumberDataNode n */\n/* OneDimensionNumberDataNode b */\n/* NormalNumberDataNode b[0] */\n/* b[0] : null value -> no code */\n/* NormalNumberDataNode m */\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_GetMedian_int_int_int_int_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_GetMedian_int_int_int_int_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint a[1];;\n\n\nint n=1;\nint b[1];;\n\n\nint m=1;\n\n\nint k=2;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode a */\n/* NormalNumberDataNode a[0] */\n/* a[0] : null value -> no code */\n/* NormalNumberDataNode n */\n/* OneDimensionNumberDataNode b */\n/* NormalNumberDataNode b[0] */\n/* b[0] : null value -> no code */\n/* NormalNumberDataNode m */\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_GetMedian_int_int_int_int_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->GetMedian(a,n,b,m,k);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Median_of_Two_Sorted_Arrays.cpp\\\\Solution\\\\GetMedian(int[],int,int[],int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint a[1];;\n\n\nint n=1;\nint b[1];;\n\n\nint m=1;\n\n\nint k=2;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode a */\n/* NormalNumberDataNode a[0] */\n/* a[0] : null value -> no code */\n/* NormalNumberDataNode n */\n/* OneDimensionNumberDataNode b */\n/* NormalNumberDataNode b[0] */\n/* b[0] : null value -> no code */\n/* NormalNumberDataNode m */\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_GetMedian_int_int_int_int_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_GetMedian_int_int_int_int_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint a[2];;\n\n\nint n=-388802519;\nint b[3];;\n\n\nint m=1244746774;\n\n\nint k=1111707250;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode a */\n/* NormalNumberDataNode a[0] */\na[0]=2131133594;\n/* NormalNumberDataNode a[1] */\na[1]=26524296;\n/* NormalNumberDataNode n */\n/* OneDimensionNumberDataNode b */\n/* NormalNumberDataNode b[0] */\nb[0]=-1232648034;\n/* NormalNumberDataNode b[1] */\nb[1]=1828236035;\n/* NormalNumberDataNode b[2] */\nb[2]=640904931;\n/* NormalNumberDataNode m */\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_GetMedian_int_int_int_int_int_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->GetMedian(a,n,b,m,k);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Median_of_Two_Sorted_Arrays.cpp\\\\Solution\\\\GetMedian(int[],int,int[],int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Median_of_Two_Sorted_Arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nint a[2];;\n\n\nint n=-388802519;\nint b[3];;\n\n\nint m=1244746774;\n\n\nint k=1111707250;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* OneDimensionNumberDataNode a */\n/* NormalNumberDataNode a[0] */\na[0]=2131133594;\n/* NormalNumberDataNode a[1] */\na[1]=26524296;\n/* NormalNumberDataNode n */\n/* OneDimensionNumberDataNode b */\n/* NormalNumberDataNode b[0] */\nb[0]=-1232648034;\n/* NormalNumberDataNode b[1] */\nb[1]=1828236035;\n/* NormalNumberDataNode b[2] */\nb[2]=640904931;\n/* NormalNumberDataNode m */\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   double findMedianSortedArrays(int A[], int m, int B[], int n) {\r     if ((n + m) % 2 == 0)\r     {\r       return (GetMedian(A, m, B, n, (m + n) / 2)\r               + GetMedian(A, m, B, n, (m + n) / 2 + 1)) / 2.0;\r     }\r     else\r       return GetMedian(A, m, B, n, (m + n) / 2 + 1);\r   }\r \r   int GetMedian(int a[], int n, int b[], int m, int k)\r   {\r     assert(a && b);\r     if (n <= 0) return b[k - 1];\r     if (m <= 0) return a[k - 1];\r     if (k <= 1) return min(a[0], b[0]);\r     if (b[m / 2] >= a[n / 2])\r     {\r       if ((n / 2 + 1 + m / 2) >= k)\r         return GetMedian(a, n, b, m / 2, k);\r       else\r         return GetMedian(\r                  a + n / 2 + 1, n - (n / 2 + 1), b, m, k - (n / 2 + 1));\r     }\r     else\r     {\r       if ((m / 2 + 1 + n / 2) >= k)\r         return GetMedian( a, n / 2, b, m, k);\r       else\r         return GetMedian(\r                  a, n, b + m / 2 + 1, m - (m / 2 + 1), k - (m / 2 + 1));\r     }\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Median_of_Two_Sorted_Arrays.cpp\\Solution\\GetMedian(int[],int,int[],int,int)"
    },
    {
        "f": [],
        "fm": "Interval() : start(0), end(0) {}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Interval_random_0(void) {\n{\nAKA_test_case_name=\"Interval_random_0\";\n\n// set up\n;\n\n\n/* SubStructDataNode AKA_INSTANCE___Interval */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"<<PRE-CALLING>> Test Interval_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Interval\\\\AKA_INSTANCE___Interval\\\\Interval()\");AKA_fCall++;AKA_INSTANCE___Interval = new ::Interval();\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\n\n\n\n\n\n\n\n/* error assertion */\n\n\n/* SubStructDataNode AKA_INSTANCE___Interval */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"<<PRE-CALLING>>\");AKA_mark(\"Calling: .\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Interval\\\\AKA_INSTANCE___Interval\\\\Interval()\");AKA_fCall++;auto EXPECTED_AKA_GLOBAL_AKA_INSTANCE___Interval = new ::Interval();\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\n\n\n\n\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubStructDataNode AKA_INSTANCE___Interval */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"<<PRE-CALLING>> Test Interval_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Interval\\\\AKA_INSTANCE___Interval\\\\Interval()\");AKA_fCall++;AKA_INSTANCE___Interval = new ::Interval();\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\n\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "",
        "c": [],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Merge_Intervals.cpp\\Interval\\Interval()"
    },
    {
        "f": [],
        "fm": "Interval(int s, int e) : start(s), end(e) {}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Interval_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Interval_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubStructDataNode AKA_INSTANCE___Interval */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint AKA_INSTANCE___Interval_s=1580699291;\n/* NormalNumberDataNode e */\nint AKA_INSTANCE___Interval_e=-242400702;\nAKA_mark(\"<<PRE-CALLING>> Test Interval_int_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Interval\\\\AKA_INSTANCE___Interval\\\\Interval(int,int)\");AKA_fCall++;AKA_INSTANCE___Interval = new ::Interval(AKA_INSTANCE___Interval_s,AKA_INSTANCE___Interval_e);\n/* NormalNumberDataNode start */\nAKA_INSTANCE___Interval->start=928432163;\n/* NormalNumberDataNode end */\nAKA_INSTANCE___Interval->end=-870128765;\n\n\n\n\n\n\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubStructDataNode AKA_INSTANCE___Interval */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint AKA_INSTANCE___Interval_s=1580699291;\n/* NormalNumberDataNode e */\nint AKA_INSTANCE___Interval_e=-242400702;\nAKA_mark(\"<<PRE-CALLING>> Test Interval_int_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Interval\\\\AKA_INSTANCE___Interval\\\\Interval(int,int)\");AKA_fCall++;AKA_INSTANCE___Interval = new ::Interval(AKA_INSTANCE___Interval_s,AKA_INSTANCE___Interval_e);\n/* NormalNumberDataNode start */\nAKA_INSTANCE___Interval->start=928432163;\n/* NormalNumberDataNode end */\nAKA_INSTANCE___Interval->end=-870128765;\n\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "",
        "c": [],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Merge_Intervals.cpp\\Interval\\Interval(int,int)"
    },
    {
        "f": [],
        "fm": "vector<Interval> merge(vector<Interval> &intervals) {\r     vector<Interval> result;\r     for (int i = 0; i < intervals.size(); i++)\r     {\r       insert(result, intervals[i]);\r     }\r     return result;\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_directed_6(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_directed_6\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_directed_6\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_directed_5(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_directed_5\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_directed_5\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_directed_4\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_random_2(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element0_s=1909543212;\n/* NormalNumberDataNode e */\nint intervals_element0_e=-1270750171;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #0\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element0 = ::Interval(intervals_element0_s,intervals_element0_e);\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #1\\\\Interval()\");AKA_fCall++;::Interval intervals_element1 = ::Interval();\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element1);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element2_s=0;\n/* NormalNumberDataNode e */\nint intervals_element2_e=0;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #2\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element2 = ::Interval(intervals_element2_s,intervals_element2_e);\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element2);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_random_2\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element0_s=1909543212;\n/* NormalNumberDataNode e */\nint intervals_element0_e=-1270750171;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #0\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element0 = ::Interval(intervals_element0_s,intervals_element0_e);\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #1\\\\Interval()\");AKA_fCall++;::Interval intervals_element1 = ::Interval();\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element1);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element2_s=0;\n/* NormalNumberDataNode e */\nint intervals_element2_e=0;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #2\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element2 = ::Interval(intervals_element2_s,intervals_element2_e);\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element2);\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_random_1(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #0\\\\Interval()\");AKA_fCall++;::Interval intervals_element0 = ::Interval();\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element1_s=556101470;\n/* NormalNumberDataNode e */\nint intervals_element1_e=1530937317;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #1\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element1 = ::Interval(intervals_element1_s,intervals_element1_e);\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element1);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_random_1\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #0\\\\Interval()\");AKA_fCall++;::Interval intervals_element0 = ::Interval();\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element1_s=556101470;\n/* NormalNumberDataNode e */\nint intervals_element1_e=1530937317;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\merge(vector<Interval>&)\\\\intervals\\\\element #1\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element1 = ::Interval(intervals_element1_s,intervals_element1_e);\n/* NormalNumberDataNode start */\n/* start : null value -> no code */\n/* NormalNumberDataNode end */\n/* end : null value -> no code */\nintervals.push_back(intervals_element1);\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_directed_3\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_directed_2\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_directed_1\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_directed_0\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \r   vector<Interval> merge(vector<Interval> &intervals) {\r     vector<Interval> result;\r     for (int i = 0; i < intervals.size(); i++)\r     {\r       insert(result, intervals[i]);\r     }\r     return result;\r   }\r   void insert(vector<Interval> &intervals, Interval newInterval) {\r     vector<Interval>::iterator it = intervals.begin();\r     while (it != intervals.end())\r     {\r       if (newInterval.end < it->start)\r       {\r         intervals.insert(it, newInterval);\r         return;\r       }\r       else if (newInterval.start > it->end)\r       {\r         it++;\r         continue;\r       }\r       else\r       {\r         newInterval.start = min(newInterval.start, it->start);\r         newInterval.end = max(newInterval.end, it->end);\r         it = intervals.erase(it);\r       }\r     }\r     intervals.insert(intervals.end(), newInterval);\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Merge_Intervals.cpp\\Solution\\merge(vector<Interval>&)"
    },
    {
        "f": [],
        "fm": "void insert(vector<Interval> &intervals, Interval newInterval) {\r     vector<Interval>::iterator it = intervals.begin();\r     while (it != intervals.end())\r     {\r       if (newInterval.end < it->start)\r       {\r         intervals.insert(it, newInterval);\r         return;\r       }\r       else if (newInterval.start > it->end)\r       {\r         it++;\r         continue;\r       }\r       else\r       {\r         newInterval.start = min(newInterval.start, it->start);\r         newInterval.end = max(newInterval.end, it->end);\r         it = intervals.erase(it);\r       }\r     }\r     intervals.insert(intervals.end(), newInterval);\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_insert_vector_Interval_Interval_random_3(void) {\n{\nAKA_test_case_name=\"Solution_insert_vector_Interval_Interval_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\n\n\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element0_s=-1339000315;\n/* NormalNumberDataNode e */\nint intervals_element0_e=-196162690;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #0\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element0 = ::Interval(intervals_element0_s,intervals_element0_e);\n/* NormalNumberDataNode start */\nintervals_element0.start=-617411251;\n/* NormalNumberDataNode end */\nintervals_element0.end=-1079926241;\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #1\\\\Interval()\");AKA_fCall++;::Interval intervals_element1 = ::Interval();\n/* NormalNumberDataNode start */\nintervals_element1.start=1071872924;\n/* NormalNumberDataNode end */\nintervals_element1.end=-1347283542;\nintervals.push_back(intervals_element1);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element2_s=-1825729307;\n/* NormalNumberDataNode e */\nint intervals_element2_e=-1804860959;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #2\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element2 = ::Interval(intervals_element2_s,intervals_element2_e);\n/* NormalNumberDataNode start */\nintervals_element2.start=210292696;\n/* NormalNumberDataNode end */\nintervals_element2.end=-1392854400;\nintervals.push_back(intervals_element2);\n/* StructDataNode newInterval */\n/* SubStructDataNode newInterval */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint newInterval_s=-1807260815;\n/* NormalNumberDataNode e */\nint newInterval_e=-1681060028;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\newInterval\\\\newInterval\\\\Interval(int,int)\");AKA_fCall++;::Interval newInterval = ::Interval(newInterval_s,newInterval_e);\n/* NormalNumberDataNode start */\nnewInterval.start=-1596129047;\n/* NormalNumberDataNode end */\nnewInterval.end=995048125;\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_insert_vector_Interval_Interval_random_3\");AKA_INSTANCE___Solution->insert(intervals,newInterval);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\insert(vector<Interval>&,Interval)\");\n\n/* error assertion */\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\n\n\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element0_s=-1339000315;\n/* NormalNumberDataNode e */\nint intervals_element0_e=-196162690;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #0\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element0 = ::Interval(intervals_element0_s,intervals_element0_e);\n/* NormalNumberDataNode start */\nintervals_element0.start=-617411251;\n/* NormalNumberDataNode end */\nintervals_element0.end=-1079926241;\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #1\\\\Interval()\");AKA_fCall++;::Interval intervals_element1 = ::Interval();\n/* NormalNumberDataNode start */\nintervals_element1.start=1071872924;\n/* NormalNumberDataNode end */\nintervals_element1.end=-1347283542;\nintervals.push_back(intervals_element1);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element2_s=-1825729307;\n/* NormalNumberDataNode e */\nint intervals_element2_e=-1804860959;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #2\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element2 = ::Interval(intervals_element2_s,intervals_element2_e);\n/* NormalNumberDataNode start */\nintervals_element2.start=210292696;\n/* NormalNumberDataNode end */\nintervals_element2.end=-1392854400;\nintervals.push_back(intervals_element2);\n/* StructDataNode newInterval */\n/* SubStructDataNode newInterval */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint newInterval_s=-1807260815;\n/* NormalNumberDataNode e */\nint newInterval_e=-1681060028;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\newInterval\\\\newInterval\\\\Interval(int,int)\");AKA_fCall++;::Interval newInterval = ::Interval(newInterval_s,newInterval_e);\n/* NormalNumberDataNode start */\nnewInterval.start=-1596129047;\n/* NormalNumberDataNode end */\nnewInterval.end=995048125;\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_insert_vector_Interval_Interval_random_2(void) {\n{\nAKA_test_case_name=\"Solution_insert_vector_Interval_Interval_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\n\n\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element0_s=1464654948;\n/* NormalNumberDataNode e */\nint intervals_element0_e=-2082973889;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #0\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element0 = ::Interval(intervals_element0_s,intervals_element0_e);\n/* NormalNumberDataNode start */\nintervals_element0.start=-1588125567;\n/* NormalNumberDataNode end */\nintervals_element0.end=744273507;\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element1_s=-796931800;\n/* NormalNumberDataNode e */\nint intervals_element1_e=-1493783820;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #1\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element1 = ::Interval(intervals_element1_s,intervals_element1_e);\n/* NormalNumberDataNode start */\nintervals_element1.start=-2099183586;\n/* NormalNumberDataNode end */\nintervals_element1.end=1211410448;\nintervals.push_back(intervals_element1);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element2_s=63681564;\n/* NormalNumberDataNode e */\nint intervals_element2_e=-1278408126;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #2\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element2 = ::Interval(intervals_element2_s,intervals_element2_e);\n/* NormalNumberDataNode start */\nintervals_element2.start=144174024;\n/* NormalNumberDataNode end */\nintervals_element2.end=590221557;\nintervals.push_back(intervals_element2);\n/* StructDataNode newInterval */\n/* SubStructDataNode newInterval */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\newInterval\\\\newInterval\\\\Interval()\");AKA_fCall++;::Interval newInterval = ::Interval();\n/* NormalNumberDataNode start */\nnewInterval.start=1616471468;\n/* NormalNumberDataNode end */\nnewInterval.end=174686902;\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_insert_vector_Interval_Interval_random_2\");AKA_INSTANCE___Solution->insert(intervals,newInterval);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Intervals.cpp\\\\Solution\\\\insert(vector<Interval>&,Interval)\");\n\n/* error assertion */\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\n\n\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element0_s=1464654948;\n/* NormalNumberDataNode e */\nint intervals_element0_e=-2082973889;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #0\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element0 = ::Interval(intervals_element0_s,intervals_element0_e);\n/* NormalNumberDataNode start */\nintervals_element0.start=-1588125567;\n/* NormalNumberDataNode end */\nintervals_element0.end=744273507;\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element1_s=-796931800;\n/* NormalNumberDataNode e */\nint intervals_element1_e=-1493783820;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #1\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element1 = ::Interval(intervals_element1_s,intervals_element1_e);\n/* NormalNumberDataNode start */\nintervals_element1.start=-2099183586;\n/* NormalNumberDataNode end */\nintervals_element1.end=1211410448;\nintervals.push_back(intervals_element1);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element2_s=63681564;\n/* NormalNumberDataNode e */\nint intervals_element2_e=-1278408126;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval(int,int)|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\intervals\\\\element #2\\\\Interval(int,int)\");AKA_fCall++;::Interval intervals_element2 = ::Interval(intervals_element2_s,intervals_element2_e);\n/* NormalNumberDataNode start */\nintervals_element2.start=144174024;\n/* NormalNumberDataNode end */\nintervals_element2.end=590221557;\nintervals.push_back(intervals_element2);\n/* StructDataNode newInterval */\n/* SubStructDataNode newInterval */\n/* ConstructorDataNode Interval() */\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_Intervals.cpp\\\\Interval\\\\Interval()|ROOT\\\\Merge_Intervals.cpp\\\\insert(vector<Interval>&,Interval)\\\\newInterval\\\\newInterval\\\\Interval()\");AKA_fCall++;::Interval newInterval = ::Interval();\n/* NormalNumberDataNode start */\nnewInterval.start=1616471468;\n/* NormalNumberDataNode end */\nnewInterval.end=174686902;\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \r   vector<Interval> merge(vector<Interval> &intervals) {\r     vector<Interval> result;\r     for (int i = 0; i < intervals.size(); i++)\r     {\r       insert(result, intervals[i]);\r     }\r     return result;\r   }\r   void insert(vector<Interval> &intervals, Interval newInterval) {\r     vector<Interval>::iterator it = intervals.begin();\r     while (it != intervals.end())\r     {\r       if (newInterval.end < it->start)\r       {\r         intervals.insert(it, newInterval);\r         return;\r       }\r       else if (newInterval.start > it->end)\r       {\r         it++;\r         continue;\r       }\r       else\r       {\r         newInterval.start = min(newInterval.start, it->start);\r         newInterval.end = max(newInterval.end, it->end);\r         it = intervals.erase(it);\r       }\r     }\r     intervals.insert(intervals.end(), newInterval);\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Merge_Intervals.cpp\\Solution\\insert(vector<Interval>&,Interval)"
    },
    {
        "f": [],
        "fm": "ListNode(int x) : val(x), next(NULL) {}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_ListNode_int_random_0(void) {\n{\nAKA_test_case_name=\"ListNode_int_random_0\";\n\n// set up\n;\n\n\n/* SubStructDataNode AKA_INSTANCE___ListNode */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint AKA_INSTANCE___ListNode_x=257996255;\nAKA_mark(\"<<PRE-CALLING>> Test ListNode_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___ListNode\\\\AKA_INSTANCE___ListNode\\\\ListNode(int)\");AKA_fCall++;AKA_INSTANCE___ListNode = new ::ListNode(AKA_INSTANCE___ListNode_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nAKA_INSTANCE___ListNode->next;\n\n\n\n\n\n\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubStructDataNode AKA_INSTANCE___ListNode */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint AKA_INSTANCE___ListNode_x=257996255;\nAKA_mark(\"<<PRE-CALLING>> Test ListNode_int_random_0\");AKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___ListNode\\\\AKA_INSTANCE___ListNode\\\\ListNode(int)\");AKA_fCall++;AKA_INSTANCE___ListNode = new ::ListNode(AKA_INSTANCE___ListNode_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nAKA_INSTANCE___ListNode->next;\n\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "",
        "c": [],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Merge_k_Sorted_Lists.cpp\\ListNode\\ListNode(int)"
    },
    {
        "f": [],
        "fm": "ListNode *mergeKLists(vector<ListNode *> &lists) {\r         ListNode* one = NULL;\r         for (int i = 0; i < lists.size(); i++)\r         {\r             one = merge2Lists(one, lists[i]);\r         }\r         return one;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_mergeKLists_vector_ListNodemul_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_mergeKLists_vector_ListNodemul_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_mergeKLists_vector_ListNodemul_directed_3\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->mergeKLists(lists);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\mergeKLists(vector<ListNode*>&)\");\n\n\nvector<ListNode*> EXPECTED_lists;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_mergeKLists_vector_ListNodemul_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_mergeKLists_vector_ListNodemul_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_mergeKLists_vector_ListNodemul_directed_4\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->mergeKLists(lists);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\mergeKLists(vector<ListNode*>&)\");\n\n\nvector<ListNode*> EXPECTED_lists;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_mergeKLists_vector_ListNodemul_random_3(void) {\n{\nAKA_test_case_name=\"Solution_mergeKLists_vector_ListNodemul_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\nstd::vector<ListNode*> AKA_VECTOR_INIT_lists_element0;\n/* SubStructDataNode  */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint lists_element00_x=494759145;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\mergeKLists(vector<ListNode*>&)\\\\lists\\\\element #0\\\\element #0[0]\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_lists_element0_0 = new ::ListNode(lists_element00_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_lists_element0_0).next;\nAKA_VECTOR_INIT_lists_element0.push_back(AKA_VECTOR_INIT_lists_element0_0);\nListNode* lists_element0 = AKA_VECTOR_INIT_lists_element0[0];\nlists.push_back(lists_element0);\nstd::vector<ListNode*> AKA_VECTOR_INIT_lists_element1;\n/* SubStructDataNode  */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint lists_element10_x=1964659642;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\mergeKLists(vector<ListNode*>&)\\\\lists\\\\element #1\\\\element #1[0]\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_lists_element1_0 = new ::ListNode(lists_element10_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_lists_element1_0).next;\nAKA_VECTOR_INIT_lists_element1.push_back(AKA_VECTOR_INIT_lists_element1_0);\nListNode* lists_element1 = AKA_VECTOR_INIT_lists_element1[0];\nlists.push_back(lists_element1);\nListNode* lists_element2;\nlists.push_back(lists_element2);\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_mergeKLists_vector_ListNodemul_random_3\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->mergeKLists(lists);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\mergeKLists(vector<ListNode*>&)\");\n\n\nvector<ListNode*> EXPECTED_lists;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\nstd::vector<ListNode*> AKA_VECTOR_INIT_lists_element0;\n/* SubStructDataNode  */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint lists_element00_x=494759145;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\mergeKLists(vector<ListNode*>&)\\\\lists\\\\element #0\\\\element #0[0]\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_lists_element0_0 = new ::ListNode(lists_element00_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_lists_element0_0).next;\nAKA_VECTOR_INIT_lists_element0.push_back(AKA_VECTOR_INIT_lists_element0_0);\nListNode* lists_element0 = AKA_VECTOR_INIT_lists_element0[0];\nlists.push_back(lists_element0);\nstd::vector<ListNode*> AKA_VECTOR_INIT_lists_element1;\n/* SubStructDataNode  */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint lists_element10_x=1964659642;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\mergeKLists(vector<ListNode*>&)\\\\lists\\\\element #1\\\\element #1[0]\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_lists_element1_0 = new ::ListNode(lists_element10_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_lists_element1_0).next;\nAKA_VECTOR_INIT_lists_element1.push_back(AKA_VECTOR_INIT_lists_element1_0);\nListNode* lists_element1 = AKA_VECTOR_INIT_lists_element1[0];\nlists.push_back(lists_element1);\nListNode* lists_element2;\nlists.push_back(lists_element2);\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_mergeKLists_vector_ListNodemul_random_2(void) {\n{\nAKA_test_case_name=\"Solution_mergeKLists_vector_ListNodemul_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\nstd::vector<ListNode*> AKA_VECTOR_INIT_lists_element0;\n/* SubStructDataNode  */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint lists_element00_x=-444282433;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\mergeKLists(vector<ListNode*>&)\\\\lists\\\\element #0\\\\element #0[0]\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_lists_element0_0 = new ::ListNode(lists_element00_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_lists_element0_0).next;\nAKA_VECTOR_INIT_lists_element0.push_back(AKA_VECTOR_INIT_lists_element0_0);\n/* SubStructDataNode  */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint lists_element01_x=1110839745;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\mergeKLists(vector<ListNode*>&)\\\\lists\\\\element #0\\\\element #0[1]\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_lists_element0_1 = new ::ListNode(lists_element01_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_lists_element0_1).next;\nAKA_VECTOR_INIT_lists_element0.push_back(AKA_VECTOR_INIT_lists_element0_1);\nListNode* lists_element0 = AKA_VECTOR_INIT_lists_element0[0];\nlists.push_back(lists_element0);\nListNode* lists_element1;\nlists.push_back(lists_element1);\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_mergeKLists_vector_ListNodemul_random_2\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->mergeKLists(lists);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\mergeKLists(vector<ListNode*>&)\");\n\n\nvector<ListNode*> EXPECTED_lists;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\nstd::vector<ListNode*> AKA_VECTOR_INIT_lists_element0;\n/* SubStructDataNode  */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint lists_element00_x=-444282433;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\mergeKLists(vector<ListNode*>&)\\\\lists\\\\element #0\\\\element #0[0]\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_lists_element0_0 = new ::ListNode(lists_element00_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_lists_element0_0).next;\nAKA_VECTOR_INIT_lists_element0.push_back(AKA_VECTOR_INIT_lists_element0_0);\n/* SubStructDataNode  */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint lists_element01_x=1110839745;\nAKA_mark(\"Calling: D:\\\\prj-data\\\\codingtmd_leetcode\\\\src\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\mergeKLists(vector<ListNode*>&)\\\\lists\\\\element #0\\\\element #0[1]\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_lists_element0_1 = new ::ListNode(lists_element01_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_lists_element0_1).next;\nAKA_VECTOR_INIT_lists_element0.push_back(AKA_VECTOR_INIT_lists_element0_1);\nListNode* lists_element0 = AKA_VECTOR_INIT_lists_element0[0];\nlists.push_back(lists_element0);\nListNode* lists_element1;\nlists.push_back(lists_element1);\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_mergeKLists_vector_ListNodemul_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_mergeKLists_vector_ListNodemul_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_mergeKLists_vector_ListNodemul_directed_0\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->mergeKLists(lists);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\mergeKLists(vector<ListNode*>&)\");\n\n\nvector<ListNode*> EXPECTED_lists;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_mergeKLists_vector_ListNodemul_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_mergeKLists_vector_ListNodemul_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_mergeKLists_vector_ListNodemul_directed_1\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->mergeKLists(lists);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\mergeKLists(vector<ListNode*>&)\");\n\n\nvector<ListNode*> EXPECTED_lists;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_mergeKLists_vector_ListNodemul_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_mergeKLists_vector_ListNodemul_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_mergeKLists_vector_ListNodemul_directed_2\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->mergeKLists(lists);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\mergeKLists(vector<ListNode*>&)\");\n\n\nvector<ListNode*> EXPECTED_lists;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<ListNode*> lists;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode lists */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     ListNode *mergeKLists(vector<ListNode *> &lists) {\r         ListNode* one = NULL;\r         for (int i = 0; i < lists.size(); i++)\r         {\r             one = merge2Lists(one, lists[i]);\r         }\r         return one;\r     }\r \r     ListNode* merge2Lists(ListNode* one, ListNode* two)\r     {\r         if (one == NULL) return two;\r         if (two == NULL) return one;\r         ListNode* newHead = new ListNode(-1);\r         ListNode* p = newHead;\r         while (one != NULL && two != NULL)\r         {\r             if (one->val < two->val)\r             {\r                 p->next = one;\r                 one = one->next;\r             }\r             else\r             {\r                 p->next = two;\r                 two = two->next;\r             }\r             p = p->next;\r         }\r \r         if (one == NULL)\r         {\r             p->next = two;\r         }\r         else\r         {\r             p->next = one;\r         }\r         p = newHead->next;\r         delete newHead;\r         return p;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Merge_k_Sorted_Lists.cpp\\Solution\\mergeKLists(vector<ListNode*>&)"
    },
    {
        "f": [],
        "fm": "ListNode* merge2Lists(ListNode* one, ListNode* two)\r     {\r         if (one == NULL) return two;\r         if (two == NULL) return one;\r         ListNode* newHead = new ListNode(-1);\r         ListNode* p = newHead;\r         while (one != NULL && two != NULL)\r         {\r             if (one->val < two->val)\r             {\r                 p->next = one;\r                 one = one->next;\r             }\r             else\r             {\r                 p->next = two;\r                 two = two->next;\r             }\r             p = p->next;\r         }\r \r         if (one == NULL)\r         {\r             p->next = two;\r         }\r         else\r         {\r             p->next = one;\r         }\r         p = newHead->next;\r         delete newHead;\r         return p;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge2Lists_ListNodemul_ListNodemul_random_0(void) {\n{\nAKA_test_case_name=\"Solution_merge2Lists_ListNodemul_ListNodemul_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nListNode* one;\nListNode* two;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode one */\n/* PointerStructureDataNode two */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge2Lists_ListNodemul_ListNodemul_random_0\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge2Lists(one,two);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\merge2Lists(ListNode*,ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nListNode* one;\nListNode* two;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode one */\n/* PointerStructureDataNode two */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge2Lists_ListNodemul_ListNodemul_random_1(void) {\n{\nAKA_test_case_name=\"Solution_merge2Lists_ListNodemul_ListNodemul_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_one;\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_x=-131213060;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0 = new ::ListNode(one0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_0).val=2000410881;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_one_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_next0_x=-1123207092;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0_DOT_next_0 = new ::ListNode(one0_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_0_DOT_next_0).val=2009073077;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_0_DOT_next_0).next;\nAKA_VECTOR_INIT_one_0_DOT_next.push_back(AKA_VECTOR_INIT_one_0_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_next1_x=-637269947;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0_DOT_next_1 = new ::ListNode(one0_next1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_0_DOT_next_1).val=2090235506;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_0_DOT_next_1).next;\nAKA_VECTOR_INIT_one_0_DOT_next.push_back(AKA_VECTOR_INIT_one_0_DOT_next_1);\n(*AKA_VECTOR_INIT_one_0).next = AKA_VECTOR_INIT_one_0_DOT_next[0];\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_0);\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one1_x=1951907992;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_1\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_1 = new ::ListNode(one1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_1).val=-829178101;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_one_1_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one1_next0_x=-264519393;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_1\\\\one\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_1_DOT_next_0 = new ::ListNode(one1_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_1_DOT_next_0).val=519247754;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_1_DOT_next_0).next;\nAKA_VECTOR_INIT_one_1_DOT_next.push_back(AKA_VECTOR_INIT_one_1_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one1_next1_x=1209803803;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_1\\\\one\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_1_DOT_next_1 = new ::ListNode(one1_next1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_1_DOT_next_1).val=1696603090;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_1_DOT_next_1).next;\nAKA_VECTOR_INIT_one_1_DOT_next.push_back(AKA_VECTOR_INIT_one_1_DOT_next_1);\n(*AKA_VECTOR_INIT_one_1).next = AKA_VECTOR_INIT_one_1_DOT_next[0];\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_1);\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one2_x=-1254779284;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_2\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_2 = new ::ListNode(one2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_2).val=1614437435;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_one_2_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one2_next0_x=-1268812275;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_2\\\\one\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_2_DOT_next_0 = new ::ListNode(one2_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_2_DOT_next_0).val=-1199794319;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_2_DOT_next_0).next;\nAKA_VECTOR_INIT_one_2_DOT_next.push_back(AKA_VECTOR_INIT_one_2_DOT_next_0);\n(*AKA_VECTOR_INIT_one_2).next = AKA_VECTOR_INIT_one_2_DOT_next[0];\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_2);\n\nListNode* one = AKA_VECTOR_INIT_one[0];\nListNode* two;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode one */\n/* PointerStructureDataNode two */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge2Lists_ListNodemul_ListNodemul_random_1\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge2Lists(one,two);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\merge2Lists(ListNode*,ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_one;\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_x=-131213060;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0 = new ::ListNode(one0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_0).val=2000410881;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_one_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_next0_x=-1123207092;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0_DOT_next_0 = new ::ListNode(one0_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_0_DOT_next_0).val=2009073077;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_0_DOT_next_0).next;\nAKA_VECTOR_INIT_one_0_DOT_next.push_back(AKA_VECTOR_INIT_one_0_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_next1_x=-637269947;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0_DOT_next_1 = new ::ListNode(one0_next1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_0_DOT_next_1).val=2090235506;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_0_DOT_next_1).next;\nAKA_VECTOR_INIT_one_0_DOT_next.push_back(AKA_VECTOR_INIT_one_0_DOT_next_1);\n(*AKA_VECTOR_INIT_one_0).next = AKA_VECTOR_INIT_one_0_DOT_next[0];\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_0);\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one1_x=1951907992;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_1\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_1 = new ::ListNode(one1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_1).val=-829178101;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_one_1_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one1_next0_x=-264519393;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_1\\\\one\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_1_DOT_next_0 = new ::ListNode(one1_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_1_DOT_next_0).val=519247754;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_1_DOT_next_0).next;\nAKA_VECTOR_INIT_one_1_DOT_next.push_back(AKA_VECTOR_INIT_one_1_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one1_next1_x=1209803803;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_1\\\\one\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_1_DOT_next_1 = new ::ListNode(one1_next1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_1_DOT_next_1).val=1696603090;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_1_DOT_next_1).next;\nAKA_VECTOR_INIT_one_1_DOT_next.push_back(AKA_VECTOR_INIT_one_1_DOT_next_1);\n(*AKA_VECTOR_INIT_one_1).next = AKA_VECTOR_INIT_one_1_DOT_next[0];\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_1);\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one2_x=-1254779284;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_2\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_2 = new ::ListNode(one2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_2).val=1614437435;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_one_2_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one2_next0_x=-1268812275;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_2\\\\one\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_2_DOT_next_0 = new ::ListNode(one2_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_2_DOT_next_0).val=-1199794319;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_2_DOT_next_0).next;\nAKA_VECTOR_INIT_one_2_DOT_next.push_back(AKA_VECTOR_INIT_one_2_DOT_next_0);\n(*AKA_VECTOR_INIT_one_2).next = AKA_VECTOR_INIT_one_2_DOT_next[0];\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_2);\n\nListNode* one = AKA_VECTOR_INIT_one[0];\nListNode* two;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode one */\n/* PointerStructureDataNode two */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge2Lists_ListNodemul_ListNodemul_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_merge2Lists_ListNodemul_ListNodemul_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_one;\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_x=0;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0 = new ::ListNode(one0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_0).next;\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_0);\n\nListNode* one = AKA_VECTOR_INIT_one[0];\n\nListNode* two = nullptr;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode one */\n/* PointerStructureDataNode two */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge2Lists_ListNodemul_ListNodemul_directed_0\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge2Lists(one,two);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\merge2Lists(ListNode*,ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_one;\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_x=0;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0 = new ::ListNode(one0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_0).next;\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_0);\n\nListNode* one = AKA_VECTOR_INIT_one[0];\n\nListNode* two = nullptr;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode one */\n/* PointerStructureDataNode two */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge2Lists_ListNodemul_ListNodemul_random_4(void) {\n{\nAKA_test_case_name=\"Solution_merge2Lists_ListNodemul_ListNodemul_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_one;\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_x=-2096739345;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0 = new ::ListNode(one0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_0).val=-1377061986;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_0).next;\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_0);\n\nListNode* one = AKA_VECTOR_INIT_one[0];\nstd::vector<ListNode*> AKA_VECTOR_INIT_two;\n\n\n/* SubStructDataNode two */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two0_x=1049484191;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_0\\\\two\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_0 = new ::ListNode(two0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_0).val=-928392060;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_two_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two0_next0_x=-1515622866;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_0\\\\two\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_0_DOT_next_0 = new ::ListNode(two0_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_0_DOT_next_0).val=1766468022;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_two_0_DOT_next_0).next;\nAKA_VECTOR_INIT_two_0_DOT_next.push_back(AKA_VECTOR_INIT_two_0_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two0_next1_x=-734050001;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_0\\\\two\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_0_DOT_next_1 = new ::ListNode(two0_next1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_0_DOT_next_1).val=-507494761;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_two_0_DOT_next_1).next;\nAKA_VECTOR_INIT_two_0_DOT_next.push_back(AKA_VECTOR_INIT_two_0_DOT_next_1);\n(*AKA_VECTOR_INIT_two_0).next = AKA_VECTOR_INIT_two_0_DOT_next[0];\n\nAKA_VECTOR_INIT_two.push_back(AKA_VECTOR_INIT_two_0);\n\n\n/* SubStructDataNode two */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two1_x=-1268158900;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_1\\\\two\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_1 = new ::ListNode(two1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_1).val=1382870461;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_two_1_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two1_next0_x=203691362;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_1\\\\two\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_1_DOT_next_0 = new ::ListNode(two1_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_1_DOT_next_0).val=-1896311963;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_two_1_DOT_next_0).next;\nAKA_VECTOR_INIT_two_1_DOT_next.push_back(AKA_VECTOR_INIT_two_1_DOT_next_0);\n(*AKA_VECTOR_INIT_two_1).next = AKA_VECTOR_INIT_two_1_DOT_next[0];\n\nAKA_VECTOR_INIT_two.push_back(AKA_VECTOR_INIT_two_1);\n\n\n/* SubStructDataNode two */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two2_x=1516127324;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_2\\\\two\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_2 = new ::ListNode(two2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_2).val=-309504451;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_two_2).next;\n\nAKA_VECTOR_INIT_two.push_back(AKA_VECTOR_INIT_two_2);\n\nListNode* two = AKA_VECTOR_INIT_two[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode one */\n/* PointerStructureDataNode two */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge2Lists_ListNodemul_ListNodemul_random_4\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge2Lists(one,two);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\Solution\\\\merge2Lists(ListNode*,ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_one;\n\n\n/* SubStructDataNode one */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint one0_x=-2096739345;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\one\\\\AKA_VECTOR_INIT_one_0\\\\one\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_one_0 = new ::ListNode(one0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_one_0).val=-1377061986;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_one_0).next;\n\nAKA_VECTOR_INIT_one.push_back(AKA_VECTOR_INIT_one_0);\n\nListNode* one = AKA_VECTOR_INIT_one[0];\nstd::vector<ListNode*> AKA_VECTOR_INIT_two;\n\n\n/* SubStructDataNode two */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two0_x=1049484191;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_0\\\\two\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_0 = new ::ListNode(two0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_0).val=-928392060;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_two_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two0_next0_x=-1515622866;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_0\\\\two\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_0_DOT_next_0 = new ::ListNode(two0_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_0_DOT_next_0).val=1766468022;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_two_0_DOT_next_0).next;\nAKA_VECTOR_INIT_two_0_DOT_next.push_back(AKA_VECTOR_INIT_two_0_DOT_next_0);\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two0_next1_x=-734050001;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_0\\\\two\\\\next\\\\next[1]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_0_DOT_next_1 = new ::ListNode(two0_next1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_0_DOT_next_1).val=-507494761;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_two_0_DOT_next_1).next;\nAKA_VECTOR_INIT_two_0_DOT_next.push_back(AKA_VECTOR_INIT_two_0_DOT_next_1);\n(*AKA_VECTOR_INIT_two_0).next = AKA_VECTOR_INIT_two_0_DOT_next[0];\n\nAKA_VECTOR_INIT_two.push_back(AKA_VECTOR_INIT_two_0);\n\n\n/* SubStructDataNode two */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two1_x=-1268158900;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_1\\\\two\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_1 = new ::ListNode(two1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_1).val=1382870461;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_two_1_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two1_next0_x=203691362;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_1\\\\two\\\\next\\\\next[0]\\\\next\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_1_DOT_next_0 = new ::ListNode(two1_next0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_1_DOT_next_0).val=-1896311963;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_two_1_DOT_next_0).next;\nAKA_VECTOR_INIT_two_1_DOT_next.push_back(AKA_VECTOR_INIT_two_1_DOT_next_0);\n(*AKA_VECTOR_INIT_two_1).next = AKA_VECTOR_INIT_two_1_DOT_next[0];\n\nAKA_VECTOR_INIT_two.push_back(AKA_VECTOR_INIT_two_1);\n\n\n/* SubStructDataNode two */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint two2_x=1516127324;\nAKA_mark(\"Calling: .\\\\eight\\\\Merge_k_Sorted_Lists.cpp\\\\ListNode\\\\ListNode(int)|ROOT\\\\Merge_k_Sorted_Lists.cpp\\\\merge2Lists(ListNode*,ListNode*)\\\\two\\\\AKA_VECTOR_INIT_two_2\\\\two\\\\ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_two_2 = new ::ListNode(two2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_two_2).val=-309504451;\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_two_2).next;\n\nAKA_VECTOR_INIT_two.push_back(AKA_VECTOR_INIT_two_2);\n\nListNode* two = AKA_VECTOR_INIT_two[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode one */\n/* PointerStructureDataNode two */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     ListNode *mergeKLists(vector<ListNode *> &lists) {\r         ListNode* one = NULL;\r         for (int i = 0; i < lists.size(); i++)\r         {\r             one = merge2Lists(one, lists[i]);\r         }\r         return one;\r     }\r \r     ListNode* merge2Lists(ListNode* one, ListNode* two)\r     {\r         if (one == NULL) return two;\r         if (two == NULL) return one;\r         ListNode* newHead = new ListNode(-1);\r         ListNode* p = newHead;\r         while (one != NULL && two != NULL)\r         {\r             if (one->val < two->val)\r             {\r                 p->next = one;\r                 one = one->next;\r             }\r             else\r             {\r                 p->next = two;\r                 two = two->next;\r             }\r             p = p->next;\r         }\r \r         if (one == NULL)\r         {\r             p->next = two;\r         }\r         else\r         {\r             p->next = one;\r         }\r         p = newHead->next;\r         delete newHead;\r         return p;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Merge_k_Sorted_Lists.cpp\\Solution\\merge2Lists(ListNode*,ListNode*)"
    },
    {
        "f": [],
        "fm": "void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r     int k = m + n - 1;\r     int i = m - 1, j = n - 1;\r     for (; i >= 0 && j >= 0; k--)\r     {\r       if (nums1[i] >= nums2[j])\r       {\r         nums1[k] = nums1[i];\r         i--;\r       }\r       else\r       {\r         nums1[k] = nums2[j];\r         j--;\r       }\r     }\r     while (j >= 0)\r     {\r       nums1[k] = nums2[j];\r       k--; j--;\r     }\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_int_int_vector_int_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_int_int_vector_int_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Sorted_Array.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums1;\n\n\nint m=8;\nvector<int> nums2;\n\n\nint n=8;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums1 */\nint nums1_element0=898789286;\nnums1.push_back(nums1_element0);\nint nums1_element1=1348739971;\nnums1.push_back(nums1_element1);\n/* NormalNumberDataNode m */\n/* VectorDataNode nums2 */\nint nums2_element0=185363489;\nnums2.push_back(nums2_element0);\nint nums2_element1=-223337160;\nnums2.push_back(nums2_element1);\n/* NormalNumberDataNode n */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_int_int_vector_int_int_random_1\");AKA_INSTANCE___Solution->merge(nums1,m,nums2,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Sorted_Array.cpp\\\\Solution\\\\merge(vector<int>&,int,vector<int>&,int)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums1;\n\nvector<int> EXPECTED_nums2;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Sorted_Array.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums1;\n\n\nint m=8;\nvector<int> nums2;\n\n\nint n=8;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums1 */\nint nums1_element0=898789286;\nnums1.push_back(nums1_element0);\nint nums1_element1=1348739971;\nnums1.push_back(nums1_element1);\n/* NormalNumberDataNode m */\n/* VectorDataNode nums2 */\nint nums2_element0=185363489;\nnums2.push_back(nums2_element0);\nint nums2_element1=-223337160;\nnums2.push_back(nums2_element1);\n/* NormalNumberDataNode n */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_int_int_vector_int_int_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_int_int_vector_int_int_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Sorted_Array.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums1;\n\n\nint m=0;\nvector<int> nums2;\n\n\nint n=3;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums1 */\n/* NormalNumberDataNode m */\n/* VectorDataNode nums2 */\n/* NormalNumberDataNode n */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_int_int_vector_int_int_directed_1\");AKA_INSTANCE___Solution->merge(nums1,m,nums2,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Sorted_Array.cpp\\\\Solution\\\\merge(vector<int>&,int,vector<int>&,int)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums1;\n\nvector<int> EXPECTED_nums2;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Sorted_Array.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums1;\n\n\nint m=0;\nvector<int> nums2;\n\n\nint n=3;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums1 */\n/* NormalNumberDataNode m */\n/* VectorDataNode nums2 */\n/* NormalNumberDataNode n */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_int_int_vector_int_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_int_int_vector_int_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Sorted_Array.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums1;\n\n\nint m=1;\nvector<int> nums2;\n\n\nint n=0;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums1 */\n/* NormalNumberDataNode m */\n/* VectorDataNode nums2 */\n/* NormalNumberDataNode n */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_int_int_vector_int_int_directed_0\");AKA_INSTANCE___Solution->merge(nums1,m,nums2,n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\eight\\\\Merge_Sorted_Array.cpp\\\\Solution\\\\merge(vector<int>&,int,vector<int>&,int)\");\n\n/* error assertion */\nvector<int> EXPECTED_nums1;\n\nvector<int> EXPECTED_nums2;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Merge_Sorted_Array.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums1;\n\n\nint m=1;\nvector<int> nums2;\n\n\nint n=0;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums1 */\n/* NormalNumberDataNode m */\n/* VectorDataNode nums2 */\n/* NormalNumberDataNode n */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\r     int k = m + n - 1;\r     int i = m - 1, j = n - 1;\r     for (; i >= 0 && j >= 0; k--)\r     {\r       if (nums1[i] >= nums2[j])\r       {\r         nums1[k] = nums1[i];\r         i--;\r       }\r       else\r       {\r         nums1[k] = nums2[j];\r         j--;\r       }\r     }\r     while (j >= 0)\r     {\r       nums1[k] = nums2[j];\r       k--; j--;\r     }\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\eight\\Merge_Sorted_Array.cpp\\Solution\\merge(vector<int>&,int,vector<int>&,int)"
    }
]