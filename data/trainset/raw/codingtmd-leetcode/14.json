[
    {
        "f": [
            "unordered_map<string, vector<int>> memo;"
        ],
        "fm": "int compute(int a, int b, char op) {\r         switch(op) {\r             case '+': return a + b;\r             case '-': return a - b;\r             case '*': return a * b;\r         }\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_compute_int_int_char_random_4(void) {\n{\nAKA_test_case_name=\"Solution_compute_int_int_char_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint a=237836447;\n\n\nint b=1541064803;\n\nchar op=21;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_compute_int_int_char_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->compute(a,b,op);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\Solution\\\\compute(int,int,char)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint a=237836447;\n\n\nint b=1541064803;\n\nchar op=21;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_compute_int_int_char_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_compute_int_int_char_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=43;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_compute_int_int_char_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->compute(a,b,op);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\Solution\\\\compute(int,int,char)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=43;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_compute_int_int_char_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_compute_int_int_char_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=42;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_compute_int_int_char_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->compute(a,b,op);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\Solution\\\\compute(int,int,char)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=42;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_compute_int_int_char_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_compute_int_int_char_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=45;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_compute_int_int_char_directed_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->compute(a,b,op);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\Solution\\\\compute(int,int,char)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=45;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     unordered_map<string, vector<int>> memo;\r     int compute(int a, int b, char op) {\r         switch(op) {\r             case '+': return a + b;\r             case '-': return a - b;\r             case '*': return a * b;\r         }\r     }\r     \r     string generateKey(int startIndex, int endIndex) {\r         return to_string(startIndex) + \"-\" + to_string(endIndex);\r     }\r \r     vector<int> diffWaysToCompute(string input) {\r         return diffWaysToComputeWithMemo(input, 0, input.size()-1);\r     }\r     vector<int> diffWaysToComputeWithMemo(string& input, int startIndex, int endIndex) {    \r         string cache_key = generateKey(startIndex, endIndex);\r         if(memo.find(cache_key) != memo.end()) return memo[cache_key];\r         \r         int number = 0, i=startIndex;\r         for(; i<= endIndex && isdigit(input[i]); ++i) {\r             number  = number * 10 + input[i]-'0';\r         }\r         // if pure number, just return\r         if(i > endIndex)  return {number};\r         \r         vector<int> diffWays, lefts, rights;\r         for(int i =startIndex; i< endIndex; i++) {\r             if(isdigit(input[i])) continue;\r             lefts = \r                 diffWaysToComputeWithMemo(input, startIndex, i-1);\r             rights = \r                 diffWaysToComputeWithMemo(input, i+1, endIndex );\r             for(int j = 0; j < lefts.size(); ++j) \r                 for( int k =0; k < rights.size(); ++k) \r                     diffWays.push_back(compute(lefts[j], rights[k], input[i]));\r         }\r         memo[cache_key] = diffWays;\r         return diffWays;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Different Ways to Add Parentheses(Memoization).cpp\\Solution\\compute(int,int,char)"
    },
    {
        "f": [
            "unordered_map<string, vector<int>> memo;"
        ],
        "fm": "string generateKey(int startIndex, int endIndex) {\r         return to_string(startIndex) + \"-\" + to_string(endIndex);\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_generateKey_int_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_generateKey_int_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint startIndex=-489878522;\n\n\nint endIndex=-655884145;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode startIndex */\n/* NormalNumberDataNode endIndex */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_generateKey_int_int_random_2\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->generateKey(startIndex,endIndex);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\Solution\\\\generateKey(int,int)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\n\n\nint startIndex=-489878522;\n\n\nint endIndex=-655884145;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode startIndex */\n/* NormalNumberDataNode endIndex */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     unordered_map<string, vector<int>> memo;\r     int compute(int a, int b, char op) {\r         switch(op) {\r             case '+': return a + b;\r             case '-': return a - b;\r             case '*': return a * b;\r         }\r     }\r     \r     string generateKey(int startIndex, int endIndex) {\r         return to_string(startIndex) + \"-\" + to_string(endIndex);\r     }\r \r     vector<int> diffWaysToCompute(string input) {\r         return diffWaysToComputeWithMemo(input, 0, input.size()-1);\r     }\r     vector<int> diffWaysToComputeWithMemo(string& input, int startIndex, int endIndex) {    \r         string cache_key = generateKey(startIndex, endIndex);\r         if(memo.find(cache_key) != memo.end()) return memo[cache_key];\r         \r         int number = 0, i=startIndex;\r         for(; i<= endIndex && isdigit(input[i]); ++i) {\r             number  = number * 10 + input[i]-'0';\r         }\r         // if pure number, just return\r         if(i > endIndex)  return {number};\r         \r         vector<int> diffWays, lefts, rights;\r         for(int i =startIndex; i< endIndex; i++) {\r             if(isdigit(input[i])) continue;\r             lefts = \r                 diffWaysToComputeWithMemo(input, startIndex, i-1);\r             rights = \r                 diffWaysToComputeWithMemo(input, i+1, endIndex );\r             for(int j = 0; j < lefts.size(); ++j) \r                 for( int k =0; k < rights.size(); ++k) \r                     diffWays.push_back(compute(lefts[j], rights[k], input[i]));\r         }\r         memo[cache_key] = diffWays;\r         return diffWays;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Different Ways to Add Parentheses(Memoization).cpp\\Solution\\generateKey(int,int)"
    },
    {
        "f": [
            "unordered_map<string, vector<int>> memo;"
        ],
        "fm": "vector<int> diffWaysToCompute(string input) {\r         return diffWaysToComputeWithMemo(input, 0, input.size()-1);\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_diffWaysToCompute_string_random_2(void) {\n{\nAKA_test_case_name=\"Solution_diffWaysToCompute_string_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\nchar* akaRandomName125145 = new char[2];akaRandomName125145[0] = -61;akaRandomName125145[1] = '\\0';string input=akaRandomName125145;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_diffWaysToCompute_string_random_2\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->diffWaysToCompute(input);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\Solution\\\\diffWaysToCompute(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\nchar* akaRandomName985341 = new char[2];akaRandomName985341[0] = -61;akaRandomName985341[1] = '\\0';string input=akaRandomName985341;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     unordered_map<string, vector<int>> memo;\r     int compute(int a, int b, char op) {\r         switch(op) {\r             case '+': return a + b;\r             case '-': return a - b;\r             case '*': return a * b;\r         }\r     }\r     \r     string generateKey(int startIndex, int endIndex) {\r         return to_string(startIndex) + \"-\" + to_string(endIndex);\r     }\r \r     vector<int> diffWaysToCompute(string input) {\r         return diffWaysToComputeWithMemo(input, 0, input.size()-1);\r     }\r     vector<int> diffWaysToComputeWithMemo(string& input, int startIndex, int endIndex) {    \r         string cache_key = generateKey(startIndex, endIndex);\r         if(memo.find(cache_key) != memo.end()) return memo[cache_key];\r         \r         int number = 0, i=startIndex;\r         for(; i<= endIndex && isdigit(input[i]); ++i) {\r             number  = number * 10 + input[i]-'0';\r         }\r         // if pure number, just return\r         if(i > endIndex)  return {number};\r         \r         vector<int> diffWays, lefts, rights;\r         for(int i =startIndex; i< endIndex; i++) {\r             if(isdigit(input[i])) continue;\r             lefts = \r                 diffWaysToComputeWithMemo(input, startIndex, i-1);\r             rights = \r                 diffWaysToComputeWithMemo(input, i+1, endIndex );\r             for(int j = 0; j < lefts.size(); ++j) \r                 for( int k =0; k < rights.size(); ++k) \r                     diffWays.push_back(compute(lefts[j], rights[k], input[i]));\r         }\r         memo[cache_key] = diffWays;\r         return diffWays;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Different Ways to Add Parentheses(Memoization).cpp\\Solution\\diffWaysToCompute(string)"
    },
    {
        "f": [
            "unordered_map<string, vector<int>> memo;"
        ],
        "fm": "vector<int> diffWaysToComputeWithMemo(string& input, int startIndex, int endIndex) {    \r         string cache_key = generateKey(startIndex, endIndex);\r         if(memo.find(cache_key) != memo.end()) return memo[cache_key];\r         \r         int number = 0, i=startIndex;\r         for(; i<= endIndex && isdigit(input[i]); ++i) {\r             number  = number * 10 + input[i]-'0';\r         }\r         // if pure number, just return\r         if(i > endIndex)  return {number};\r         \r         vector<int> diffWays, lefts, rights;\r         for(int i =startIndex; i< endIndex; i++) {\r             if(isdigit(input[i])) continue;\r             lefts = \r                 diffWaysToComputeWithMemo(input, startIndex, i-1);\r             rights = \r                 diffWaysToComputeWithMemo(input, i+1, endIndex );\r             for(int j = 0; j < lefts.size(); ++j) \r                 for( int k =0; k < rights.size(); ++k) \r                     diffWays.push_back(compute(lefts[j], rights[k], input[i]));\r         }\r         memo[cache_key] = diffWays;\r         return diffWays;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_diffWaysToComputeWithMemo_string_int_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_diffWaysToComputeWithMemo_string_int_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\nstring input=\"\";\n\n\nint startIndex=0;\n\n\nint endIndex=0;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* NormalNumberDataNode startIndex */\n/* NormalNumberDataNode endIndex */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_diffWaysToComputeWithMemo_string_int_int_directed_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->diffWaysToComputeWithMemo(input,startIndex,endIndex);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\Solution\\\\diffWaysToComputeWithMemo(string&,int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\nstring input=\"\";\n\n\nint startIndex=0;\n\n\nint endIndex=0;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* NormalNumberDataNode startIndex */\n/* NormalNumberDataNode endIndex */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_diffWaysToComputeWithMemo_string_int_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_diffWaysToComputeWithMemo_string_int_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\nchar* akaRandomName68957 = new char[2];akaRandomName68957[0] = -14;akaRandomName68957[1] = '\\0';string input=akaRandomName68957;\n\n\nint startIndex=0;\n\n\nint endIndex=7;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* NormalNumberDataNode startIndex */\n/* NormalNumberDataNode endIndex */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_diffWaysToComputeWithMemo_string_int_int_random_1\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->diffWaysToComputeWithMemo(input,startIndex,endIndex);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\Solution\\\\diffWaysToComputeWithMemo(string&,int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses(Memoization).cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n/* UnorderedMapDataNode memo */\n\n\nchar* akaRandomName470258 = new char[2];akaRandomName470258[0] = -14;akaRandomName470258[1] = '\\0';string input=akaRandomName470258;\n\n\nint startIndex=0;\n\n\nint endIndex=7;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* NormalNumberDataNode startIndex */\n/* NormalNumberDataNode endIndex */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     unordered_map<string, vector<int>> memo;\r     int compute(int a, int b, char op) {\r         switch(op) {\r             case '+': return a + b;\r             case '-': return a - b;\r             case '*': return a * b;\r         }\r     }\r     \r     string generateKey(int startIndex, int endIndex) {\r         return to_string(startIndex) + \"-\" + to_string(endIndex);\r     }\r \r     vector<int> diffWaysToCompute(string input) {\r         return diffWaysToComputeWithMemo(input, 0, input.size()-1);\r     }\r     vector<int> diffWaysToComputeWithMemo(string& input, int startIndex, int endIndex) {    \r         string cache_key = generateKey(startIndex, endIndex);\r         if(memo.find(cache_key) != memo.end()) return memo[cache_key];\r         \r         int number = 0, i=startIndex;\r         for(; i<= endIndex && isdigit(input[i]); ++i) {\r             number  = number * 10 + input[i]-'0';\r         }\r         // if pure number, just return\r         if(i > endIndex)  return {number};\r         \r         vector<int> diffWays, lefts, rights;\r         for(int i =startIndex; i< endIndex; i++) {\r             if(isdigit(input[i])) continue;\r             lefts = \r                 diffWaysToComputeWithMemo(input, startIndex, i-1);\r             rights = \r                 diffWaysToComputeWithMemo(input, i+1, endIndex );\r             for(int j = 0; j < lefts.size(); ++j) \r                 for( int k =0; k < rights.size(); ++k) \r                     diffWays.push_back(compute(lefts[j], rights[k], input[i]));\r         }\r         memo[cache_key] = diffWays;\r         return diffWays;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Different Ways to Add Parentheses(Memoization).cpp\\Solution\\diffWaysToComputeWithMemo(string&,int,int)"
    },
    {
        "f": [],
        "fm": "int compute(int a, int b, char op) {\r         switch(op) {\r             case '+': return a + b;\r             case '-': return a - b;\r             case '*': return a * b;\r         }\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_compute_int_int_char_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_compute_int_int_char_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=45;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_compute_int_int_char_directed_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->compute(a,b,op);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses.cpp\\\\Solution\\\\compute(int,int,char)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=45;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_compute_int_int_char_directed_5(void) {\n{\nAKA_test_case_name=\"Solution_compute_int_int_char_directed_5\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=43;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_compute_int_int_char_directed_5\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->compute(a,b,op);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses.cpp\\\\Solution\\\\compute(int,int,char)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=43;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_compute_int_int_char_random_1(void) {\n{\nAKA_test_case_name=\"Solution_compute_int_int_char_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint a=1280330780;\n\n\nint b=2102927511;\n\nchar op=-116;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_compute_int_int_char_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->compute(a,b,op);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses.cpp\\\\Solution\\\\compute(int,int,char)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint a=1280330780;\n\n\nint b=2102927511;\n\nchar op=-116;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_compute_int_int_char_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_compute_int_int_char_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=42;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_compute_int_int_char_directed_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->compute(a,b,op);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses.cpp\\\\Solution\\\\compute(int,int,char)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint a=0;\n\n\nint b=0;\n\nchar op=42;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode a */\n/* NormalNumberDataNode b */\n/* NormalCharacterDataNode op */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     int compute(int a, int b, char op) {\r         switch(op) {\r             case '+': return a + b;\r             case '-': return a - b;\r             case '*': return a * b;\r         }\r     }\r     \r     vector<int> diffWaysToCompute(string input) {\r         int number = 0, i=0;\r         for(; i< input.length() && isdigit(input[i]); ++i) {\r             number  = number * 10 + input[i]-'0';\r         }\r         // if pure number, just return\r         if(i == input.length())\r             return {number};\r         \r         vector<int> diffWays, lefts, rights;\r         for(int i =0; i< input.length(); i++) {\r             if(isdigit(input[i])) continue;\r             lefts = \r                 diffWaysToCompute(input.substr(0, i));\r             rights = \r                 diffWaysToCompute(input.substr(i + 1, input.length() - i - 1));\r             for(int j = 0; j < lefts.size(); ++j) {\r                 for( int k =0; k < rights.size(); ++k) {\r                     diffWays.push_back(compute(lefts[j], rights[k], input[i]));\r                 }\r             }\r         }\r         return diffWays;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Different Ways to Add Parentheses.cpp\\Solution\\compute(int,int,char)"
    },
    {
        "f": [],
        "fm": "vector<int> diffWaysToCompute(string input) {\r         int number = 0, i=0;\r         for(; i< input.length() && isdigit(input[i]); ++i) {\r             number  = number * 10 + input[i]-'0';\r         }\r         // if pure number, just return\r         if(i == input.length())\r             return {number};\r         \r         vector<int> diffWays, lefts, rights;\r         for(int i =0; i< input.length(); i++) {\r             if(isdigit(input[i])) continue;\r             lefts = \r                 diffWaysToCompute(input.substr(0, i));\r             rights = \r                 diffWaysToCompute(input.substr(i + 1, input.length() - i - 1));\r             for(int j = 0; j < lefts.size(); ++j) {\r                 for( int k =0; k < rights.size(); ++k) {\r                     diffWays.push_back(compute(lefts[j], rights[k], input[i]));\r                 }\r             }\r         }\r         return diffWays;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_diffWaysToCompute_string_random_3(void) {\n{\nAKA_test_case_name=\"Solution_diffWaysToCompute_string_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName464992 = new char[2];akaRandomName464992[0] = 91;akaRandomName464992[1] = '\\0';string input=akaRandomName464992;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_diffWaysToCompute_string_random_3\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->diffWaysToCompute(input);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses.cpp\\\\Solution\\\\diffWaysToCompute(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName695581 = new char[2];akaRandomName695581[0] = 91;akaRandomName695581[1] = '\\0';string input=akaRandomName695581;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_diffWaysToCompute_string_random_4(void) {\n{\nAKA_test_case_name=\"Solution_diffWaysToCompute_string_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName543075 = new char[2];akaRandomName543075[0] = 48;akaRandomName543075[1] = '\\0';string input=akaRandomName543075;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_diffWaysToCompute_string_random_4\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->diffWaysToCompute(input);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Different Ways to Add Parentheses.cpp\\\\Solution\\\\diffWaysToCompute(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Different Ways to Add Parentheses.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName320054 = new char[2];akaRandomName320054[0] = 48;akaRandomName320054[1] = '\\0';string input=akaRandomName320054;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode input */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     int compute(int a, int b, char op) {\r         switch(op) {\r             case '+': return a + b;\r             case '-': return a - b;\r             case '*': return a * b;\r         }\r     }\r     \r     vector<int> diffWaysToCompute(string input) {\r         int number = 0, i=0;\r         for(; i< input.length() && isdigit(input[i]); ++i) {\r             number  = number * 10 + input[i]-'0';\r         }\r         // if pure number, just return\r         if(i == input.length())\r             return {number};\r         \r         vector<int> diffWays, lefts, rights;\r         for(int i =0; i< input.length(); i++) {\r             if(isdigit(input[i])) continue;\r             lefts = \r                 diffWaysToCompute(input.substr(0, i));\r             rights = \r                 diffWaysToCompute(input.substr(i + 1, input.length() - i - 1));\r             for(int j = 0; j < lefts.size(); ++j) {\r                 for( int k =0; k < rights.size(); ++k) {\r                     diffWays.push_back(compute(lefts[j], rights[k], input[i]));\r                 }\r             }\r         }\r         return diffWays;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Different Ways to Add Parentheses.cpp\\Solution\\diffWaysToCompute(string)"
    },
    {
        "f": [],
        "fm": "int numDistinct(string S, string T) {\r \t\tint match[200];\r \t\tif (S.size() < T.size()) return 0;\r \t\tmatch[0] = 1;\r \t\tfor (int i = 1; i <= T.size(); i++)\r \t\t\tmatch[i] = 0;\r \t\tfor (int i = 1; i <= S.size(); i ++)\r \t\t\tfor (int j = T.size(); j >= 1; j--)\r \t\t\t\tif (S[i - 1] == T[j - 1])\r \t\t\t\t\tmatch[j] += match[j - 1];\r \t\treturn match[T.size()];\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_numDistinct_string_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_numDistinct_string_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Distinct_Subsequences.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName505011 = new char[2];akaRandomName505011[0] = 29;akaRandomName505011[1] = '\\0';string S=akaRandomName505011;\nchar* akaRandomName408093 = new char[2];akaRandomName408093[0] = 54;akaRandomName408093[1] = '\\0';string T=akaRandomName408093;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode T */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_numDistinct_string_string_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->numDistinct(S,T);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Distinct_Subsequences.cpp\\\\Solution\\\\numDistinct(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Distinct_Subsequences.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName79834 = new char[2];akaRandomName79834[0] = 29;akaRandomName79834[1] = '\\0';string S=akaRandomName79834;\nchar* akaRandomName146216 = new char[2];akaRandomName146216[0] = 54;akaRandomName146216[1] = '\\0';string T=akaRandomName146216;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode T */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_numDistinct_string_string_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_numDistinct_string_string_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Distinct_Subsequences.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring S=\"\";\nstring T=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode T */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_numDistinct_string_string_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->numDistinct(S,T);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Distinct_Subsequences.cpp\\\\Solution\\\\numDistinct(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Distinct_Subsequences.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring S=\"\";\nstring T=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode T */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_numDistinct_string_string_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_numDistinct_string_string_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Distinct_Subsequences.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring S=\"\";\nstring T=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode T */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_numDistinct_string_string_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->numDistinct(S,T);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Distinct_Subsequences.cpp\\\\Solution\\\\numDistinct(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Distinct_Subsequences.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring S=\"\";\nstring T=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode T */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_numDistinct_string_string_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_numDistinct_string_string_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Distinct_Subsequences.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring S=\"\";\nstring T=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode T */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_numDistinct_string_string_directed_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->numDistinct(S,T);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Distinct_Subsequences.cpp\\\\Solution\\\\numDistinct(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Distinct_Subsequences.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring S=\"\";\nstring T=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode S */\n/* NormalStringDataNode T */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint numDistinct(string S, string T) {\r \t\tint match[200];\r \t\tif (S.size() < T.size()) return 0;\r \t\tmatch[0] = 1;\r \t\tfor (int i = 1; i <= T.size(); i++)\r \t\t\tmatch[i] = 0;\r \t\tfor (int i = 1; i <= S.size(); i ++)\r \t\t\tfor (int j = T.size(); j >= 1; j--)\r \t\t\t\tif (S[i - 1] == T[j - 1])\r \t\t\t\t\tmatch[j] += match[j - 1];\r \t\treturn match[T.size()];\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Distinct_Subsequences.cpp\\Solution\\numDistinct(string,string)"
    },
    {
        "f": [],
        "fm": "int divide(int dividend, int divisor) {\r \t\tint sign = 1;\r \t\tif (dividend == 0) return 0;\r \t\tif (dividend < 0) sign *= -1;\r \t\tif (divisor < 0) sign *= -1;\r \t\tunsigned int dvd = dividend > 0 ? dividend : -dividend;\r \t\tunsigned int dvs = divisor > 0 ? divisor : -divisor; //abs(divisor);\r \t\tunsigned int inc[32];\r \t\tunsigned int migValue = dvs;\r \t\tint i = 0;\r \t\twhile (migValue > 0 && migValue <= dvd)\r \t\t{\r \t\t\tinc[i] = migValue;\r \t\t\tmigValue = migValue << 1;\r \t\t\ti++;\r \t\t}\r \t\ti--;\r \t\tunsigned int res = 0;\r \t\twhile (i >= 0 && dvd != 0)\r \t\t{\r \t\t\tif (dvd >= inc[i])\r \t\t\t{\r \t\t\t\tdvd = dvd - inc[i];\r \t\t\t\tres += 1 << i;\r \t\t\t}\r \t\t\ti--;\r \t\t}\r \t\tres *= sign;\r \t\treturn res;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_divide_int_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_divide_int_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Divide_Two_Integers.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint dividend=1;\n\n\nint divisor=0;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode dividend */\n/* NormalNumberDataNode divisor */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_divide_int_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->divide(dividend,divisor);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Divide_Two_Integers.cpp\\\\Solution\\\\divide(int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Divide_Two_Integers.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint dividend=1;\n\n\nint divisor=0;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode dividend */\n/* NormalNumberDataNode divisor */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_divide_int_int_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_divide_int_int_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Divide_Two_Integers.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint dividend=0;\n\n\nint divisor=-2147483648;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode dividend */\n/* NormalNumberDataNode divisor */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_divide_int_int_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->divide(dividend,divisor);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Divide_Two_Integers.cpp\\\\Solution\\\\divide(int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Divide_Two_Integers.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint dividend=0;\n\n\nint divisor=-2147483648;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode dividend */\n/* NormalNumberDataNode divisor */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_divide_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_divide_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Divide_Two_Integers.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint dividend=-2104360751;\n\n\nint divisor=-974916990;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode dividend */\n/* NormalNumberDataNode divisor */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_divide_int_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->divide(dividend,divisor);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Divide_Two_Integers.cpp\\\\Solution\\\\divide(int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Divide_Two_Integers.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint dividend=-2104360751;\n\n\nint divisor=-974916990;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode dividend */\n/* NormalNumberDataNode divisor */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_divide_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_divide_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Divide_Two_Integers.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint dividend=1249310456;\n\n\nint divisor=165179742;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode dividend */\n/* NormalNumberDataNode divisor */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_divide_int_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->divide(dividend,divisor);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Divide_Two_Integers.cpp\\\\Solution\\\\divide(int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Divide_Two_Integers.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint dividend=1249310456;\n\n\nint divisor=165179742;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode dividend */\n/* NormalNumberDataNode divisor */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint divide(int dividend, int divisor) {\r \t\tint sign = 1;\r \t\tif (dividend == 0) return 0;\r \t\tif (dividend < 0) sign *= -1;\r \t\tif (divisor < 0) sign *= -1;\r \t\tunsigned int dvd = dividend > 0 ? dividend : -dividend;\r \t\tunsigned int dvs = divisor > 0 ? divisor : -divisor; //abs(divisor);\r \t\tunsigned int inc[32];\r \t\tunsigned int migValue = dvs;\r \t\tint i = 0;\r \t\twhile (migValue > 0 && migValue <= dvd)\r \t\t{\r \t\t\tinc[i] = migValue;\r \t\t\tmigValue = migValue << 1;\r \t\t\ti++;\r \t\t}\r \t\ti--;\r \t\tunsigned int res = 0;\r \t\twhile (i >= 0 && dvd != 0)\r \t\t{\r \t\t\tif (dvd >= inc[i])\r \t\t\t{\r \t\t\t\tdvd = dvd - inc[i];\r \t\t\t\tres += 1 << i;\r \t\t\t}\r \t\t\ti--;\r \t\t}\r \t\tres *= sign;\r \t\treturn res;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Divide_Two_Integers.cpp\\Solution\\divide(int,int)"
    },
    {
        "f": [],
        "fm": "int minDistance(string word1, string word2) {\r \t\tif (word1.size() < word2.size())\r \t\t\tword1.swap(word2);\r \t\tint * matchUp = new int[20000];\r \t\tint* matchDown = new int[20000];\r \t\tfor (int i = 0; i <= word2.size(); i++)\r \t\t{\r \t\t\tmatchUp[i] = 0;\r \t\t\tmatchDown[i] = i;\r \t\t}\r \t\tfor (int i = 1; i <= word1.size(); i++)\r \t\t{\r \t\t\tmatchUp[0] = i;\r \t\t\tfor (int j = 1; j <= word2.size(); j++)\r \t\t\t{\r \t\t\t\tif (word1[i - 1] == word2[j - 1])\r \t\t\t\t{\r \t\t\t\t\tmatchUp[j] = matchDown[j - 1];\r \t\t\t\t}\r \t\t\t\telse\r \t\t\t\t{\r \t\t\t\t\tmatchUp[j] = min(matchDown[j], matchDown[j - 1]);\r \t\t\t\t\tmatchUp[j] = min(matchUp[j], matchUp[j - 1]) + 1;\r \t\t\t\t}\r \t\t\t}\r \t\t\tint* temp = matchUp;\r \t\t\tmatchUp = matchDown;\r \t\t\tmatchDown = temp;\r \t\t}\r \t\treturn matchDown[word2.size()];\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName580560 = new char[2];akaRandomName580560[0] = 12;akaRandomName580560[1] = '\\0';string word1=akaRandomName580560;\nchar* akaRandomName756183 = new char[2];akaRandomName756183[0] = -83;akaRandomName756183[1] = '\\0';string word2=akaRandomName756183;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName222038 = new char[2];akaRandomName222038[0] = 12;akaRandomName222038[1] = '\\0';string word1=akaRandomName222038;\nchar* akaRandomName193310 = new char[2];akaRandomName193310[0] = -83;akaRandomName193310[1] = '\\0';string word2=akaRandomName193310;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_10(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_10\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName295800 = new char[2];akaRandomName295800[0] = 0;akaRandomName295800[1] = '\\0';string word1=akaRandomName295800;\nchar* akaRandomName487996 = new char[2];akaRandomName487996[0] = 0;akaRandomName487996[1] = '\\0';string word2=akaRandomName487996;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_10\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName723000 = new char[2];akaRandomName723000[0] = 0;akaRandomName723000[1] = '\\0';string word1=akaRandomName723000;\nchar* akaRandomName727558 = new char[2];akaRandomName727558[0] = 0;akaRandomName727558[1] = '\\0';string word2=akaRandomName727558;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_9(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_9\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName702061 = new char[2];akaRandomName702061[0] = 0;akaRandomName702061[1] = '\\0';string word1=akaRandomName702061;\nchar* akaRandomName823797 = new char[3];akaRandomName823797[0] = 0;akaRandomName823797[1] = 0;akaRandomName823797[2] = '\\0';string word2=akaRandomName823797;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_9\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName413989 = new char[2];akaRandomName413989[0] = 0;akaRandomName413989[1] = '\\0';string word1=akaRandomName413989;\nchar* akaRandomName43823 = new char[3];akaRandomName43823[0] = 0;akaRandomName43823[1] = 0;akaRandomName43823[2] = '\\0';string word2=akaRandomName43823;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_11(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_11\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_11\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_6(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_6\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_6\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_5(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_5\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_5\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_8(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_8\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_8\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_7(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_7\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName526360 = new char[2];akaRandomName526360[0] = 0;akaRandomName526360[1] = '\\0';string word1=akaRandomName526360;\nchar* akaRandomName486185 = new char[2];akaRandomName486185[0] = 0;akaRandomName486185[1] = '\\0';string word2=akaRandomName486185;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_7\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName215739 = new char[2];akaRandomName215739[0] = 0;akaRandomName215739[1] = '\\0';string word1=akaRandomName215739;\nchar* akaRandomName192354 = new char[2];akaRandomName192354[0] = 0;akaRandomName192354[1] = '\\0';string word2=akaRandomName192354;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 9,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 10,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName74760 = new char[2];akaRandomName74760[0] = 0;akaRandomName74760[1] = '\\0';string word1=akaRandomName74760;\nchar* akaRandomName724041 = new char[2];akaRandomName724041[0] = 0;akaRandomName724041[1] = '\\0';string word2=akaRandomName724041;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName543238 = new char[2];akaRandomName543238[0] = 0;akaRandomName543238[1] = '\\0';string word1=akaRandomName543238;\nchar* akaRandomName839559 = new char[2];akaRandomName839559[0] = 0;akaRandomName839559[1] = '\\0';string word2=akaRandomName839559;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 11,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstring word1=\"\";\nstring word2=\"\";\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 12,
                "dt": {},
                "td": "void AKA_TEST_Solution_minDistance_string_string_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_minDistance_string_string_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName953043 = new char[2];akaRandomName953043[0] = 0;akaRandomName953043[1] = '\\0';string word1=akaRandomName953043;\nchar* akaRandomName616083 = new char[2];akaRandomName616083[0] = 0;akaRandomName616083[1] = '\\0';string word2=akaRandomName616083;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_minDistance_string_string_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->minDistance(word1,word2);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Edit_Distance.cpp\\\\Solution\\\\minDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Edit_Distance.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName593725 = new char[2];akaRandomName593725[0] = 0;akaRandomName593725[1] = '\\0';string word1=akaRandomName593725;\nchar* akaRandomName80062 = new char[2];akaRandomName80062[0] = 0;akaRandomName80062[1] = '\\0';string word2=akaRandomName80062;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode word1 */\n/* NormalStringDataNode word2 */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint minDistance(string word1, string word2) {\r \t\tif (word1.size() < word2.size())\r \t\t\tword1.swap(word2);\r \t\tint * matchUp = new int[20000];\r \t\tint* matchDown = new int[20000];\r \t\tfor (int i = 0; i <= word2.size(); i++)\r \t\t{\r \t\t\tmatchUp[i] = 0;\r \t\t\tmatchDown[i] = i;\r \t\t}\r \t\tfor (int i = 1; i <= word1.size(); i++)\r \t\t{\r \t\t\tmatchUp[0] = i;\r \t\t\tfor (int j = 1; j <= word2.size(); j++)\r \t\t\t{\r \t\t\t\tif (word1[i - 1] == word2[j - 1])\r \t\t\t\t{\r \t\t\t\t\tmatchUp[j] = matchDown[j - 1];\r \t\t\t\t}\r \t\t\t\telse\r \t\t\t\t{\r \t\t\t\t\tmatchUp[j] = min(matchDown[j], matchDown[j - 1]);\r \t\t\t\t\tmatchUp[j] = min(matchUp[j], matchUp[j - 1]) + 1;\r \t\t\t\t}\r \t\t\t}\r \t\t\tint* temp = matchUp;\r \t\t\tmatchUp = matchDown;\r \t\t\tmatchDown = temp;\r \t\t}\r \t\treturn matchDown[word2.size()];\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Edit_Distance.cpp\\Solution\\minDistance(string,string)"
    },
    {
        "f": [],
        "fm": "int evalRPN(vector<string> &tokens) {\r \t\tstack<int> operand;\r \t\tfor (int i = 0; i < tokens.size(); i++)\r \t\t{\r \t\t\tif ((tokens[i][0] == '-' && tokens[i].size() > 1)\r \t\t\t        || (tokens[i][0] >= '0' && tokens[i][0] <= '9'))\r \t\t\t{\r \t\t\t\toperand.push(atoi(tokens[i].c_str()));\r \t\t\t\tcontinue;\r \t\t\t}\r \t\t\tint op1 = operand.top();\r \t\t\toperand.pop();\r \t\t\tint op2 = operand.top();\r \t\t\toperand.pop();\r \t\t\tif (tokens[i] == \"+\") operand.push(op2 + op1);\r \t\t\tif (tokens[i] == \"-\") operand.push(op2 - op1);\r \t\t\tif (tokens[i] == \"*\") operand.push(op2 * op1);\r \t\t\tif (tokens[i] == \"/\") operand.push(op2 / op1);\r \t\t}\r \t\treturn operand.top();\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_10(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_10\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_10\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_9(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_9\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nstring tokens_element0=\"\";\ntokens.push_back(tokens_element0);\nstring tokens_element1=\"\";\ntokens.push_back(tokens_element1);\nstring tokens_element2=\"\";\ntokens.push_back(tokens_element2);\nstring tokens_element3=\"\";\ntokens.push_back(tokens_element3);\nstring tokens_element4=\"\";\ntokens.push_back(tokens_element4);\nstring tokens_element5=\"\";\ntokens.push_back(tokens_element5);\nstring tokens_element6=\"\";\ntokens.push_back(tokens_element6);\nstring tokens_element7=\"\";\ntokens.push_back(tokens_element7);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_9\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nstring tokens_element0=\"\";\ntokens.push_back(tokens_element0);\nstring tokens_element1=\"\";\ntokens.push_back(tokens_element1);\nstring tokens_element2=\"\";\ntokens.push_back(tokens_element2);\nstring tokens_element3=\"\";\ntokens.push_back(tokens_element3);\nstring tokens_element4=\"\";\ntokens.push_back(tokens_element4);\nstring tokens_element5=\"\";\ntokens.push_back(tokens_element5);\nstring tokens_element6=\"\";\ntokens.push_back(tokens_element6);\nstring tokens_element7=\"\";\ntokens.push_back(tokens_element7);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_8(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_8\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_8\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_7(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_7\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_7\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nchar* akaRandomName30752 = new char[2];akaRandomName30752[0] = 98;akaRandomName30752[1] = '\\0';string tokens_element0=akaRandomName30752;\ntokens.push_back(tokens_element0);\nchar* akaRandomName771236 = new char[2];akaRandomName771236[0] = -31;akaRandomName771236[1] = '\\0';string tokens_element1=akaRandomName771236;\ntokens.push_back(tokens_element1);\nchar* akaRandomName397793 = new char[2];akaRandomName397793[0] = 95;akaRandomName397793[1] = '\\0';string tokens_element2=akaRandomName397793;\ntokens.push_back(tokens_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nchar* akaRandomName571808 = new char[2];akaRandomName571808[0] = 98;akaRandomName571808[1] = '\\0';string tokens_element0=akaRandomName571808;\ntokens.push_back(tokens_element0);\nchar* akaRandomName146239 = new char[2];akaRandomName146239[0] = -31;akaRandomName146239[1] = '\\0';string tokens_element1=akaRandomName146239;\ntokens.push_back(tokens_element1);\nchar* akaRandomName41207 = new char[2];akaRandomName41207[0] = 95;akaRandomName41207[1] = '\\0';string tokens_element2=akaRandomName41207;\ntokens.push_back(tokens_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 9,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_6(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_6\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nstring tokens_element0=\"\";\ntokens.push_back(tokens_element0);\nstring tokens_element1=\"\";\ntokens.push_back(tokens_element1);\nstring tokens_element2=\"\";\ntokens.push_back(tokens_element2);\nstring tokens_element3=\"\";\ntokens.push_back(tokens_element3);\nstring tokens_element4=\"\";\ntokens.push_back(tokens_element4);\nstring tokens_element5=\"\";\ntokens.push_back(tokens_element5);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_6\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nstring tokens_element0=\"\";\ntokens.push_back(tokens_element0);\nstring tokens_element1=\"\";\ntokens.push_back(tokens_element1);\nstring tokens_element2=\"\";\ntokens.push_back(tokens_element2);\nstring tokens_element3=\"\";\ntokens.push_back(tokens_element3);\nstring tokens_element4=\"\";\ntokens.push_back(tokens_element4);\nstring tokens_element5=\"\";\ntokens.push_back(tokens_element5);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 10,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_5(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_5\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_5\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 11,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_11(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_11\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nstring tokens_element0=\"\";\ntokens.push_back(tokens_element0);\nstring tokens_element1=\"\";\ntokens.push_back(tokens_element1);\nstring tokens_element2=\"\";\ntokens.push_back(tokens_element2);\nstring tokens_element3=\"\";\ntokens.push_back(tokens_element3);\nstring tokens_element4=\"\";\ntokens.push_back(tokens_element4);\nstring tokens_element5=\"\";\ntokens.push_back(tokens_element5);\nstring tokens_element6=\"\";\ntokens.push_back(tokens_element6);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_11\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nstring tokens_element0=\"\";\ntokens.push_back(tokens_element0);\nstring tokens_element1=\"\";\ntokens.push_back(tokens_element1);\nstring tokens_element2=\"\";\ntokens.push_back(tokens_element2);\nstring tokens_element3=\"\";\ntokens.push_back(tokens_element3);\nstring tokens_element4=\"\";\ntokens.push_back(tokens_element4);\nstring tokens_element5=\"\";\ntokens.push_back(tokens_element5);\nstring tokens_element6=\"\";\ntokens.push_back(tokens_element6);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 12,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 13,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_directed_12(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_directed_12\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nstring tokens_element0=\"\";\ntokens.push_back(tokens_element0);\nstring tokens_element1=\"\";\ntokens.push_back(tokens_element1);\nstring tokens_element2=\"\";\ntokens.push_back(tokens_element2);\nstring tokens_element3=\"\";\ntokens.push_back(tokens_element3);\nstring tokens_element4=\"\";\ntokens.push_back(tokens_element4);\nstring tokens_element5=\"\";\ntokens.push_back(tokens_element5);\nstring tokens_element6=\"\";\ntokens.push_back(tokens_element6);\nstring tokens_element7=\"\";\ntokens.push_back(tokens_element7);\nstring tokens_element8=\"\";\ntokens.push_back(tokens_element8);\nstring tokens_element9=\"\";\ntokens.push_back(tokens_element9);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_directed_12\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nstring tokens_element0=\"\";\ntokens.push_back(tokens_element0);\nstring tokens_element1=\"\";\ntokens.push_back(tokens_element1);\nstring tokens_element2=\"\";\ntokens.push_back(tokens_element2);\nstring tokens_element3=\"\";\ntokens.push_back(tokens_element3);\nstring tokens_element4=\"\";\ntokens.push_back(tokens_element4);\nstring tokens_element5=\"\";\ntokens.push_back(tokens_element5);\nstring tokens_element6=\"\";\ntokens.push_back(tokens_element6);\nstring tokens_element7=\"\";\ntokens.push_back(tokens_element7);\nstring tokens_element8=\"\";\ntokens.push_back(tokens_element8);\nstring tokens_element9=\"\";\ntokens.push_back(tokens_element9);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 14,
                "dt": {},
                "td": "void AKA_TEST_Solution_evalRPN_vector_string_random_3(void) {\n{\nAKA_test_case_name=\"Solution_evalRPN_vector_string_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nchar* akaRandomName7651 = new char[2];akaRandomName7651[0] = -83;akaRandomName7651[1] = '\\0';string tokens_element0=akaRandomName7651;\ntokens.push_back(tokens_element0);\nchar* akaRandomName989905 = new char[2];akaRandomName989905[0] = -38;akaRandomName989905[1] = '\\0';string tokens_element1=akaRandomName989905;\ntokens.push_back(tokens_element1);\nchar* akaRandomName284319 = new char[2];akaRandomName284319[0] = -32;akaRandomName284319[1] = '\\0';string tokens_element2=akaRandomName284319;\ntokens.push_back(tokens_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_evalRPN_vector_string_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->evalRPN(tokens);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\Solution\\\\evalRPN(vector<string>&)\");\n\n\nvector<string> EXPECTED_tokens;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Evaluate_Reverse_Polish_Notation.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<string> tokens;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode tokens */\nchar* akaRandomName439811 = new char[2];akaRandomName439811[0] = -83;akaRandomName439811[1] = '\\0';string tokens_element0=akaRandomName439811;\ntokens.push_back(tokens_element0);\nchar* akaRandomName830791 = new char[2];akaRandomName830791[0] = -38;akaRandomName830791[1] = '\\0';string tokens_element1=akaRandomName830791;\ntokens.push_back(tokens_element1);\nchar* akaRandomName642512 = new char[2];akaRandomName642512[0] = -32;akaRandomName642512[1] = '\\0';string tokens_element2=akaRandomName642512;\ntokens.push_back(tokens_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint evalRPN(vector<string> &tokens) {\r \t\tstack<int> operand;\r \t\tfor (int i = 0; i < tokens.size(); i++)\r \t\t{\r \t\t\tif ((tokens[i][0] == '-' && tokens[i].size() > 1)\r \t\t\t        || (tokens[i][0] >= '0' && tokens[i][0] <= '9'))\r \t\t\t{\r \t\t\t\toperand.push(atoi(tokens[i].c_str()));\r \t\t\t\tcontinue;\r \t\t\t}\r \t\t\tint op1 = operand.top();\r \t\t\toperand.pop();\r \t\t\tint op2 = operand.top();\r \t\t\toperand.pop();\r \t\t\tif (tokens[i] == \"+\") operand.push(op2 + op1);\r \t\t\tif (tokens[i] == \"-\") operand.push(op2 - op1);\r \t\t\tif (tokens[i] == \"*\") operand.push(op2 * op1);\r \t\t\tif (tokens[i] == \"/\") operand.push(op2 / op1);\r \t\t}\r \t\treturn operand.top();\r \t}\r \r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Evaluate_Reverse_Polish_Notation.cpp\\Solution\\evalRPN(vector<string>&)"
    },
    {
        "f": [],
        "fm": "int findDuplicate(vector<int>& nums) {\r \t\tint length = nums.size();\r \t\t            \r \t\tfor(int i =0; i< length; i++) {\r \t\t\tif(nums[i] == i+1) {\r \t\t\t\tcontinue;\r \t\t\t}\r \t\t\t\t\t\t\t\t\t                \r \t\t\tint oldIndex = i;\r \t\t\tint newIndex = nums[i]-1;\r \t\t\twhile(nums[oldIndex] != oldIndex +1 ) {\r \t\t\t\tif(nums[oldIndex] == nums[newIndex] ) {\r \t\t\t\t\treturn nums[oldIndex];\r \t\t\t\t}\r \t\t\t\tint temp = nums[newIndex];\r \t\t\t\tnums[newIndex] = nums[oldIndex];\r \t\t\t\tnums[oldIndex] = temp;\r \t\t\t\t\r \t\t\t\tnewIndex = nums[oldIndex] -1;\r \t\t\t}\r \t\t}\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_findDuplicate_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_findDuplicate_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Find_the_Duplicate_Number.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-174260642;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findDuplicate_vector_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findDuplicate(nums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Find_the_Duplicate_Number.cpp\\\\Solution\\\\findDuplicate(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Find_the_Duplicate_Number.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-174260642;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_findDuplicate_vector_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_findDuplicate_vector_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Find_the_Duplicate_Number.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findDuplicate_vector_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findDuplicate(nums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Find_the_Duplicate_Number.cpp\\\\Solution\\\\findDuplicate(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Find_the_Duplicate_Number.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint findDuplicate(vector<int>& nums) {\r \t\tint length = nums.size();\r \t\t            \r \t\tfor(int i =0; i< length; i++) {\r \t\t\tif(nums[i] == i+1) {\r \t\t\t\tcontinue;\r \t\t\t}\r \t\t\t\t\t\t\t\t\t                \r \t\t\tint oldIndex = i;\r \t\t\tint newIndex = nums[i]-1;\r \t\t\twhile(nums[oldIndex] != oldIndex +1 ) {\r \t\t\t\tif(nums[oldIndex] == nums[newIndex] ) {\r \t\t\t\t\treturn nums[oldIndex];\r \t\t\t\t}\r \t\t\t\tint temp = nums[newIndex];\r \t\t\t\tnums[newIndex] = nums[oldIndex];\r \t\t\t\tnums[oldIndex] = temp;\r \t\t\t\t\r \t\t\t\tnewIndex = nums[oldIndex] -1;\r \t\t\t}\r \t\t}\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Find_the_Duplicate_Number.cpp\\Solution\\findDuplicate(vector<int>&)"
    },
    {
        "f": [],
        "fm": "int firstBadVersion(int n) {\r         int start = 0, end = n-1;\r         while(start <=end) {\r             int mid = start + (end - start)/2;\r             bool isBad = isBadVersion(mid);\r             if(isBad == false) {\r                 start = mid +1;\r             } else {\r                 end = mid-1;\r             }\r         }\r         \r         return start;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_firstBadVersion_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_firstBadVersion_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\First_Bad_Version.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=8;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_firstBadVersion_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->firstBadVersion(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\First_Bad_Version.cpp\\\\Solution\\\\firstBadVersion(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\First_Bad_Version.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=8;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_firstBadVersion_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_firstBadVersion_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\First_Bad_Version.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=5;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_firstBadVersion_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->firstBadVersion(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\First_Bad_Version.cpp\\\\Solution\\\\firstBadVersion(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\First_Bad_Version.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=5;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     int firstBadVersion(int n) {\r         int start = 0, end = n-1;\r         while(start <=end) {\r             int mid = start + (end - start)/2;\r             bool isBad = isBadVersion(mid);\r             if(isBad == false) {\r                 start = mid +1;\r             } else {\r                 end = mid-1;\r             }\r         }\r         \r         return start;\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\First_Bad_Version.cpp\\Solution\\firstBadVersion(int)"
    },
    {
        "f": [],
        "fm": "int firstMissingPositive(vector<int>& nums) {\r \t\tint i = 0;\r \t\tint n = nums.size();\r \t\tfor (int i = 0; i < n; i++)\r \t\t{\r \t\t\twhile (nums[i] != i + 1)\r \t\t\t{\r \t\t\t\tif (nums[i] <= 0 || nums[i] > n || nums[i] == nums[nums[i] - 1]) break;\r \t\t\t\tint temp = nums[i];\r \t\t\t\tnums[i] = nums[temp - 1];\r \t\t\t\tnums[temp - 1] = temp;\r \t\t\t}\r \t\t}\r \t\tfor (int i = 0; i < n; i++)\r \t\t\tif (nums[i] != i + 1)\r \t\t\t\treturn i + 1;\r \t\treturn n + 1;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_firstMissingPositive_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_firstMissingPositive_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\First_Missing_Positive.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-331273977;\nnums.push_back(nums_element0);\nint nums_element1=-895301083;\nnums.push_back(nums_element1);\nint nums_element2=676307338;\nnums.push_back(nums_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_firstMissingPositive_vector_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->firstMissingPositive(nums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\First_Missing_Positive.cpp\\\\Solution\\\\firstMissingPositive(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\First_Missing_Positive.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-331273977;\nnums.push_back(nums_element0);\nint nums_element1=-895301083;\nnums.push_back(nums_element1);\nint nums_element2=676307338;\nnums.push_back(nums_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_firstMissingPositive_vector_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_firstMissingPositive_vector_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\First_Missing_Positive.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_firstMissingPositive_vector_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->firstMissingPositive(nums);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\First_Missing_Positive.cpp\\\\Solution\\\\firstMissingPositive(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\First_Missing_Positive.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint firstMissingPositive(vector<int>& nums) {\r \t\tint i = 0;\r \t\tint n = nums.size();\r \t\tfor (int i = 0; i < n; i++)\r \t\t{\r \t\t\twhile (nums[i] != i + 1)\r \t\t\t{\r \t\t\t\tif (nums[i] <= 0 || nums[i] > n || nums[i] == nums[nums[i] - 1]) break;\r \t\t\t\tint temp = nums[i];\r \t\t\t\tnums[i] = nums[temp - 1];\r \t\t\t\tnums[temp - 1] = temp;\r \t\t\t}\r \t\t}\r \t\tfor (int i = 0; i < n; i++)\r \t\t\tif (nums[i] != i + 1)\r \t\t\t\treturn i + 1;\r \t\treturn n + 1;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\First_Missing_Positive.cpp\\Solution\\firstMissingPositive(vector<int>&)"
    },
    {
        "f": [],
        "fm": "int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\r \t\tvector<int> diff(gas.size());\r \t\tfor (int i = 0; i < gas.size(); ++i)\r \t\t{\r \t\t\tdiff[i] = gas[i] - cost[i];\r \t\t}\r \t\tint leftGas = 0, sum = 0, startnode = 0;\r \t\tfor (int i = 0; i < gas.size(); ++i)\r \t\t{\r \t\t\tleftGas += diff[i];\r \t\t\tsum += diff[i];\r \t\t\tif (sum < 0) //if less than 0, skip it\r \t\t\t{\r \t\t\t\tstartnode = i + 1;\r \t\t\t\tsum = 0;\r \t\t\t}\r \t\t}\r \t\tif (leftGas < 0)\r \t\t\treturn -1;\r \t\telse\r \t\t\treturn startnode;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_canCompleteCircuit_vector_int_vector_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_canCompleteCircuit_vector_int_vector_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canCompleteCircuit_vector_int_vector_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canCompleteCircuit(gas,cost);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Gas_Station.cpp\\\\Solution\\\\canCompleteCircuit(vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_gas;\n\nvector<int> EXPECTED_cost;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_canCompleteCircuit_vector_int_vector_int_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_canCompleteCircuit_vector_int_vector_int_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* element #5 : null value -> no code */\ngas.push_back(gas_element5);\n/* element #6 : null value -> no code */\ngas.push_back(gas_element6);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* element #5 : null value -> no code */\ncost.push_back(cost_element5);\n/* element #6 : null value -> no code */\ncost.push_back(cost_element6);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canCompleteCircuit_vector_int_vector_int_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canCompleteCircuit(gas,cost);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Gas_Station.cpp\\\\Solution\\\\canCompleteCircuit(vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_gas;\n\nvector<int> EXPECTED_cost;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* element #5 : null value -> no code */\ngas.push_back(gas_element5);\n/* element #6 : null value -> no code */\ngas.push_back(gas_element6);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* element #5 : null value -> no code */\ncost.push_back(cost_element5);\n/* element #6 : null value -> no code */\ncost.push_back(cost_element6);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_canCompleteCircuit_vector_int_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_canCompleteCircuit_vector_int_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\nint gas_element0=-27654560;\ngas.push_back(gas_element0);\nint gas_element1=-1084943690;\ngas.push_back(gas_element1);\n/* VectorDataNode cost */\nint cost_element0=2003601255;\ncost.push_back(cost_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canCompleteCircuit_vector_int_vector_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canCompleteCircuit(gas,cost);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Gas_Station.cpp\\\\Solution\\\\canCompleteCircuit(vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_gas;\n\nvector<int> EXPECTED_cost;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\nint gas_element0=-27654560;\ngas.push_back(gas_element0);\nint gas_element1=-1084943690;\ngas.push_back(gas_element1);\n/* VectorDataNode cost */\nint cost_element0=2003601255;\ncost.push_back(cost_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_canCompleteCircuit_vector_int_vector_int_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_canCompleteCircuit_vector_int_vector_int_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* element #5 : null value -> no code */\ngas.push_back(gas_element5);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* element #5 : null value -> no code */\ncost.push_back(cost_element5);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canCompleteCircuit_vector_int_vector_int_directed_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canCompleteCircuit(gas,cost);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Gas_Station.cpp\\\\Solution\\\\canCompleteCircuit(vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_gas;\n\nvector<int> EXPECTED_cost;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* element #5 : null value -> no code */\ngas.push_back(gas_element5);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* element #5 : null value -> no code */\ncost.push_back(cost_element5);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_canCompleteCircuit_vector_int_vector_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_canCompleteCircuit_vector_int_vector_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\nint gas_element0=423574810;\ngas.push_back(gas_element0);\nint gas_element1=132167875;\ngas.push_back(gas_element1);\n/* VectorDataNode cost */\nint cost_element0=-1348694278;\ncost.push_back(cost_element0);\nint cost_element1=-731681713;\ncost.push_back(cost_element1);\nint cost_element2=-955112037;\ncost.push_back(cost_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canCompleteCircuit_vector_int_vector_int_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canCompleteCircuit(gas,cost);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Gas_Station.cpp\\\\Solution\\\\canCompleteCircuit(vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_gas;\n\nvector<int> EXPECTED_cost;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\nint gas_element0=423574810;\ngas.push_back(gas_element0);\nint gas_element1=132167875;\ngas.push_back(gas_element1);\n/* VectorDataNode cost */\nint cost_element0=-1348694278;\ncost.push_back(cost_element0);\nint cost_element1=-731681713;\ncost.push_back(cost_element1);\nint cost_element2=-955112037;\ncost.push_back(cost_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_canCompleteCircuit_vector_int_vector_int_directed_5(void) {\n{\nAKA_test_case_name=\"Solution_canCompleteCircuit_vector_int_vector_int_directed_5\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* element #5 : null value -> no code */\ngas.push_back(gas_element5);\n/* element #6 : null value -> no code */\ngas.push_back(gas_element6);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* element #5 : null value -> no code */\ncost.push_back(cost_element5);\n/* element #6 : null value -> no code */\ncost.push_back(cost_element6);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canCompleteCircuit_vector_int_vector_int_directed_5\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canCompleteCircuit(gas,cost);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Gas_Station.cpp\\\\Solution\\\\canCompleteCircuit(vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_gas;\n\nvector<int> EXPECTED_cost;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* element #5 : null value -> no code */\ngas.push_back(gas_element5);\n/* element #6 : null value -> no code */\ngas.push_back(gas_element6);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* element #5 : null value -> no code */\ncost.push_back(cost_element5);\n/* element #6 : null value -> no code */\ncost.push_back(cost_element6);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_canCompleteCircuit_vector_int_vector_int_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_canCompleteCircuit_vector_int_vector_int_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* element #5 : null value -> no code */\ngas.push_back(gas_element5);\n/* element #6 : null value -> no code */\ngas.push_back(gas_element6);\n/* element #7 : null value -> no code */\ngas.push_back(gas_element7);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* element #5 : null value -> no code */\ncost.push_back(cost_element5);\n/* element #6 : null value -> no code */\ncost.push_back(cost_element6);\n/* element #7 : null value -> no code */\ncost.push_back(cost_element7);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canCompleteCircuit_vector_int_vector_int_directed_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canCompleteCircuit(gas,cost);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Gas_Station.cpp\\\\Solution\\\\canCompleteCircuit(vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_gas;\n\nvector<int> EXPECTED_cost;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* element #4 : null value -> no code */\ngas.push_back(gas_element4);\n/* element #5 : null value -> no code */\ngas.push_back(gas_element5);\n/* element #6 : null value -> no code */\ngas.push_back(gas_element6);\n/* element #7 : null value -> no code */\ngas.push_back(gas_element7);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* element #4 : null value -> no code */\ncost.push_back(cost_element4);\n/* element #5 : null value -> no code */\ncost.push_back(cost_element5);\n/* element #6 : null value -> no code */\ncost.push_back(cost_element6);\n/* element #7 : null value -> no code */\ncost.push_back(cost_element7);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_canCompleteCircuit_vector_int_vector_int_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_canCompleteCircuit_vector_int_vector_int_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canCompleteCircuit_vector_int_vector_int_directed_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canCompleteCircuit(gas,cost);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Gas_Station.cpp\\\\Solution\\\\canCompleteCircuit(vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_gas;\n\nvector<int> EXPECTED_cost;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_canCompleteCircuit_vector_int_vector_int_directed_6(void) {\n{\nAKA_test_case_name=\"Solution_canCompleteCircuit_vector_int_vector_int_directed_6\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canCompleteCircuit_vector_int_vector_int_directed_6\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canCompleteCircuit(gas,cost);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\four\\\\Gas_Station.cpp\\\\Solution\\\\canCompleteCircuit(vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_gas;\n\nvector<int> EXPECTED_cost;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Gas_Station.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> gas;\nvector<int> cost;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode gas */\n/* element #0 : null value -> no code */\ngas.push_back(gas_element0);\n/* element #1 : null value -> no code */\ngas.push_back(gas_element1);\n/* element #2 : null value -> no code */\ngas.push_back(gas_element2);\n/* element #3 : null value -> no code */\ngas.push_back(gas_element3);\n/* VectorDataNode cost */\n/* element #0 : null value -> no code */\ncost.push_back(cost_element0);\n/* element #1 : null value -> no code */\ncost.push_back(cost_element1);\n/* element #2 : null value -> no code */\ncost.push_back(cost_element2);\n/* element #3 : null value -> no code */\ncost.push_back(cost_element3);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint canCompleteCircuit(vector<int> &gas, vector<int> &cost) {\r \t\tvector<int> diff(gas.size());\r \t\tfor (int i = 0; i < gas.size(); ++i)\r \t\t{\r \t\t\tdiff[i] = gas[i] - cost[i];\r \t\t}\r \t\tint leftGas = 0, sum = 0, startnode = 0;\r \t\tfor (int i = 0; i < gas.size(); ++i)\r \t\t{\r \t\t\tleftGas += diff[i];\r \t\t\tsum += diff[i];\r \t\t\tif (sum < 0) //if less than 0, skip it\r \t\t\t{\r \t\t\t\tstartnode = i + 1;\r \t\t\t\tsum = 0;\r \t\t\t}\r \t\t}\r \t\tif (leftGas < 0)\r \t\t\treturn -1;\r \t\telse\r \t\t\treturn startnode;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\four\\Gas_Station.cpp\\Solution\\canCompleteCircuit(vector<int>&,vector<int>&)"
    }
]