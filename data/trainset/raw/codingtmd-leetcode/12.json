[
    {
        "f": [],
        "fm": "int maxProfit(vector<int>&prices) {\r \t\t// Start typing your C/C++ solution below\r \t\t// DO NOT write int main() function\r \t\tint minV = INT_MAX; int max = 0;\r \t\tint diff = 0;\r \t\tfor (int i = 0; i < prices.size(); i++)\r \t\t{\r \t\t\tif (prices[i] < minV) minV = prices[i];\r \t\t\tdiff = prices[i] - minV;\r \t\t\tif (max < diff)\r \t\t\t\tmax = diff;\r \t\t}\r \t\treturn max;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_10(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_10\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_10\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_6(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_6\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_6\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* element #10 : null value -> no code */\nprices.push_back(prices_element10);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* element #10 : null value -> no code */\nprices.push_back(prices_element10);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1898262886;\nprices.push_back(prices_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1898262886;\nprices.push_back(prices_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-734120016;\nprices.push_back(prices_element0);\nint prices_element1=61828759;\nprices.push_back(prices_element1);\nint prices_element2=-1068824936;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-734120016;\nprices.push_back(prices_element0);\nint prices_element1=61828759;\nprices.push_back(prices_element1);\nint prices_element2=-1068824936;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_13(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_13\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_13\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_8(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_8\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_8\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 9,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1366946116;\nprices.push_back(prices_element0);\nint prices_element1=-1585703564;\nprices.push_back(prices_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1366946116;\nprices.push_back(prices_element0);\nint prices_element1=-1585703564;\nprices.push_back(prices_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint maxProfit(vector<int>&prices) {\r \t\t// Start typing your C/C++ solution below\r \t\t// DO NOT write int main() function\r \t\tint minV = INT_MAX; int max = 0;\r \t\tint diff = 0;\r \t\tfor (int i = 0; i < prices.size(); i++)\r \t\t{\r \t\t\tif (prices[i] < minV) minV = prices[i];\r \t\t\tdiff = prices[i] - minV;\r \t\t\tif (max < diff)\r \t\t\t\tmax = diff;\r \t\t}\r \t\treturn max;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Best_Time_to_Buy_and_Sell_Stock.cpp\\Solution\\maxProfit(vector<int>&)"
    },
    {
        "f": [],
        "fm": "int maxProfit(vector<int>&prices) {\r \t\tint max = 0;\r \t\tint sum = 0;\r \t\tfor (int i = 1; i < prices.size(); i++)\r \t\t{\r \t\t\tint diff = prices[i] - prices[i - 1];\r \t\t\tif (diff > 0)\r \t\t\t\tsum += diff;\r \t\t}\r \t\treturn sum;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_5(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_5\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* element #10 : null value -> no code */\nprices.push_back(prices_element10);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_5\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* element #10 : null value -> no code */\nprices.push_back(prices_element10);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_7(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_7\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_7\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_9(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_9\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_9\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_14(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_14\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_14\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_11(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_11\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_11\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1366946116;\nprices.push_back(prices_element0);\nint prices_element1=-1585703564;\nprices.push_back(prices_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1366946116;\nprices.push_back(prices_element0);\nint prices_element1=-1585703564;\nprices.push_back(prices_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_12(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_12\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_12\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint maxProfit(vector<int>&prices) {\r \t\tint max = 0;\r \t\tint sum = 0;\r \t\tfor (int i = 1; i < prices.size(); i++)\r \t\t{\r \t\t\tint diff = prices[i] - prices[i - 1];\r \t\t\tif (diff > 0)\r \t\t\t\tsum += diff;\r \t\t}\r \t\treturn sum;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Best_Time_to_Buy_and_Sell_Stock_II.cpp\\Solution\\maxProfit(vector<int>&)"
    },
    {
        "f": [],
        "fm": "int maxProfit(vector<int> &prices) {\r     if (prices.size() <= 1) return 0;\r     vector<int> maxFromLeft(prices.size(), 0);\r     vector<int> maxFromRight(prices.size(), 0);\r     int minV = INT_MAX, maxP = INT_MIN;\r     for (int i = 0; i < prices.size(); i++)\r     {\r       if (minV > prices[i]) minV = prices[i];\r       int temp = prices[i] - minV;\r       if (temp > maxP) maxP = temp;\r       maxFromLeft[i] = maxP;\r     }\r \r     int maxV = INT_MIN;\r     maxP = INT_MIN;\r     for (int i = prices.size() - 1; i >= 0; i--)\r     {\r       if (maxV < prices[i]) maxV = prices[i];\r       int temp = maxV - prices[i];\r       if (temp > maxP) maxP = temp;\r       maxFromRight[i] = maxP;\r     }\r \r     int maxProfit = INT_MIN;\r     for (int i = 0; i < prices.size() - 1; i++)\r     {\r       int sum = maxFromLeft[i] + maxFromRight[i + 1];\r       if (sum > maxProfit) maxProfit = sum;\r     }\r     if (maxProfit < maxFromRight[0])\r       maxProfit = maxFromRight[0];\r     return maxProfit;\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_20(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_20\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_20\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_21(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_21\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_21\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_19(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_19\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_19\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1898262886;\nprices.push_back(prices_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1898262886;\nprices.push_back(prices_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_17(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_17\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_17\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* element #9 : null value -> no code */\nprices.push_back(prices_element9);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-734120016;\nprices.push_back(prices_element0);\nint prices_element1=61828759;\nprices.push_back(prices_element1);\nint prices_element2=-1068824936;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-734120016;\nprices.push_back(prices_element0);\nint prices_element1=61828759;\nprices.push_back(prices_element1);\nint prices_element2=-1068824936;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_18(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_18\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_18\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_15(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_15\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_15\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_16(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_16\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_16\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 9,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_22(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_22\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_22\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* element #6 : null value -> no code */\nprices.push_back(prices_element6);\n/* element #7 : null value -> no code */\nprices.push_back(prices_element7);\n/* element #8 : null value -> no code */\nprices.push_back(prices_element8);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 10,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_23(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_23\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_23\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* element #1 : null value -> no code */\nprices.push_back(prices_element1);\n/* element #2 : null value -> no code */\nprices.push_back(prices_element2);\n/* element #3 : null value -> no code */\nprices.push_back(prices_element3);\n/* element #4 : null value -> no code */\nprices.push_back(prices_element4);\n/* element #5 : null value -> no code */\nprices.push_back(prices_element5);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   int maxProfit(vector<int> &prices) {\r     if (prices.size() <= 1) return 0;\r     vector<int> maxFromLeft(prices.size(), 0);\r     vector<int> maxFromRight(prices.size(), 0);\r     int minV = INT_MAX, maxP = INT_MIN;\r     for (int i = 0; i < prices.size(); i++)\r     {\r       if (minV > prices[i]) minV = prices[i];\r       int temp = prices[i] - minV;\r       if (temp > maxP) maxP = temp;\r       maxFromLeft[i] = maxP;\r     }\r \r     int maxV = INT_MIN;\r     maxP = INT_MIN;\r     for (int i = prices.size() - 1; i >= 0; i--)\r     {\r       if (maxV < prices[i]) maxV = prices[i];\r       int temp = maxV - prices[i];\r       if (temp > maxP) maxP = temp;\r       maxFromRight[i] = maxP;\r     }\r \r     int maxProfit = INT_MIN;\r     for (int i = 0; i < prices.size() - 1; i++)\r     {\r       int sum = maxFromLeft[i] + maxFromRight[i + 1];\r       if (sum > maxProfit) maxProfit = sum;\r     }\r     if (maxProfit < maxFromRight[0])\r       maxProfit = maxFromRight[0];\r     return maxProfit;\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Best_Time_to_Buy_and_Sell_Stock_III.cpp\\Solution\\maxProfit(vector<int>&)"
    },
    {
        "f": [],
        "fm": "vector<string> binaryTreePaths(TreeNode* root) {\r         vector<string> paths;\r         vector<int> nodes;\r         getAllPaths(root, nodes, paths);          \r         return paths;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_binaryTreePaths_TreeNodemul_random_1(void) {\n{\nAKA_test_case_name=\"Solution_binaryTreePaths_TreeNodemul_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* root;\nvector<string> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_binaryTreePaths_TreeNodemul_random_1\");vector<string> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->binaryTreePaths(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\binaryTreePaths(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* root;\nvector<string> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_binaryTreePaths_TreeNodemul_random_2(void) {\n{\nAKA_test_case_name=\"Solution_binaryTreePaths_TreeNodemul_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-1100558536;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\binaryTreePaths(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=94486351;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\binaryTreePaths(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<string> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_binaryTreePaths_TreeNodemul_random_2\");vector<string> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->binaryTreePaths(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\binaryTreePaths(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-1100558536;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\binaryTreePaths(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=94486351;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\binaryTreePaths(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<string> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     vector<string> binaryTreePaths(TreeNode* root) {\r         vector<string> paths;\r         vector<int> nodes;\r         getAllPaths(root, nodes, paths);          \r         return paths;\r     }\r     \r     void getAllPaths(TreeNode* node, vector<int>& nodes,vector<string>& paths) {\r         if(node == NULL) {\r             return;\r         }\r         if(node->left== NULL && node->right == NULL) {\r             stringstream ss;\r             for(int i =0; i< nodes.size(); i++) {\r                 ss << nodes[i] << \"->\";\r             }\r             ss << node->val;\r             paths.push_back(ss.str());\r             return;\r         }\r         \r         nodes.push_back(node->val);\r         getAllPaths(node->left, nodes, paths);\r         getAllPaths(node->right, nodes, paths);\r         nodes.pop_back();\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Binary Tree Paths.cpp\\Solution\\binaryTreePaths(TreeNode*)"
    },
    {
        "f": [],
        "fm": "void getAllPaths(TreeNode* node, vector<int>& nodes,vector<string>& paths) {\r         if(node == NULL) {\r             return;\r         }\r         if(node->left== NULL && node->right == NULL) {\r             stringstream ss;\r             for(int i =0; i< nodes.size(); i++) {\r                 ss << nodes[i] << \"->\";\r             }\r             ss << node->val;\r             paths.push_back(ss.str());\r             return;\r         }\r         \r         nodes.push_back(node->val);\r         getAllPaths(node->left, nodes, paths);\r         getAllPaths(node->right, nodes, paths);\r         nodes.pop_back();\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_random_2(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=1126506629;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::TreeNode(node0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0).val=1077422641;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0).left;\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_0_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_right0_x=-2076841208;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_right_0 = new ::TreeNode(node0_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).val=972234517;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).right;\nAKA_VECTOR_INIT_node_0_DOT_right.push_back(AKA_VECTOR_INIT_node_0_DOT_right_0);\n(*AKA_VECTOR_INIT_node_0).right = AKA_VECTOR_INIT_node_0_DOT_right[0];\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nTreeNode* node = AKA_VECTOR_INIT_node[0];\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\nint nodes_element0=506300680;\nnodes.push_back(nodes_element0);\nint nodes_element1=-1710398563;\nnodes.push_back(nodes_element1);\n/* VectorDataNode paths */\nchar* akaRandomName320849 = new char[2];akaRandomName320849[0] = -81;akaRandomName320849[1] = '\\0';string paths_element0=akaRandomName320849;\npaths.push_back(paths_element0);\nchar* akaRandomName44542 = new char[2];akaRandomName44542[0] = 40;akaRandomName44542[1] = '\\0';string paths_element1=akaRandomName44542;\npaths.push_back(paths_element1);\nchar* akaRandomName543284 = new char[2];akaRandomName543284[0] = -121;akaRandomName543284[1] = '\\0';string paths_element2=akaRandomName543284;\npaths.push_back(paths_element2);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_random_2\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=1126506629;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::TreeNode(node0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0).val=1077422641;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0).left;\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_0_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_right0_x=-2076841208;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_right_0 = new ::TreeNode(node0_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).val=972234517;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).right;\nAKA_VECTOR_INIT_node_0_DOT_right.push_back(AKA_VECTOR_INIT_node_0_DOT_right_0);\n(*AKA_VECTOR_INIT_node_0).right = AKA_VECTOR_INIT_node_0_DOT_right[0];\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nTreeNode* node = AKA_VECTOR_INIT_node[0];\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\nint nodes_element0=506300680;\nnodes.push_back(nodes_element0);\nint nodes_element1=-1710398563;\nnodes.push_back(nodes_element1);\n/* VectorDataNode paths */\nchar* akaRandomName80176 = new char[2];akaRandomName80176[0] = -81;akaRandomName80176[1] = '\\0';string paths_element0=akaRandomName80176;\npaths.push_back(paths_element0);\nchar* akaRandomName672007 = new char[2];akaRandomName672007[0] = 40;akaRandomName672007[1] = '\\0';string paths_element1=akaRandomName672007;\npaths.push_back(paths_element1);\nchar* akaRandomName95725 = new char[2];akaRandomName95725[0] = -121;akaRandomName95725[1] = '\\0';string paths_element2=akaRandomName95725;\npaths.push_back(paths_element2);\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\nint nodes_element0=1868011728;\nnodes.push_back(nodes_element0);\n/* VectorDataNode paths */\nchar* akaRandomName228583 = new char[2];akaRandomName228583[0] = 101;akaRandomName228583[1] = '\\0';string paths_element0=akaRandomName228583;\npaths.push_back(paths_element0);\nchar* akaRandomName995456 = new char[2];akaRandomName995456[0] = -19;akaRandomName995456[1] = '\\0';string paths_element1=akaRandomName995456;\npaths.push_back(paths_element1);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_random_0\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\nint nodes_element0=1868011728;\nnodes.push_back(nodes_element0);\n/* VectorDataNode paths */\nchar* akaRandomName257906 = new char[2];akaRandomName257906[0] = 101;akaRandomName257906[1] = '\\0';string paths_element0=akaRandomName257906;\npaths.push_back(paths_element0);\nchar* akaRandomName833814 = new char[2];akaRandomName833814[0] = -19;akaRandomName833814[1] = '\\0';string paths_element1=akaRandomName833814;\npaths.push_back(paths_element1);\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_1\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::TreeNode(node0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0).left = nullptr;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0).right = nullptr;\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nTreeNode* node = AKA_VECTOR_INIT_node[0];\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_0\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary Tree Paths.cpp\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::TreeNode(node0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0).left = nullptr;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0).right = nullptr;\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nTreeNode* node = AKA_VECTOR_INIT_node[0];\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_3\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_2\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_5(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_5\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_5\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_4\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_7(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_7\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_7\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 9,
                "dt": {},
                "td": "void AKA_TEST_Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_6(void) {\n{\nAKA_test_case_name=\"Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_6\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getAllPaths_TreeNodemul_vector_int_vector_string_directed_6\");AKA_INSTANCE___Solution->getAllPaths(node,nodes,paths);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary Tree Paths.cpp\\\\Solution\\\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)\");\n\n/* error assertion */\nvector<int> EXPECTED_nodes;\n\nvector<string> EXPECTED_paths;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary Tree Paths.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* node;\nvector<int> nodes;\nvector<string> paths;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* VectorDataNode nodes */\n/* VectorDataNode paths */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     vector<string> binaryTreePaths(TreeNode* root) {\r         vector<string> paths;\r         vector<int> nodes;\r         getAllPaths(root, nodes, paths);          \r         return paths;\r     }\r     \r     void getAllPaths(TreeNode* node, vector<int>& nodes,vector<string>& paths) {\r         if(node == NULL) {\r             return;\r         }\r         if(node->left== NULL && node->right == NULL) {\r             stringstream ss;\r             for(int i =0; i< nodes.size(); i++) {\r                 ss << nodes[i] << \"->\";\r             }\r             ss << node->val;\r             paths.push_back(ss.str());\r             return;\r         }\r         \r         nodes.push_back(node->val);\r         getAllPaths(node->left, nodes, paths);\r         getAllPaths(node->right, nodes, paths);\r         nodes.pop_back();\r     }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Binary Tree Paths.cpp\\Solution\\getAllPaths(TreeNode*,vector<int>&,vector<string>&)"
    },
    {
        "f": [],
        "fm": "vector<int> inorderTraversal(TreeNode *root) {\r \t\tvector<TreeNode*> sta;\r \t\tvector<int> result;\r \t\tif (root == NULL) return result;\r \t\tTreeNode* node = root;\r \t\twhile (sta.size() > 0 || node != NULL)\r \t\t{\r \t\t\twhile (node != NULL)\r \t\t\t{\r \t\t\t\tsta.push_back(node);\r \t\t\t\tnode = node->left;\r \t\t\t}\r \t\t\tnode = sta.back();\r \t\t\tsta.pop_back();\r \t\t\tresult.push_back(node->val);\r \t\t\tnode = node->right;\r \t\t}\r \t\treturn result;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_inorderTraversal_TreeNodemul_random_2(void) {\n{\nAKA_test_case_name=\"Solution_inorderTraversal_TreeNodemul_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=709798911;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=-24081069;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_inorderTraversal_TreeNodemul_random_2\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->inorderTraversal(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Inorder_Traversal.cpp\\\\Solution\\\\inorderTraversal(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=709798911;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=-24081069;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_inorderTraversal_TreeNodemul_random_3(void) {\n{\nAKA_test_case_name=\"Solution_inorderTraversal_TreeNodemul_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* root;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_inorderTraversal_TreeNodemul_random_3\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->inorderTraversal(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Inorder_Traversal.cpp\\\\Solution\\\\inorderTraversal(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* root;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_inorderTraversal_TreeNodemul_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_inorderTraversal_TreeNodemul_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_inorderTraversal_TreeNodemul_directed_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->inorderTraversal(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Inorder_Traversal.cpp\\\\Solution\\\\inorderTraversal(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Inorder_Traversal.cpp\\\\inorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tvector<int> inorderTraversal(TreeNode *root) {\r \t\tvector<TreeNode*> sta;\r \t\tvector<int> result;\r \t\tif (root == NULL) return result;\r \t\tTreeNode* node = root;\r \t\twhile (sta.size() > 0 || node != NULL)\r \t\t{\r \t\t\twhile (node != NULL)\r \t\t\t{\r \t\t\t\tsta.push_back(node);\r \t\t\t\tnode = node->left;\r \t\t\t}\r \t\t\tnode = sta.back();\r \t\t\tsta.pop_back();\r \t\t\tresult.push_back(node->val);\r \t\t\tnode = node->right;\r \t\t}\r \t\treturn result;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Binary_Tree_Inorder_Traversal.cpp\\Solution\\inorderTraversal(TreeNode*)"
    },
    {
        "f": [],
        "fm": "vector<vector<int> > levelOrder(TreeNode *root) {\r \t\tvector<vector<int> > result;\r \t\tif (root == NULL) return result;\r \t\tqueue<TreeNode*> nodeQ;\r \t\tnodeQ.push(root);\r \t\tint nextLevelCnt = 0, currentLevelCnt = 1;\r \t\tvector<int> layer;\r \t\tint visitedCnt = 0;\r \t\twhile (nodeQ.size() != 0)\r \t\t{\r \t\t\tTreeNode* node = nodeQ.front();\r \t\t\tnodeQ.pop();\r \t\t\tvisitedCnt++;\r \t\t\tlayer.push_back(node->val);\r \t\t\tif (node->left != NULL)\r \t\t\t{\r \t\t\t\tnodeQ.push(node->left);\r \t\t\t\tnextLevelCnt++;\r \t\t\t}\r \t\t\tif (node->right != NULL)\r \t\t\t{\r \t\t\t\tnodeQ.push(node->right);\r \t\t\t\tnextLevelCnt++;\r \t\t\t}\r \t\t\tif (visitedCnt == currentLevelCnt)\r \t\t\t{\r \t\t\t\tvisitedCnt = 0;\r \t\t\t\tcurrentLevelCnt = nextLevelCnt;\r \t\t\t\tnextLevelCnt = 0;\r \t\t\t\tresult.push_back(layer);\r \t\t\t\tlayer.clear();\r \t\t\t}\r \t\t}\r \t\treturn result;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_levelOrder_TreeNodemul_random_0(void) {\n{\nAKA_test_case_name=\"Solution_levelOrder_TreeNodemul_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* root;\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_levelOrder_TreeNodemul_random_0\");vector<vector<int>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->levelOrder(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\Solution\\\\levelOrder(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nTreeNode* root;\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_levelOrder_TreeNodemul_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_levelOrder_TreeNodemul_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_levelOrder_TreeNodemul_directed_0\");vector<vector<int>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->levelOrder(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\Solution\\\\levelOrder(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_levelOrder_TreeNodemul_random_3(void) {\n{\nAKA_test_case_name=\"Solution_levelOrder_TreeNodemul_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-634516461;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=-2040055169;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_levelOrder_TreeNodemul_random_3\");vector<vector<int>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->levelOrder(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\Solution\\\\levelOrder(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-634516461;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=-2040055169;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_levelOrder_TreeNodemul_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_levelOrder_TreeNodemul_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_levelOrder_TreeNodemul_directed_1\");vector<vector<int>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->levelOrder(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\Solution\\\\levelOrder(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_levelOrder_TreeNodemul_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_levelOrder_TreeNodemul_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_levelOrder_TreeNodemul_directed_2\");vector<vector<int>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->levelOrder(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\Solution\\\\levelOrder(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Level_Order_Traversal.cpp\\\\levelOrder(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tvector<vector<int> > levelOrder(TreeNode *root) {\r \t\tvector<vector<int> > result;\r \t\tif (root == NULL) return result;\r \t\tqueue<TreeNode*> nodeQ;\r \t\tnodeQ.push(root);\r \t\tint nextLevelCnt = 0, currentLevelCnt = 1;\r \t\tvector<int> layer;\r \t\tint visitedCnt = 0;\r \t\twhile (nodeQ.size() != 0)\r \t\t{\r \t\t\tTreeNode* node = nodeQ.front();\r \t\t\tnodeQ.pop();\r \t\t\tvisitedCnt++;\r \t\t\tlayer.push_back(node->val);\r \t\t\tif (node->left != NULL)\r \t\t\t{\r \t\t\t\tnodeQ.push(node->left);\r \t\t\t\tnextLevelCnt++;\r \t\t\t}\r \t\t\tif (node->right != NULL)\r \t\t\t{\r \t\t\t\tnodeQ.push(node->right);\r \t\t\t\tnextLevelCnt++;\r \t\t\t}\r \t\t\tif (visitedCnt == currentLevelCnt)\r \t\t\t{\r \t\t\t\tvisitedCnt = 0;\r \t\t\t\tcurrentLevelCnt = nextLevelCnt;\r \t\t\t\tnextLevelCnt = 0;\r \t\t\t\tresult.push_back(layer);\r \t\t\t\tlayer.clear();\r \t\t\t}\r \t\t}\r \t\treturn result;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Binary_Tree_Level_Order_Traversal.cpp\\Solution\\levelOrder(TreeNode*)"
    },
    {
        "f": [],
        "fm": "int maxPathSum(TreeNode *root) {\r \t\tint maxAcrossRoot = INT_MIN;\r \t\tint maxEndByRoot = GetMax(root, maxAcrossRoot);\r \t\treturn std::max(maxAcrossRoot, maxEndByRoot);\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxPathSum_TreeNodemul_random_1(void) {\n{\nAKA_test_case_name=\"Solution_maxPathSum_TreeNodemul_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=1668218687;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\maxPathSum(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxPathSum_TreeNodemul_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxPathSum(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\Solution\\\\maxPathSum(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=1668218687;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\maxPathSum(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint maxPathSum(TreeNode *root) {\r \t\tint maxAcrossRoot = INT_MIN;\r \t\tint maxEndByRoot = GetMax(root, maxAcrossRoot);\r \t\treturn std::max(maxAcrossRoot, maxEndByRoot);\r \t}\r \tint GetMax(TreeNode *node, int& maxAcrossRoot)\r \t{\r \t\tif (node == NULL) return 0;\r \t\tint left = GetMax(node->left, maxAcrossRoot);\r \t\tint right = GetMax(node->right, maxAcrossRoot);\r \t\tint cMax = node->val;\r \t\tif (left > 0)\r \t\t\tcMax += left;\r \t\tif (right > 0)\r \t\t\tcMax += right;\r \t\tmaxAcrossRoot = std::max(maxAcrossRoot, cMax);\r \t\treturn std::max(\r \t\t    node->val,\r \t\t    std::max(node->val + left, node->val + right));\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Binary_Tree_Maximum_Path_Sum.cpp\\Solution\\maxPathSum(TreeNode*)"
    },
    {
        "f": [],
        "fm": "int GetMax(TreeNode *node, int& maxAcrossRoot)\r \t{\r \t\tif (node == NULL) return 0;\r \t\tint left = GetMax(node->left, maxAcrossRoot);\r \t\tint right = GetMax(node->right, maxAcrossRoot);\r \t\tint cMax = node->val;\r \t\tif (left > 0)\r \t\t\tcMax += left;\r \t\tif (right > 0)\r \t\t\tcMax += right;\r \t\tmaxAcrossRoot = std::max(maxAcrossRoot, cMax);\r \t\treturn std::max(\r \t\t    node->val,\r \t\t    std::max(node->val + left, node->val + right));\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_GetMax_TreeNodemul_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_GetMax_TreeNodemul_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=1812203977;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::TreeNode(node0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0).val=-1107173340;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_left0_x=-105121716;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_left_0 = new ::TreeNode(node0_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_left_0).val=1514010510;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_left_0).right;\nAKA_VECTOR_INIT_node_0_DOT_left.push_back(AKA_VECTOR_INIT_node_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_left1_x=1767938862;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_left_1 = new ::TreeNode(node0_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_left_1).val=440192465;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_left_1).right;\nAKA_VECTOR_INIT_node_0_DOT_left.push_back(AKA_VECTOR_INIT_node_0_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_left2_x=1865353523;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_left_2 = new ::TreeNode(node0_left2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_left_2).val=-1640347386;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_left_2).right;\nAKA_VECTOR_INIT_node_0_DOT_left.push_back(AKA_VECTOR_INIT_node_0_DOT_left_2);\n(*AKA_VECTOR_INIT_node_0).left = AKA_VECTOR_INIT_node_0_DOT_left[0];\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_0_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_right0_x=-34653239;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_right_0 = new ::TreeNode(node0_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).val=1028693992;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).right;\nAKA_VECTOR_INIT_node_0_DOT_right.push_back(AKA_VECTOR_INIT_node_0_DOT_right_0);\n(*AKA_VECTOR_INIT_node_0).right = AKA_VECTOR_INIT_node_0_DOT_right[0];\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node1_x=-340408835;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1 = new ::TreeNode(node1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_1).val=1986430572;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_1_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node1_left0_x=1675693829;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1_DOT_left_0 = new ::TreeNode(node1_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_1_DOT_left_0).val=-136682922;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_1_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_1_DOT_left_0).right;\nAKA_VECTOR_INIT_node_1_DOT_left.push_back(AKA_VECTOR_INIT_node_1_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node1_left1_x=237603637;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1_DOT_left_1 = new ::TreeNode(node1_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_1_DOT_left_1).val=-975094955;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_1_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_1_DOT_left_1).right;\nAKA_VECTOR_INIT_node_1_DOT_left.push_back(AKA_VECTOR_INIT_node_1_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node1_left2_x=1792592139;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1_DOT_left_2 = new ::TreeNode(node1_left2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_1_DOT_left_2).val=-1246513010;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_1_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_1_DOT_left_2).right;\nAKA_VECTOR_INIT_node_1_DOT_left.push_back(AKA_VECTOR_INIT_node_1_DOT_left_2);\n(*AKA_VECTOR_INIT_node_1).left = AKA_VECTOR_INIT_node_1_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_1).right;\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_1);\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_x=1015347844;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2 = new ::TreeNode(node2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2).val=136130624;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_2_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_left0_x=-30647657;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_left_0 = new ::TreeNode(node2_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_left_0).val=-1825652640;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_left_0).right;\nAKA_VECTOR_INIT_node_2_DOT_left.push_back(AKA_VECTOR_INIT_node_2_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_left1_x=-675078506;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_left_1 = new ::TreeNode(node2_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_left_1).val=-299258660;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_left_1).right;\nAKA_VECTOR_INIT_node_2_DOT_left.push_back(AKA_VECTOR_INIT_node_2_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_left2_x=-858554885;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_left_2 = new ::TreeNode(node2_left2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_left_2).val=-820981373;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_left_2).right;\nAKA_VECTOR_INIT_node_2_DOT_left.push_back(AKA_VECTOR_INIT_node_2_DOT_left_2);\n(*AKA_VECTOR_INIT_node_2).left = AKA_VECTOR_INIT_node_2_DOT_left[0];\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_2_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_right0_x=-931940225;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_right_0 = new ::TreeNode(node2_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_right_0).val=1859940808;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_right_0).right;\nAKA_VECTOR_INIT_node_2_DOT_right.push_back(AKA_VECTOR_INIT_node_2_DOT_right_0);\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_right1_x=-1008212229;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\right\\\\right[1]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_right_1 = new ::TreeNode(node2_right1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_right_1).val=-664605078;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_right_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_right_1).right;\nAKA_VECTOR_INIT_node_2_DOT_right.push_back(AKA_VECTOR_INIT_node_2_DOT_right_1);\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_right2_x=327341830;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\right\\\\right[2]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_right_2 = new ::TreeNode(node2_right2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_right_2).val=1813226601;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_right_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_right_2).right;\nAKA_VECTOR_INIT_node_2_DOT_right.push_back(AKA_VECTOR_INIT_node_2_DOT_right_2);\n(*AKA_VECTOR_INIT_node_2).right = AKA_VECTOR_INIT_node_2_DOT_right[0];\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_2);\n\nTreeNode* node = AKA_VECTOR_INIT_node[0];\n\n\nint maxAcrossRoot=1616695493;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* NormalNumberDataNode maxAcrossRoot */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_GetMax_TreeNodemul_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->GetMax(node,maxAcrossRoot);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\Solution\\\\GetMax(TreeNode*,int&)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=1812203977;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::TreeNode(node0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0).val=-1107173340;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_left0_x=-105121716;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_left_0 = new ::TreeNode(node0_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_left_0).val=1514010510;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_left_0).right;\nAKA_VECTOR_INIT_node_0_DOT_left.push_back(AKA_VECTOR_INIT_node_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_left1_x=1767938862;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_left_1 = new ::TreeNode(node0_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_left_1).val=440192465;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_left_1).right;\nAKA_VECTOR_INIT_node_0_DOT_left.push_back(AKA_VECTOR_INIT_node_0_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_left2_x=1865353523;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_left_2 = new ::TreeNode(node0_left2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_left_2).val=-1640347386;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_left_2).right;\nAKA_VECTOR_INIT_node_0_DOT_left.push_back(AKA_VECTOR_INIT_node_0_DOT_left_2);\n(*AKA_VECTOR_INIT_node_0).left = AKA_VECTOR_INIT_node_0_DOT_left[0];\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_0_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node0_right0_x=-34653239;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0_DOT_right_0 = new ::TreeNode(node0_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).val=1028693992;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_0_DOT_right_0).right;\nAKA_VECTOR_INIT_node_0_DOT_right.push_back(AKA_VECTOR_INIT_node_0_DOT_right_0);\n(*AKA_VECTOR_INIT_node_0).right = AKA_VECTOR_INIT_node_0_DOT_right[0];\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node1_x=-340408835;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1 = new ::TreeNode(node1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_1).val=1986430572;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_1_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node1_left0_x=1675693829;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1_DOT_left_0 = new ::TreeNode(node1_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_1_DOT_left_0).val=-136682922;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_1_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_1_DOT_left_0).right;\nAKA_VECTOR_INIT_node_1_DOT_left.push_back(AKA_VECTOR_INIT_node_1_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node1_left1_x=237603637;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1_DOT_left_1 = new ::TreeNode(node1_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_1_DOT_left_1).val=-975094955;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_1_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_1_DOT_left_1).right;\nAKA_VECTOR_INIT_node_1_DOT_left.push_back(AKA_VECTOR_INIT_node_1_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node1_left2_x=1792592139;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_1\\\\node\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_1_DOT_left_2 = new ::TreeNode(node1_left2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_1_DOT_left_2).val=-1246513010;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_1_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_1_DOT_left_2).right;\nAKA_VECTOR_INIT_node_1_DOT_left.push_back(AKA_VECTOR_INIT_node_1_DOT_left_2);\n(*AKA_VECTOR_INIT_node_1).left = AKA_VECTOR_INIT_node_1_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_1).right;\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_1);\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_x=1015347844;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2 = new ::TreeNode(node2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2).val=136130624;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_2_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_left0_x=-30647657;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_left_0 = new ::TreeNode(node2_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_left_0).val=-1825652640;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_left_0).right;\nAKA_VECTOR_INIT_node_2_DOT_left.push_back(AKA_VECTOR_INIT_node_2_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_left1_x=-675078506;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_left_1 = new ::TreeNode(node2_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_left_1).val=-299258660;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_left_1).right;\nAKA_VECTOR_INIT_node_2_DOT_left.push_back(AKA_VECTOR_INIT_node_2_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_left2_x=-858554885;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_left_2 = new ::TreeNode(node2_left2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_left_2).val=-820981373;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_left_2).right;\nAKA_VECTOR_INIT_node_2_DOT_left.push_back(AKA_VECTOR_INIT_node_2_DOT_left_2);\n(*AKA_VECTOR_INIT_node_2).left = AKA_VECTOR_INIT_node_2_DOT_left[0];\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_node_2_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_right0_x=-931940225;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_right_0 = new ::TreeNode(node2_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_right_0).val=1859940808;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_right_0).right;\nAKA_VECTOR_INIT_node_2_DOT_right.push_back(AKA_VECTOR_INIT_node_2_DOT_right_0);\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_right1_x=-1008212229;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\right\\\\right[1]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_right_1 = new ::TreeNode(node2_right1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_right_1).val=-664605078;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_right_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_right_1).right;\nAKA_VECTOR_INIT_node_2_DOT_right.push_back(AKA_VECTOR_INIT_node_2_DOT_right_1);\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint node2_right2_x=327341830;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Maximum_Path_Sum.cpp\\\\GetMax(TreeNode*,int&)\\\\node\\\\AKA_VECTOR_INIT_node_2\\\\node\\\\right\\\\right[2]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_2_DOT_right_2 = new ::TreeNode(node2_right2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_node_2_DOT_right_2).val=1813226601;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_node_2_DOT_right_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_node_2_DOT_right_2).right;\nAKA_VECTOR_INIT_node_2_DOT_right.push_back(AKA_VECTOR_INIT_node_2_DOT_right_2);\n(*AKA_VECTOR_INIT_node_2).right = AKA_VECTOR_INIT_node_2_DOT_right[0];\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_2);\n\nTreeNode* node = AKA_VECTOR_INIT_node[0];\n\n\nint maxAcrossRoot=1616695493;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* NormalNumberDataNode maxAcrossRoot */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint maxPathSum(TreeNode *root) {\r \t\tint maxAcrossRoot = INT_MIN;\r \t\tint maxEndByRoot = GetMax(root, maxAcrossRoot);\r \t\treturn std::max(maxAcrossRoot, maxEndByRoot);\r \t}\r \tint GetMax(TreeNode *node, int& maxAcrossRoot)\r \t{\r \t\tif (node == NULL) return 0;\r \t\tint left = GetMax(node->left, maxAcrossRoot);\r \t\tint right = GetMax(node->right, maxAcrossRoot);\r \t\tint cMax = node->val;\r \t\tif (left > 0)\r \t\t\tcMax += left;\r \t\tif (right > 0)\r \t\t\tcMax += right;\r \t\tmaxAcrossRoot = std::max(maxAcrossRoot, cMax);\r \t\treturn std::max(\r \t\t    node->val,\r \t\t    std::max(node->val + left, node->val + right));\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Binary_Tree_Maximum_Path_Sum.cpp\\Solution\\GetMax(TreeNode*,int&)"
    },
    {
        "f": [],
        "fm": "vector<int> preorderTraversal(TreeNode *root) {\r \t\tstack<TreeNode*> tStack;\r \t\tvector<int> result;\r \t\twhile (tStack.size() > 0 || root != NULL)\r \t\t{\r \t\t\tif (root != NULL)\r \t\t\t{\r \t\t\t\tresult.push_back(root->val);\r \t\t\t\tif (root->right != NULL)\r \t\t\t\t\ttStack.push(root->right);\r \t\t\t\troot = root->left;\r \t\t\t}\r \t\t\telse\r \t\t\t{\r \t\t\t\troot = tStack.top();\r \t\t\t\ttStack.pop();\r \t\t\t}\r \t\t}\r \t\treturn result;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_preorderTraversal_TreeNodemul_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_preorderTraversal_TreeNodemul_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_preorderTraversal_TreeNodemul_directed_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->preorderTraversal(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Preorder_Traversal.cpp\\\\Solution\\\\preorderTraversal(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_preorderTraversal_TreeNodemul_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_preorderTraversal_TreeNodemul_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\nTreeNode* root = nullptr;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_preorderTraversal_TreeNodemul_directed_1\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->preorderTraversal(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Preorder_Traversal.cpp\\\\Solution\\\\preorderTraversal(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\nTreeNode* root = nullptr;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_preorderTraversal_TreeNodemul_random_1(void) {\n{\nAKA_test_case_name=\"Solution_preorderTraversal_TreeNodemul_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-1923048792;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_0).val=-1201880425;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-1032105707;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).val=190616009;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=84323846;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).val=1041718304;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=293145031;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1).val=-282906217;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_1_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_left0_x=-877632430;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1_DOT_left_0 = new ::TreeNode(root1_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1_DOT_left_0).val=-2008876074;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1_DOT_left_0).right;\nAKA_VECTOR_INIT_root_1_DOT_left.push_back(AKA_VECTOR_INIT_root_1_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_left1_x=-1438331557;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1_DOT_left_1 = new ::TreeNode(root1_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1_DOT_left_1).val=1356830530;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1_DOT_left_1).right;\nAKA_VECTOR_INIT_root_1_DOT_left.push_back(AKA_VECTOR_INIT_root_1_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_left2_x=536907850;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1_DOT_left_2 = new ::TreeNode(root1_left2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1_DOT_left_2).val=33386643;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1_DOT_left_2).right;\nAKA_VECTOR_INIT_root_1_DOT_left.push_back(AKA_VECTOR_INIT_root_1_DOT_left_2);\n(*AKA_VECTOR_INIT_root_1).left = AKA_VECTOR_INIT_root_1_DOT_left[0];\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_1_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_right0_x=877128937;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1_DOT_right_0 = new ::TreeNode(root1_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1_DOT_right_0).val=1124107638;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1_DOT_right_0).right;\nAKA_VECTOR_INIT_root_1_DOT_right.push_back(AKA_VECTOR_INIT_root_1_DOT_right_0);\n(*AKA_VECTOR_INIT_root_1).right = AKA_VECTOR_INIT_root_1_DOT_right[0];\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=1186625965;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2).val=1247733960;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_2_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_left0_x=1960422670;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2_DOT_left_0 = new ::TreeNode(root2_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2_DOT_left_0).val=-1649230767;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2_DOT_left_0).right;\nAKA_VECTOR_INIT_root_2_DOT_left.push_back(AKA_VECTOR_INIT_root_2_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_left1_x=-110883369;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2_DOT_left_1 = new ::TreeNode(root2_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2_DOT_left_1).val=1141165230;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2_DOT_left_1).right;\nAKA_VECTOR_INIT_root_2_DOT_left.push_back(AKA_VECTOR_INIT_root_2_DOT_left_1);\n(*AKA_VECTOR_INIT_root_2).left = AKA_VECTOR_INIT_root_2_DOT_left[0];\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_2_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_right0_x=-446047342;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2_DOT_right_0 = new ::TreeNode(root2_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2_DOT_right_0).val=-549023635;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2_DOT_right_0).right;\nAKA_VECTOR_INIT_root_2_DOT_right.push_back(AKA_VECTOR_INIT_root_2_DOT_right_0);\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_right1_x=2003069070;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\right\\\\right[1]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2_DOT_right_1 = new ::TreeNode(root2_right1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2_DOT_right_1).val=1610373260;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2_DOT_right_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2_DOT_right_1).right;\nAKA_VECTOR_INIT_root_2_DOT_right.push_back(AKA_VECTOR_INIT_root_2_DOT_right_1);\n(*AKA_VECTOR_INIT_root_2).right = AKA_VECTOR_INIT_root_2_DOT_right[0];\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_preorderTraversal_TreeNodemul_random_1\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->preorderTraversal(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Binary_Tree_Preorder_Traversal.cpp\\\\Solution\\\\preorderTraversal(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-1923048792;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_0).val=-1201880425;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-1032105707;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).val=190616009;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=84323846;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).val=1041718304;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_x=293145031;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1).val=-282906217;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_1_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_left0_x=-877632430;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1_DOT_left_0 = new ::TreeNode(root1_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1_DOT_left_0).val=-2008876074;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1_DOT_left_0).right;\nAKA_VECTOR_INIT_root_1_DOT_left.push_back(AKA_VECTOR_INIT_root_1_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_left1_x=-1438331557;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1_DOT_left_1 = new ::TreeNode(root1_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1_DOT_left_1).val=1356830530;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1_DOT_left_1).right;\nAKA_VECTOR_INIT_root_1_DOT_left.push_back(AKA_VECTOR_INIT_root_1_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_left2_x=536907850;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1_DOT_left_2 = new ::TreeNode(root1_left2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1_DOT_left_2).val=33386643;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1_DOT_left_2).right;\nAKA_VECTOR_INIT_root_1_DOT_left.push_back(AKA_VECTOR_INIT_root_1_DOT_left_2);\n(*AKA_VECTOR_INIT_root_1).left = AKA_VECTOR_INIT_root_1_DOT_left[0];\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_1_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root1_right0_x=877128937;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1_DOT_right_0 = new ::TreeNode(root1_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_1_DOT_right_0).val=1124107638;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1_DOT_right_0).right;\nAKA_VECTOR_INIT_root_1_DOT_right.push_back(AKA_VECTOR_INIT_root_1_DOT_right_0);\n(*AKA_VECTOR_INIT_root_1).right = AKA_VECTOR_INIT_root_1_DOT_right[0];\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_x=1186625965;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode(root2_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2).val=1247733960;\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_2_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_left0_x=1960422670;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2_DOT_left_0 = new ::TreeNode(root2_left0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2_DOT_left_0).val=-1649230767;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2_DOT_left_0).right;\nAKA_VECTOR_INIT_root_2_DOT_left.push_back(AKA_VECTOR_INIT_root_2_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_left1_x=-110883369;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2_DOT_left_1 = new ::TreeNode(root2_left1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2_DOT_left_1).val=1141165230;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2_DOT_left_1).right;\nAKA_VECTOR_INIT_root_2_DOT_left.push_back(AKA_VECTOR_INIT_root_2_DOT_left_1);\n(*AKA_VECTOR_INIT_root_2).left = AKA_VECTOR_INIT_root_2_DOT_left[0];\n/* PointerStructureDataNode right */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_2_DOT_right;\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_right0_x=-446047342;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\right\\\\right[0]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2_DOT_right_0 = new ::TreeNode(root2_right0_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2_DOT_right_0).val=-549023635;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2_DOT_right_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2_DOT_right_0).right;\nAKA_VECTOR_INIT_root_2_DOT_right.push_back(AKA_VECTOR_INIT_root_2_DOT_right_0);\n/* SubStructDataNode right */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root2_right1_x=2003069070;\nAKA_mark(\"Calling: .\\\\two\\\\Binary Tree Paths.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\Binary_Tree_Preorder_Traversal.cpp\\\\preorderTraversal(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\right\\\\right[1]\\\\right\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2_DOT_right_1 = new ::TreeNode(root2_right1_x);\n/* NormalNumberDataNode val */\n(*AKA_VECTOR_INIT_root_2_DOT_right_1).val=1610373260;\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2_DOT_right_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2_DOT_right_1).right;\nAKA_VECTOR_INIT_root_2_DOT_right.push_back(AKA_VECTOR_INIT_root_2_DOT_right_1);\n(*AKA_VECTOR_INIT_root_2).right = AKA_VECTOR_INIT_root_2_DOT_right[0];\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tvector<int> preorderTraversal(TreeNode *root) {\r \t\tstack<TreeNode*> tStack;\r \t\tvector<int> result;\r \t\twhile (tStack.size() > 0 || root != NULL)\r \t\t{\r \t\t\tif (root != NULL)\r \t\t\t{\r \t\t\t\tresult.push_back(root->val);\r \t\t\t\tif (root->right != NULL)\r \t\t\t\t\ttStack.push(root->right);\r \t\t\t\troot = root->left;\r \t\t\t}\r \t\t\telse\r \t\t\t{\r \t\t\t\troot = tStack.top();\r \t\t\t\ttStack.pop();\r \t\t\t}\r \t\t}\r \t\treturn result;\r \t}\r \r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Binary_Tree_Preorder_Traversal.cpp\\Solution\\preorderTraversal(TreeNode*)"
    },
    {
        "f": [],
        "fm": "int climbStairs(int n) {\r \t\tint fn_2 = 1, fn_1 = 2;\r \t\tif (n == 1) return fn_2;\r \t\tif (n == 2) return fn_1;\r \t\tint fn;\r \t\tfor (int i = 3; i <= n; i++)\r \t\t{\r \t\t\tfn = fn_2 + fn_1;\r \t\t\tfn_2 = fn_1;\r \t\t\tfn_1 = fn;\r \t\t}\r \t\treturn fn;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_climbStairs_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=2;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Climbing_Stairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=2;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_climbStairs_int_directed_6(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_directed_6\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=7;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_directed_6\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Climbing_Stairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=7;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_climbStairs_int_directed_5(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_directed_5\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=10;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_directed_5\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Climbing_Stairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=10;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_climbStairs_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=1;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Climbing_Stairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=1;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_climbStairs_int_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=6;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_directed_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Climbing_Stairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=6;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_climbStairs_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=3;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Climbing_Stairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=3;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_climbStairs_int_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=9;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Climbing_Stairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=9;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_climbStairs_int_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=5;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_directed_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Climbing_Stairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=5;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_climbStairs_int_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_climbStairs_int_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=8;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_climbStairs_int_directed_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->climbStairs(n);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Climbing_Stairs.cpp\\\\Solution\\\\climbStairs(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Climbing_Stairs.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=8;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tint climbStairs(int n) {\r \t\tint fn_2 = 1, fn_1 = 2;\r \t\tif (n == 1) return fn_2;\r \t\tif (n == 2) return fn_1;\r \t\tint fn;\r \t\tfor (int i = 3; i <= n; i++)\r \t\t{\r \t\t\tfn = fn_2 + fn_1;\r \t\t\tfn_2 = fn_1;\r \t\t\tfn_1 = fn;\r \t\t}\r \t\treturn fn;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Climbing_Stairs.cpp\\Solution\\climbStairs(int)"
    },
    {
        "f": [],
        "fm": "UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\r \t\tif (node == NULL) return NULL;\r \t\tunordered_map<UndirectedGraphNode *, UndirectedGraphNode *> nodeMap;\r \t\tqueue<UndirectedGraphNode *> visit;\r \t\tvisit.push(node);\r \t\tUndirectedGraphNode * nodeCopy = new UndirectedGraphNode(node->label);\r \t\tnodeMap[node] = nodeCopy;\r \t\twhile (visit.size() > 0)\r \t\t{\r \t\t\tUndirectedGraphNode * cur = visit.front();\r \t\t\tvisit.pop();\r \t\t\tfor (int i = 0; i < cur->neighbors.size(); ++i)\r \t\t\t{\r \t\t\t\tUndirectedGraphNode * neighb = cur->neighbors[i];\r \t\t\t\tif (nodeMap.find(neighb) == nodeMap.end())\r \t\t\t\t{\r \t\t\t\t\t// no copy of neighbor node yet. create one and link with the copy of cur\r \t\t\t\t\tUndirectedGraphNode* neighbCopy = new UndirectedGraphNode(neighb->label);\r \t\t\t\t\tnodeMap[cur]->neighbors.push_back(neighbCopy);\r \t\t\t\t\tnodeMap[neighb] = neighbCopy;\r \t\t\t\t\tvisit.push(neighb);\r \t\t\t\t}\r \t\t\t\telse\r \t\t\t\t{\r \t\t\t\t\t// already a copy there. link it with the copy of cur\r \t\t\t\t\tnodeMap[cur]->neighbors.push_back(nodeMap[neighb]);\r \t\t\t\t}\r \t\t\t}\r \t\t}\r \r \t\treturn nodeCopy;\r \t}",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_9(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_9\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_9\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_20(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_20\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_20\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_7(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_7\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_7\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_22(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_22\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_22\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_8(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_8\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_8\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 5,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_21(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_21\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_21\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 6,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_5(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_5\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_5\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 7,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_24(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_24\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_24\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 8,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_6(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_6\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_6\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 9,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_23(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_23\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_23\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 10,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_26(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_26\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_26\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 11,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_25(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_25\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_25\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 12,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_28(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_28\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_28\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 13,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_27(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_27\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_27\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 14,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_29(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_29\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_29\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 15,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_random_0(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_random_0\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 16,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_random_1(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=178938394;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=852415306;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_random_1\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=178938394;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=852415306;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 17,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_31(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_31\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_31\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 18,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_30(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_30\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_30\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 19,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_11(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_11\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_11\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 20,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_10(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_10\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_10\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 21,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_32(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_32\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_32\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 22,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_13(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_13\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_13\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 23,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_12(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_12\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_12\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 24,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_15(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_15\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_15\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 25,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_14(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_14\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_14\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 26,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_17(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_17\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_17\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 27,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_16(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_16\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_16\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 28,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_19(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_19\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_19\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 29,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_18(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_18\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_18\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 30,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_3(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_3\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 31,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_4(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_4\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nUndirectedGraphNode* node;\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 32,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_1\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 33,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_2(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_2\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 34,
                "dt": {},
                "td": "void AKA_TEST_Solution_cloneGraph_UndirectedGraphNodemul_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_cloneGraph_UndirectedGraphNodemul_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_cloneGraph_UndirectedGraphNodemul_directed_0\");UndirectedGraphNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->cloneGraph(node);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\two\\\\Clone_Graph.cpp\\\\Solution\\\\cloneGraph(UndirectedGraphNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\Clone_Graph.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<UndirectedGraphNode*> AKA_VECTOR_INIT_node;\n\n\n/* SubStructDataNode node */\n/* ConstructorDataNode UndirectedGraphNode(int) */\n/* NormalNumberDataNode x */\nint node0_x=0;\nAKA_mark(\"Calling: .\\\\two\\\\Clone_Graph.cpp\\\\UndirectedGraphNode\\\\UndirectedGraphNode(int)|ROOT\\\\Clone_Graph.cpp\\\\cloneGraph(UndirectedGraphNode*)\\\\node\\\\AKA_VECTOR_INIT_node_0\\\\node\\\\UndirectedGraphNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_node_0 = new ::UndirectedGraphNode(node0_x);\n/* NormalNumberDataNode label */\n(*AKA_VECTOR_INIT_node_0).label=0;\n/* VectorDataNode neighbors */\n\nAKA_VECTOR_INIT_node.push_back(AKA_VECTOR_INIT_node_0);\n\nUndirectedGraphNode* node = AKA_VECTOR_INIT_node[0];\nUndirectedGraphNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode node */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \tUndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {\r \t\tif (node == NULL) return NULL;\r \t\tunordered_map<UndirectedGraphNode *, UndirectedGraphNode *> nodeMap;\r \t\tqueue<UndirectedGraphNode *> visit;\r \t\tvisit.push(node);\r \t\tUndirectedGraphNode * nodeCopy = new UndirectedGraphNode(node->label);\r \t\tnodeMap[node] = nodeCopy;\r \t\twhile (visit.size() > 0)\r \t\t{\r \t\t\tUndirectedGraphNode * cur = visit.front();\r \t\t\tvisit.pop();\r \t\t\tfor (int i = 0; i < cur->neighbors.size(); ++i)\r \t\t\t{\r \t\t\t\tUndirectedGraphNode * neighb = cur->neighbors[i];\r \t\t\t\tif (nodeMap.find(neighb) == nodeMap.end())\r \t\t\t\t{\r \t\t\t\t\t// no copy of neighbor node yet. create one and link with the copy of cur\r \t\t\t\t\tUndirectedGraphNode* neighbCopy = new UndirectedGraphNode(neighb->label);\r \t\t\t\t\tnodeMap[cur]->neighbors.push_back(neighbCopy);\r \t\t\t\t\tnodeMap[neighb] = neighbCopy;\r \t\t\t\t\tvisit.push(neighb);\r \t\t\t\t}\r \t\t\t\telse\r \t\t\t\t{\r \t\t\t\t\t// already a copy there. link it with the copy of cur\r \t\t\t\t\tnodeMap[cur]->neighbors.push_back(nodeMap[neighb]);\r \t\t\t\t}\r \t\t\t}\r \t\t}\r \r \t\treturn nodeCopy;\r \t}\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\prj-data\\codingtmd_leetcode\\src\\two\\Clone_Graph.cpp\\Solution\\cloneGraph(UndirectedGraphNode*)"
    }
]