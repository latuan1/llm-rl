[
    {
        "f": [],
        "fm": "int maxSubArray(vector<int>& nums) {         int len = nums.size();         if(len == 0)             return 0;         int ans = nums[0], temp = nums[0];         for(int i = 1; i < len; i++) {             if(temp > 0) {                 temp = temp + nums[i];             } else {                 temp = nums[i];             }             ans = max(ans, temp);         }         return ans;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxSubArray_vector_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_maxSubArray_vector_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/053. Maximum Subarray.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-1475055540;\nnums.push_back(nums_element0);\nint nums_element1=1049857255;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxSubArray_vector_int_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxSubArray(nums);\nAKA_fCall++;AKA_mark(\"Return from: ./15/053. Maximum Subarray.cpp/Solution/maxSubArray(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/053. Maximum Subarray.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-1475055540;\nnums.push_back(nums_element0);\nint nums_element1=1049857255;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxSubArray_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxSubArray_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/053. Maximum Subarray.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=1020887783;\nnums.push_back(nums_element0);\nint nums_element1=-66764133;\nnums.push_back(nums_element1);\nint nums_element2=-2061420147;\nnums.push_back(nums_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxSubArray_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxSubArray(nums);\nAKA_fCall++;AKA_mark(\"Return from: ./15/053. Maximum Subarray.cpp/Solution/maxSubArray(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/053. Maximum Subarray.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=1020887783;\nnums.push_back(nums_element0);\nint nums_element1=-66764133;\nnums.push_back(nums_element1);\nint nums_element2=-2061420147;\nnums.push_back(nums_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int maxSubArray(vector<int>& nums) {         int len = nums.size();         if(len == 0)             return 0;         int ans = nums[0], temp = nums[0];         for(int i = 1; i < len; i++) {             if(temp > 0) {                 temp = temp + nums[i];             } else {                 temp = nums[i];             }             ans = max(ans, temp);         }         return ans;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/053. Maximum Subarray.cpp/Solution/maxSubArray(vector<int>&)"
    },
    {
        "f": [],
        "fm": "vector<int> spiralOrder(vector<vector<int>>& matrix) {         vector<int> result;         if(matrix.empty()) return result;         int m = matrix.size() - 1, n = matrix[0].size() - 1;         for (int x = 0, y = 0; x <= m && y <= n; x++, y++, m--, n--) {             for (int j = y; j <= n; j++)                 result.push_back(matrix[x][j]);             for (int i = x + 1; i <= m - 1; i++)                 result.push_back(matrix[i][n]);             for (int j = n; j >= y && x != m; j--)                 result.push_back(matrix[m][j]);             for (int i = m - 1; i > x && y != n; i--)                 result.push_back(matrix[i][y]);         }         return result;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_spiralOrder_vector_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_spiralOrder_vector_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/054. Spiral Matrix.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> matrix;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode matrix */\nvector<int> matrix_element0;\nint matrix_element0_element0=2024792305;\nmatrix_element0.push_back(matrix_element0_element0);\nint matrix_element0_element1=1477609337;\nmatrix_element0.push_back(matrix_element0_element1);\nint matrix_element0_element2=1499383000;\nmatrix_element0.push_back(matrix_element0_element2);\nmatrix.push_back(matrix_element0);\nvector<int> matrix_element1;\nint matrix_element1_element0=180490898;\nmatrix_element1.push_back(matrix_element1_element0);\nint matrix_element1_element1=1313940199;\nmatrix_element1.push_back(matrix_element1_element1);\nint matrix_element1_element2=-492213956;\nmatrix_element1.push_back(matrix_element1_element2);\nmatrix.push_back(matrix_element1);\nvector<int> matrix_element2;\nint matrix_element2_element0=-1034389179;\nmatrix_element2.push_back(matrix_element2_element0);\nint matrix_element2_element1=-1312811658;\nmatrix_element2.push_back(matrix_element2_element1);\nint matrix_element2_element2=-827647061;\nmatrix_element2.push_back(matrix_element2_element2);\nmatrix.push_back(matrix_element2);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_spiralOrder_vector_vector_int_random_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->spiralOrder(matrix);\nAKA_fCall++;AKA_mark(\"Return from: ./15/054. Spiral Matrix.cpp/Solution/spiralOrder(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_matrix;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/054. Spiral Matrix.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> matrix;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode matrix */\nvector<int> matrix_element0;\nint matrix_element0_element0=2024792305;\nmatrix_element0.push_back(matrix_element0_element0);\nint matrix_element0_element1=1477609337;\nmatrix_element0.push_back(matrix_element0_element1);\nint matrix_element0_element2=1499383000;\nmatrix_element0.push_back(matrix_element0_element2);\nmatrix.push_back(matrix_element0);\nvector<int> matrix_element1;\nint matrix_element1_element0=180490898;\nmatrix_element1.push_back(matrix_element1_element0);\nint matrix_element1_element1=1313940199;\nmatrix_element1.push_back(matrix_element1_element1);\nint matrix_element1_element2=-492213956;\nmatrix_element1.push_back(matrix_element1_element2);\nmatrix.push_back(matrix_element1);\nvector<int> matrix_element2;\nint matrix_element2_element0=-1034389179;\nmatrix_element2.push_back(matrix_element2_element0);\nint matrix_element2_element1=-1312811658;\nmatrix_element2.push_back(matrix_element2_element1);\nint matrix_element2_element2=-827647061;\nmatrix_element2.push_back(matrix_element2_element2);\nmatrix.push_back(matrix_element2);\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     vector<int> spiralOrder(vector<vector<int>>& matrix) {         vector<int> result;         if(matrix.empty()) return result;         int m = matrix.size() - 1, n = matrix[0].size() - 1;         for (int x = 0, y = 0; x <= m && y <= n; x++, y++, m--, n--) {             for (int j = y; j <= n; j++)                 result.push_back(matrix[x][j]);             for (int i = x + 1; i <= m - 1; i++)                 result.push_back(matrix[i][n]);             for (int j = n; j >= y && x != m; j--)                 result.push_back(matrix[m][j]);             for (int i = m - 1; i > x && y != n; i--)                 result.push_back(matrix[i][y]);         }         return result;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/054. Spiral Matrix.cpp/Solution/spiralOrder(vector<vector<int>>&)"
    },
    {
        "f": [],
        "fm": "bool canJump(vector<int>& nums) {         int distance = 0;         for(int i = 0; i < nums.size() - 1 && i <= distance; i++) {             distance = max(distance, i + nums[i]);         }         return distance >= (nums.size() - 1);     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_canJump_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_canJump_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/055. Jump Game.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=97948724;\nnums.push_back(nums_element0);\nint nums_element1=227331040;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canJump_vector_int_random_2\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canJump(nums);\nAKA_fCall++;AKA_mark(\"Return from: ./15/055. Jump Game.cpp/Solution/canJump(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/055. Jump Game.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=97948724;\nnums.push_back(nums_element0);\nint nums_element1=227331040;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     bool canJump(vector<int>& nums) {         int distance = 0;         for(int i = 0; i < nums.size() - 1 && i <= distance; i++) {             distance = max(distance, i + nums[i]);         }         return distance >= (nums.size() - 1);     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/055. Jump Game.cpp/Solution/canJump(vector<int>&)"
    },
    {
        "f": [],
        "fm": "vector<Interval> merge(vector<Interval>& intervals) {         vector<Interval> ans;         if (intervals.size() == 0) return ans;         sort(intervals.begin(), intervals.end(), [](Interval a, Interval b){return a.start < b.start;});         ans.push_back(intervals[0]);         for (int i = 1; i < intervals.size(); i++) {             if(ans.back().end < intervals[i].start)                  ans.push_back(intervals[i]);             else                 ans.back().end = max(ans.back().end, intervals[i].end);         }         return ans;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_Interval_random_2(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_Interval_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/056. Merge Intervals.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element0_s=-1962189236;\n/* NormalNumberDataNode e */\nint intervals_element0_e=-550861928;\nAKA_mark(\"Calling: ./15/056. Merge Intervals.cpp/Interval/Interval(int,int)|ROOT/056. Merge Intervals.cpp/merge(vector<Interval>&)/intervals/element #0//Interval(int,int)\");AKA_fCall++;::Interval intervals_element0 = ::Interval(intervals_element0_s,intervals_element0_e);\n/* NormalNumberDataNode start */\nintervals_element0.start=1623712943;\n/* NormalNumberDataNode end */\nintervals_element0.end=1040462850;\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element1_s=-837483558;\n/* NormalNumberDataNode e */\nint intervals_element1_e=-476852761;\nAKA_mark(\"Calling: ./15/056. Merge Intervals.cpp/Interval/Interval(int,int)|ROOT/056. Merge Intervals.cpp/merge(vector<Interval>&)/intervals/element #1//Interval(int,int)\");AKA_fCall++;::Interval intervals_element1 = ::Interval(intervals_element1_s,intervals_element1_e);\n/* NormalNumberDataNode start */\nintervals_element1.start=-632935432;\n/* NormalNumberDataNode end */\nintervals_element1.end=1430484215;\nintervals.push_back(intervals_element1);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element2_s=2013626785;\n/* NormalNumberDataNode e */\nint intervals_element2_e=1113074791;\nAKA_mark(\"Calling: ./15/056. Merge Intervals.cpp/Interval/Interval(int,int)|ROOT/056. Merge Intervals.cpp/merge(vector<Interval>&)/intervals/element #2//Interval(int,int)\");AKA_fCall++;::Interval intervals_element2 = ::Interval(intervals_element2_s,intervals_element2_e);\n/* NormalNumberDataNode start */\nintervals_element2.start=-1593353005;\n/* NormalNumberDataNode end */\nintervals_element2.end=59190052;\nintervals.push_back(intervals_element2);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_Interval_random_2\");vector<Interval> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(intervals);\nAKA_fCall++;AKA_mark(\"Return from: ./15/056. Merge Intervals.cpp/Solution/merge(vector<Interval>&)\");\n\n\nvector<Interval> EXPECTED_intervals;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/056. Merge Intervals.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<Interval> intervals;\nvector<Interval> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode intervals */\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element0_s=-1962189236;\n/* NormalNumberDataNode e */\nint intervals_element0_e=-550861928;\nAKA_mark(\"Calling: ./15/056. Merge Intervals.cpp/Interval/Interval(int,int)|ROOT/056. Merge Intervals.cpp/merge(vector<Interval>&)/intervals/element #0//Interval(int,int)\");AKA_fCall++;::Interval intervals_element0 = ::Interval(intervals_element0_s,intervals_element0_e);\n/* NormalNumberDataNode start */\nintervals_element0.start=1623712943;\n/* NormalNumberDataNode end */\nintervals_element0.end=1040462850;\nintervals.push_back(intervals_element0);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element1_s=-837483558;\n/* NormalNumberDataNode e */\nint intervals_element1_e=-476852761;\nAKA_mark(\"Calling: ./15/056. Merge Intervals.cpp/Interval/Interval(int,int)|ROOT/056. Merge Intervals.cpp/merge(vector<Interval>&)/intervals/element #1//Interval(int,int)\");AKA_fCall++;::Interval intervals_element1 = ::Interval(intervals_element1_s,intervals_element1_e);\n/* NormalNumberDataNode start */\nintervals_element1.start=-632935432;\n/* NormalNumberDataNode end */\nintervals_element1.end=1430484215;\nintervals.push_back(intervals_element1);\n\n/* SubStructDataNode  */\n/* ConstructorDataNode Interval(int,int) */\n/* NormalNumberDataNode s */\nint intervals_element2_s=2013626785;\n/* NormalNumberDataNode e */\nint intervals_element2_e=1113074791;\nAKA_mark(\"Calling: ./15/056. Merge Intervals.cpp/Interval/Interval(int,int)|ROOT/056. Merge Intervals.cpp/merge(vector<Interval>&)/intervals/element #2//Interval(int,int)\");AKA_fCall++;::Interval intervals_element2 = ::Interval(intervals_element2_s,intervals_element2_e);\n/* NormalNumberDataNode start */\nintervals_element2.start=-1593353005;\n/* NormalNumberDataNode end */\nintervals_element2.end=59190052;\nintervals.push_back(intervals_element2);\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     vector<Interval> merge(vector<Interval>& intervals) {         vector<Interval> ans;         if (intervals.size() == 0) return ans;         sort(intervals.begin(), intervals.end(), [](Interval a, Interval b){return a.start < b.start;});         ans.push_back(intervals[0]);         for (int i = 1; i < intervals.size(); i++) {             if(ans.back().end < intervals[i].start)                  ans.push_back(intervals[i]);             else                 ans.back().end = max(ans.back().end, intervals[i].end);         }         return ans;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/056. Merge Intervals.cpp/Solution/merge(vector<Interval>&)"
    },
    {
        "f": [],
        "fm": "int lengthOfLastWord(string s) {         int cnt = 0;         int flag = 0;         for(int i = s.length() - 1; i >= 0; i--) {             if(flag == 0 && s[i] == ' ') {                 continue;             }             if(s[i] != ' ') {                 flag = 1;                 cnt++;             } else {                 break;             }         }         return cnt;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_lengthOfLastWord_string_random_3(void) {\n{\nAKA_test_case_name=\"Solution_lengthOfLastWord_string_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/058. Length of Last Word.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName858334 = new char[2];akaRandomName858334[0] = -110;akaRandomName858334[1] = '\\0';string s=akaRandomName858334;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_lengthOfLastWord_string_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->lengthOfLastWord(s);\nAKA_fCall++;AKA_mark(\"Return from: ./15/058. Length of Last Word.cpp/Solution/lengthOfLastWord(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/058. Length of Last Word.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName976025 = new char[2];akaRandomName976025[0] = -110;akaRandomName976025[1] = '\\0';string s=akaRandomName976025;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int lengthOfLastWord(string s) {         int cnt = 0;         int flag = 0;         for(int i = s.length() - 1; i >= 0; i--) {             if(flag == 0 && s[i] == ' ') {                 continue;             }             if(s[i] != ' ') {                 flag = 1;                 cnt++;             } else {                 break;             }         }         return cnt;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/058. Length of Last Word.cpp/Solution/lengthOfLastWord(string)"
    },
    {
        "f": [],
        "fm": "vector<vector<int>> generateMatrix(int n) {         vector<vector<int>> result(n, vector<int>(n));         n = n - 1;         int num = 1;         for (int x = 0; x <= n; x++, n--) {             for (int j = x; j <= n; j++)                 result[x][j] = num++;             for (int i = x + 1; i <= n - 1; i++)                 result[i][n] = num++;             for (int j = n; j >= x && x != n; j--)                 result[n][j] = num++;             for (int i = n - 1; i >= x + 1 && x != n; i--)                 result[i][x] = num++;         }         return result;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_generateMatrix_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_generateMatrix_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/059. Spiral Matrix II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=10;\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_generateMatrix_int_random_1\");vector<vector<int>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->generateMatrix(n);\nAKA_fCall++;AKA_mark(\"Return from: ./15/059. Spiral Matrix II.cpp/Solution/generateMatrix(int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/059. Spiral Matrix II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=10;\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     vector<vector<int>> generateMatrix(int n) {         vector<vector<int>> result(n, vector<int>(n));         n = n - 1;         int num = 1;         for (int x = 0; x <= n; x++, n--) {             for (int j = x; j <= n; j++)                 result[x][j] = num++;             for (int i = x + 1; i <= n - 1; i++)                 result[i][n] = num++;             for (int j = n; j >= x && x != n; j--)                 result[n][j] = num++;             for (int i = n - 1; i >= x + 1 && x != n; i--)                 result[i][x] = num++;         }         return result;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/059. Spiral Matrix II.cpp/Solution/generateMatrix(int)"
    },
    {
        "f": [],
        "fm": "string getPermutation(int n, int k) {         string result = \"\";         for (int i = 1; i <= n; i++)             result += to_string(i);         do {             k--;         } while (k > 0 && next_permutation(result.begin(), result.end()));         return result;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_getPermutation_int_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_getPermutation_int_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/060. Permutation Sequence.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=2;\n\n\nint k=2;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode k */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getPermutation_int_int_random_1\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->getPermutation(n,k);\nAKA_fCall++;AKA_mark(\"Return from: ./15/060. Permutation Sequence.cpp/Solution/getPermutation(int,int)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/060. Permutation Sequence.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=2;\n\n\nint k=2;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode k */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_getPermutation_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_getPermutation_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/060. Permutation Sequence.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=2;\n\n\nint k=7;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode k */\n/* NormalStringDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_getPermutation_int_int_random_0\");string AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->getPermutation(n,k);\nAKA_fCall++;AKA_mark(\"Return from: ./15/060. Permutation Sequence.cpp/Solution/getPermutation(int,int)\");\n\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/060. Permutation Sequence.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint n=2;\n\n\nint k=7;\nstring AKA_EXPECTED_OUTPUT=\"\";\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode k */\n/* NormalStringDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     string getPermutation(int n, int k) {         string result = \"\";         for (int i = 1; i <= n; i++)             result += to_string(i);         do {             k--;         } while (k > 0 && next_permutation(result.begin(), result.end()));         return result;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/060. Permutation Sequence.cpp/Solution/getPermutation(int,int)"
    },
    {
        "f": [],
        "fm": "ListNode* rotateRight(ListNode* head, int k) {         if (head == NULL) return head;         int len = 0;         ListNode *newhead = head, *tail = head, *p = head;         while (p != NULL) {             if (p->next == NULL)                 tail = p;             len++;             p = p->next;         }         int moveDistance = len - k % len;         if (moveDistance == len) return head;         for (int i = 0; i < moveDistance - 1; i++) {             newhead = newhead->next;         }         ListNode *temp = newhead;         newhead = newhead->next;         temp->next = NULL;         tail->next = head;         return newhead;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_rotateRight_ListNodemul_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_rotateRight_ListNodemul_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/061. Rotate List.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=1420268184;\nAKA_mark(\"Calling: ./15/061. Rotate List.cpp/ListNode/ListNode(int)|ROOT/061. Rotate List.cpp/rotateRight(ListNode*,int)/head/AKA_VECTOR_INIT_head_0/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=1909399728;\nAKA_mark(\"Calling: ./15/061. Rotate List.cpp/ListNode/ListNode(int)|ROOT/061. Rotate List.cpp/rotateRight(ListNode*,int)/head/AKA_VECTOR_INIT_head_1/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head2_x=0;\nAKA_mark(\"Calling: ./15/061. Rotate List.cpp/ListNode/ListNode(int)|ROOT/061. Rotate List.cpp/rotateRight(ListNode*,int)/head/AKA_VECTOR_INIT_head_2/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::ListNode(head2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nint k=2;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode k */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_rotateRight_ListNodemul_int_random_0\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->rotateRight(head,k);\nAKA_fCall++;AKA_mark(\"Return from: ./15/061. Rotate List.cpp/Solution/rotateRight(ListNode*,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/061. Rotate List.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=1420268184;\nAKA_mark(\"Calling: ./15/061. Rotate List.cpp/ListNode/ListNode(int)|ROOT/061. Rotate List.cpp/rotateRight(ListNode*,int)/head/AKA_VECTOR_INIT_head_0/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=1909399728;\nAKA_mark(\"Calling: ./15/061. Rotate List.cpp/ListNode/ListNode(int)|ROOT/061. Rotate List.cpp/rotateRight(ListNode*,int)/head/AKA_VECTOR_INIT_head_1/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head2_x=0;\nAKA_mark(\"Calling: ./15/061. Rotate List.cpp/ListNode/ListNode(int)|ROOT/061. Rotate List.cpp/rotateRight(ListNode*,int)/head/AKA_VECTOR_INIT_head_2/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::ListNode(head2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nint k=2;\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode k */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     ListNode* rotateRight(ListNode* head, int k) {         if (head == NULL) return head;         int len = 0;         ListNode *newhead = head, *tail = head, *p = head;         while (p != NULL) {             if (p->next == NULL)                 tail = p;             len++;             p = p->next;         }         int moveDistance = len - k % len;         if (moveDistance == len) return head;         for (int i = 0; i < moveDistance - 1; i++) {             newhead = newhead->next;         }         ListNode *temp = newhead;         newhead = newhead->next;         temp->next = NULL;         tail->next = head;         return newhead;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/061. Rotate List.cpp/Solution/rotateRight(ListNode*,int)"
    },
    {
        "f": [],
        "fm": "int uniquePaths(int m, int n) {         int a[100][100];         for(int i = 0; i < m; i++) {             for(int j = 0; j < n; j++) {                 if(i == 0 || j == 0)                     a[i][j] = 1;                 else                     a[i][j] = a[i - 1][j] + a[i][j - 1];             }         }         return a[m - 1][n - 1];     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_uniquePaths_int_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_uniquePaths_int_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/062. Unique Paths.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint m=10;\n\n\nint n=2;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode m */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_uniquePaths_int_int_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->uniquePaths(m,n);\nAKA_fCall++;AKA_mark(\"Return from: ./15/062. Unique Paths.cpp/Solution/uniquePaths(int,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/062. Unique Paths.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint m=10;\n\n\nint n=2;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode m */\n/* NormalNumberDataNode n */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int uniquePaths(int m, int n) {         int a[100][100];         for(int i = 0; i < m; i++) {             for(int j = 0; j < n; j++) {                 if(i == 0 || j == 0)                     a[i][j] = 1;                 else                     a[i][j] = a[i - 1][j] + a[i][j - 1];             }         }         return a[m - 1][n - 1];     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/062. Unique Paths.cpp/Solution/uniquePaths(int,int)"
    },
    {
        "f": [],
        "fm": "int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {         int m = obstacleGrid.size();         int n = obstacleGrid[0].size();         int a[100][100];         for(int i = 0; i < m; i++) {             for(int j = 0; j < n; j++) {                 if(obstacleGrid[i][j] == 1) {                     a[i][j] = 0;                 } else if(i == 0 && j == 0) {                     a[i][j] = 1;                 } else if(i == 0) {                     a[i][j] = a[i][j-1];                 } else if(j == 0) {                     a[i][j] = a[i-1][j];                 } else {                     a[i][j] = a[i-1][j] + a[i][j-1];                 }             }         }         return a[m-1][n-1];     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_uniquePathsWithObstacles_vector_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_uniquePathsWithObstacles_vector_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=-1917669172;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=1243265440;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nint obstacleGrid_element0_element2=-114693351;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element2);\nobstacleGrid.push_back(obstacleGrid_element0);\nvector<int> obstacleGrid_element1;\nint obstacleGrid_element1_element0=581815359;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element0);\nint obstacleGrid_element1_element1=-337256401;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element1);\nint obstacleGrid_element1_element2=-2076317880;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element2);\nobstacleGrid.push_back(obstacleGrid_element1);\nvector<int> obstacleGrid_element2;\nint obstacleGrid_element2_element0=-1140239056;\nobstacleGrid_element2.push_back(obstacleGrid_element2_element0);\nint obstacleGrid_element2_element1=2118400059;\nobstacleGrid_element2.push_back(obstacleGrid_element2_element1);\nint obstacleGrid_element2_element2=1608434573;\nobstacleGrid_element2.push_back(obstacleGrid_element2_element2);\nobstacleGrid.push_back(obstacleGrid_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_uniquePathsWithObstacles_vector_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->uniquePathsWithObstacles(obstacleGrid);\nAKA_fCall++;AKA_mark(\"Return from: ./15/063. Unique Paths II.cpp/Solution/uniquePathsWithObstacles(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_obstacleGrid;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=-1917669172;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=1243265440;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nint obstacleGrid_element0_element2=-114693351;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element2);\nobstacleGrid.push_back(obstacleGrid_element0);\nvector<int> obstacleGrid_element1;\nint obstacleGrid_element1_element0=581815359;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element0);\nint obstacleGrid_element1_element1=-337256401;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element1);\nint obstacleGrid_element1_element2=-2076317880;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element2);\nobstacleGrid.push_back(obstacleGrid_element1);\nvector<int> obstacleGrid_element2;\nint obstacleGrid_element2_element0=-1140239056;\nobstacleGrid_element2.push_back(obstacleGrid_element2_element0);\nint obstacleGrid_element2_element1=2118400059;\nobstacleGrid_element2.push_back(obstacleGrid_element2_element1);\nint obstacleGrid_element2_element2=1608434573;\nobstacleGrid_element2.push_back(obstacleGrid_element2_element2);\nobstacleGrid.push_back(obstacleGrid_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_uniquePathsWithObstacles_vector_vector_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_uniquePathsWithObstacles_vector_vector_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=1803695399;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=-1571652425;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nint obstacleGrid_element0_element2=984914383;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element2);\nobstacleGrid.push_back(obstacleGrid_element0);\nvector<int> obstacleGrid_element1;\nint obstacleGrid_element1_element0=-1427419465;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element0);\nobstacleGrid.push_back(obstacleGrid_element1);\nvector<int> obstacleGrid_element2;\nint obstacleGrid_element2_element0=1618123799;\nobstacleGrid_element2.push_back(obstacleGrid_element2_element0);\nobstacleGrid.push_back(obstacleGrid_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_uniquePathsWithObstacles_vector_vector_int_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->uniquePathsWithObstacles(obstacleGrid);\nAKA_fCall++;AKA_mark(\"Return from: ./15/063. Unique Paths II.cpp/Solution/uniquePathsWithObstacles(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_obstacleGrid;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=1803695399;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=-1571652425;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nint obstacleGrid_element0_element2=984914383;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element2);\nobstacleGrid.push_back(obstacleGrid_element0);\nvector<int> obstacleGrid_element1;\nint obstacleGrid_element1_element0=-1427419465;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element0);\nobstacleGrid.push_back(obstacleGrid_element1);\nvector<int> obstacleGrid_element2;\nint obstacleGrid_element2_element0=1618123799;\nobstacleGrid_element2.push_back(obstacleGrid_element2_element0);\nobstacleGrid.push_back(obstacleGrid_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_uniquePathsWithObstacles_vector_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_uniquePathsWithObstacles_vector_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=-1306253663;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=-1721751325;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nobstacleGrid.push_back(obstacleGrid_element0);\nvector<int> obstacleGrid_element1;\nint obstacleGrid_element1_element0=-1903966724;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element0);\nint obstacleGrid_element1_element1=-870346262;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element1);\nint obstacleGrid_element1_element2=-390666506;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element2);\nobstacleGrid.push_back(obstacleGrid_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_uniquePathsWithObstacles_vector_vector_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->uniquePathsWithObstacles(obstacleGrid);\nAKA_fCall++;AKA_mark(\"Return from: ./15/063. Unique Paths II.cpp/Solution/uniquePathsWithObstacles(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_obstacleGrid;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=-1306253663;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=-1721751325;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nobstacleGrid.push_back(obstacleGrid_element0);\nvector<int> obstacleGrid_element1;\nint obstacleGrid_element1_element0=-1903966724;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element0);\nint obstacleGrid_element1_element1=-870346262;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element1);\nint obstacleGrid_element1_element2=-390666506;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element2);\nobstacleGrid.push_back(obstacleGrid_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 3,
                "dt": {},
                "td": "void AKA_TEST_Solution_uniquePathsWithObstacles_vector_vector_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_uniquePathsWithObstacles_vector_vector_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=1767991178;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=-1028259247;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nint obstacleGrid_element0_element2=1928388465;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element2);\nobstacleGrid.push_back(obstacleGrid_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_uniquePathsWithObstacles_vector_vector_int_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->uniquePathsWithObstacles(obstacleGrid);\nAKA_fCall++;AKA_mark(\"Return from: ./15/063. Unique Paths II.cpp/Solution/uniquePathsWithObstacles(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_obstacleGrid;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=1767991178;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=-1028259247;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nint obstacleGrid_element0_element2=1928388465;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element2);\nobstacleGrid.push_back(obstacleGrid_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 4,
                "dt": {},
                "td": "void AKA_TEST_Solution_uniquePathsWithObstacles_vector_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_uniquePathsWithObstacles_vector_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=-1009971319;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=-1413311285;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nobstacleGrid.push_back(obstacleGrid_element0);\nvector<int> obstacleGrid_element1;\nint obstacleGrid_element1_element0=273673469;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element0);\nint obstacleGrid_element1_element1=30730250;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element1);\nobstacleGrid.push_back(obstacleGrid_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_uniquePathsWithObstacles_vector_vector_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->uniquePathsWithObstacles(obstacleGrid);\nAKA_fCall++;AKA_mark(\"Return from: ./15/063. Unique Paths II.cpp/Solution/uniquePathsWithObstacles(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_obstacleGrid;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/063. Unique Paths II.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> obstacleGrid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode obstacleGrid */\nvector<int> obstacleGrid_element0;\nint obstacleGrid_element0_element0=-1009971319;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element0);\nint obstacleGrid_element0_element1=-1413311285;\nobstacleGrid_element0.push_back(obstacleGrid_element0_element1);\nobstacleGrid.push_back(obstacleGrid_element0);\nvector<int> obstacleGrid_element1;\nint obstacleGrid_element1_element0=273673469;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element0);\nint obstacleGrid_element1_element1=30730250;\nobstacleGrid_element1.push_back(obstacleGrid_element1_element1);\nobstacleGrid.push_back(obstacleGrid_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {         int m = obstacleGrid.size();         int n = obstacleGrid[0].size();         int a[100][100];         for(int i = 0; i < m; i++) {             for(int j = 0; j < n; j++) {                 if(obstacleGrid[i][j] == 1) {                     a[i][j] = 0;                 } else if(i == 0 && j == 0) {                     a[i][j] = 1;                 } else if(i == 0) {                     a[i][j] = a[i][j-1];                 } else if(j == 0) {                     a[i][j] = a[i-1][j];                 } else {                     a[i][j] = a[i-1][j] + a[i][j-1];                 }             }         }         return a[m-1][n-1];     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/15/063. Unique Paths II.cpp/Solution/uniquePathsWithObstacles(vector<vector<int>>&)"
    }
]