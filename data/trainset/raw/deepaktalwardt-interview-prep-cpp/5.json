[
    {
        "f": [],
        "fm": "bool wordBreak(string s, vector<string>& wordDict) {         unordered_set<string> dict(wordDict.begin(), wordDict.end());         int n = s.size();         vector<bool> canBeSegmented(n + 1, false);         canBeSegmented[0] = true;         for (int i = 1; i <= n; i++) {             for (int j = 0; j < i; j++) {                 if (canBeSegmented[j]) {                     string sub = s.substr(j, i - j);                     if (dict.find(sub) != dict.end()) {                         canBeSegmented[i] = true;                         break;                     }                 }             }         }         return canBeSegmented[n];     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_wordBreak_string_vector_string_random_1(void) {\n{\nAKA_test_case_name=\"Solution_wordBreak_string_vector_string_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/139-word-break.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName333801 = new char[2];akaRandomName333801[0] = -114;akaRandomName333801[1] = '\\0';string s=akaRandomName333801;\nvector<string> wordDict;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* VectorDataNode wordDict */\nchar* akaRandomName749923 = new char[2];akaRandomName749923[0] = 73;akaRandomName749923[1] = '\\0';string wordDict_element0=akaRandomName749923;\nwordDict.push_back(wordDict_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_wordBreak_string_vector_string_random_1\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->wordBreak(s,wordDict);\nAKA_fCall++;AKA_mark(\"Return from: ./5/139-word-break.cpp/Solution/wordBreak(string,vector<string>&)\");\n\n\nvector<string> EXPECTED_wordDict;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/139-word-break.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName826833 = new char[2];akaRandomName826833[0] = -114;akaRandomName826833[1] = '\\0';string s=akaRandomName826833;\nvector<string> wordDict;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* VectorDataNode wordDict */\nchar* akaRandomName950596 = new char[2];akaRandomName950596[0] = 73;akaRandomName950596[1] = '\\0';string wordDict_element0=akaRandomName950596;\nwordDict.push_back(wordDict_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     bool wordBreak(string s, vector<string>& wordDict) {         unordered_set<string> dict(wordDict.begin(), wordDict.end());         int n = s.size();         vector<bool> canBeSegmented(n + 1, false);         canBeSegmented[0] = true;         for (int i = 1; i <= n; i++) {             for (int j = 0; j < i; j++) {                 if (canBeSegmented[j]) {                     string sub = s.substr(j, i - j);                     if (dict.find(sub) != dict.end()) {                         canBeSegmented[i] = true;                         break;                     }                 }             }         }         return canBeSegmented[n];     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/139-word-break.cpp/Solution/wordBreak(string,vector<string>&)"
    },
    {
        "f": [],
        "fm": "bool hasCycle(ListNode *head) {         if (head == NULL || head->next == NULL) {             return false;         }         ListNode* fast = head->next;         ListNode* slow = head;         while (slow != fast) {             if (fast == NULL || fast->next == NULL) {                 return false;             }             fast = fast->next->next;             slow = slow->next;         }         return true;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_hasCycle_ListNodemul_random_2(void) {\n{\nAKA_test_case_name=\"Solution_hasCycle_ListNodemul_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/141-linked-list-cycle.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=1823711698;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_0/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next0_x=-2044359822;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_0/head/next/next[0]/next/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode(head0_next0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_hasCycle_ListNodemul_random_2\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->hasCycle(head);\nAKA_fCall++;AKA_mark(\"Return from: ./5/141-linked-list-cycle.cpp/Solution/hasCycle(ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/141-linked-list-cycle.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=1823711698;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_0/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_next0_x=-2044359822;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_0/head/next/next[0]/next/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode(head0_next0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_hasCycle_ListNodemul_random_3(void) {\n{\nAKA_test_case_name=\"Solution_hasCycle_ListNodemul_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/141-linked-list-cycle.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-881549430;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_0/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=35502490;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_1/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head2_x=419142879;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_2/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::ListNode(head2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_hasCycle_ListNodemul_random_3\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->hasCycle(head);\nAKA_fCall++;AKA_mark(\"Return from: ./5/141-linked-list-cycle.cpp/Solution/hasCycle(ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/141-linked-list-cycle.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-881549430;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_0/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=35502490;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_1/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head2_x=419142879;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/141-linked-list-cycle.cpp/hasCycle(ListNode*)/head/AKA_VECTOR_INIT_head_2/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::ListNode(head2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_hasCycle_ListNodemul_random_0(void) {\n{\nAKA_test_case_name=\"Solution_hasCycle_ListNodemul_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/141-linked-list-cycle.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nListNode* head;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_hasCycle_ListNodemul_random_0\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->hasCycle(head);\nAKA_fCall++;AKA_mark(\"Return from: ./5/141-linked-list-cycle.cpp/Solution/hasCycle(ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/141-linked-list-cycle.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nListNode* head;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     bool hasCycle(ListNode *head) {         if (head == NULL || head->next == NULL) {             return false;         }         ListNode* fast = head->next;         ListNode* slow = head;         while (slow != fast) {             if (fast == NULL || fast->next == NULL) {                 return false;             }             fast = fast->next->next;             slow = slow->next;         }         return true;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/141-linked-list-cycle.cpp/Solution/hasCycle(ListNode*)"
    },
    {
        "f": [],
        "fm": "int lengthOfLongestSubstringTwoDistinct(string s) {         unordered_map<char, int> uniqueChars;         int longest = 0;         int N = s.size();         if (N <= 2) return N;         int left = 0;         int right = 0;         while (right < N) {             if (uniqueChars.size() <= 2) {                 uniqueChars[s[right]] = right;             }             if (uniqueChars.size() == 3) {                 auto it = min_element(uniqueChars.begin(), uniqueChars.end(),                                       [](const auto& l, const auto& r) {                                          return l.second < r.second;                                      });                 int leftmost = it->second;                 uniqueChars.erase(s[leftmost]);                 left = leftmost + 1;             }             longest = max(longest, right - left + 1);             right++;         }         return longest;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_lengthOfLongestSubstringTwoDistinct_string_random_0(void) {\n{\nAKA_test_case_name=\"Solution_lengthOfLongestSubstringTwoDistinct_string_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/159-longest-substring-with-two-distinct-chars.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName600447 = new char[2];akaRandomName600447[0] = 12;akaRandomName600447[1] = '\\0';string s=akaRandomName600447;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_lengthOfLongestSubstringTwoDistinct_string_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->lengthOfLongestSubstringTwoDistinct(s);\nAKA_fCall++;AKA_mark(\"Return from: ./5/159-longest-substring-with-two-distinct-chars.cpp/Solution/lengthOfLongestSubstringTwoDistinct(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/159-longest-substring-with-two-distinct-chars.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName765305 = new char[2];akaRandomName765305[0] = 12;akaRandomName765305[1] = '\\0';string s=akaRandomName765305;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int lengthOfLongestSubstringTwoDistinct(string s) {         unordered_map<char, int> uniqueChars;         int longest = 0;         int N = s.size();         if (N <= 2) return N;         int left = 0;         int right = 0;         while (right < N) {             if (uniqueChars.size() <= 2) {                 uniqueChars[s[right]] = right;             }             if (uniqueChars.size() == 3) {                 auto it = min_element(uniqueChars.begin(), uniqueChars.end(),                                       [](const auto& l, const auto& r) {                                          return l.second < r.second;                                      });                 int leftmost = it->second;                 uniqueChars.erase(s[leftmost]);                 left = leftmost + 1;             }             longest = max(longest, right - left + 1);             right++;         }         return longest;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/159-longest-substring-with-two-distinct-chars.cpp/Solution/lengthOfLongestSubstringTwoDistinct(string)"
    },
    {
        "f": [],
        "fm": "bool isOneEditDistance(string s, string t) {         if (s.length() == 0 && t.length() == 0) return false;         if (s.length() == 0 && t.length() == 1 || t.length() == 0 && s.length() == 1) return true;         int lenDiff = s.length() - t.length();         if (abs(lenDiff) > 1) return false;                  int equal = 0; // default: s and t are of equal length         if (s.length() > t.length()) {             equal = -1; // s is longer         } else if (s.length() < t.length()) {             equal = 1; // t is longer         }                  auto it1 = s.begin();         auto it2 = t.begin();                  int numDiff = 0;                  while (it1 != s.end() && it2 != s.end()) {             if (*it1 == *it2) {                 it1++;                 it2++;             } else {                 numDiff++;                 if (equal == 0) {                     it1++;                     it2++;                 } else if (equal == -1) {                     it1++;                 } else if (equal == 1) {                     it2++;                 }                 if (numDiff > 1) {                     return false;                 }                              }         }         if (numDiff == 1 || numDiff == 0 && (it1 != s.end() || it2 != t.end())) {             return true;         }         return false;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_isOneEditDistance_string_string_random_4(void) {\n{\nAKA_test_case_name=\"Solution_isOneEditDistance_string_string_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/161-one-edit-distance.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName550038 = new char[2];akaRandomName550038[0] = 121;akaRandomName550038[1] = '\\0';string s=akaRandomName550038;\nchar* akaRandomName297230 = new char[2];akaRandomName297230[0] = 84;akaRandomName297230[1] = '\\0';string t=akaRandomName297230;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalStringDataNode t */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_isOneEditDistance_string_string_random_4\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->isOneEditDistance(s,t);\nAKA_fCall++;AKA_mark(\"Return from: ./5/161-one-edit-distance.cpp/Solution/isOneEditDistance(string,string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/161-one-edit-distance.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName184839 = new char[2];akaRandomName184839[0] = 121;akaRandomName184839[1] = '\\0';string s=akaRandomName184839;\nchar* akaRandomName712069 = new char[2];akaRandomName712069[0] = 84;akaRandomName712069[1] = '\\0';string t=akaRandomName712069;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalStringDataNode t */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     bool isOneEditDistance(string s, string t) {         if (s.length() == 0 && t.length() == 0) return false;         if (s.length() == 0 && t.length() == 1 || t.length() == 0 && s.length() == 1) return true;         int lenDiff = s.length() - t.length();         if (abs(lenDiff) > 1) return false;                  int equal = 0; // default: s and t are of equal length         if (s.length() > t.length()) {             equal = -1; // s is longer         } else if (s.length() < t.length()) {             equal = 1; // t is longer         }                  auto it1 = s.begin();         auto it2 = t.begin();                  int numDiff = 0;                  while (it1 != s.end() && it2 != s.end()) {             if (*it1 == *it2) {                 it1++;                 it2++;             } else {                 numDiff++;                 if (equal == 0) {                     it1++;                     it2++;                 } else if (equal == -1) {                     it1++;                 } else if (equal == 1) {                     it2++;                 }                 if (numDiff > 1) {                     return false;                 }                              }         }         if (numDiff == 1 || numDiff == 0 && (it1 != s.end() || it2 != t.end())) {             return true;         }         return false;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/161-one-edit-distance.cpp/Solution/isOneEditDistance(string,string)"
    },
    {
        "f": [],
        "fm": "int rob(vector<int>& nums) {         int len = nums.size();         if (len == 0) {             return 0;         }         if (len == 1) {             return nums[0];         }         int prevPrev = nums[0];         int prev = max(nums[0], nums[1]);         for (int i = 2; i < len; i++) {             int curr = max(prev, nums[i] + prevPrev);             prevPrev = prev;             prev = curr;         }         return prev;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_rob_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_rob_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/198-house-robber.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-784076941;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_rob_vector_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->rob(nums);\nAKA_fCall++;AKA_mark(\"Return from: ./5/198-house-robber.cpp/Solution/rob(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/198-house-robber.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-784076941;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_rob_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_rob_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/198-house-robber.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=2001269510;\nnums.push_back(nums_element0);\nint nums_element1=-1096278227;\nnums.push_back(nums_element1);\nint nums_element2=2004363316;\nnums.push_back(nums_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_rob_vector_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->rob(nums);\nAKA_fCall++;AKA_mark(\"Return from: ./5/198-house-robber.cpp/Solution/rob(vector<int>&)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/198-house-robber.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=2001269510;\nnums.push_back(nums_element0);\nint nums_element1=-1096278227;\nnums.push_back(nums_element1);\nint nums_element2=2004363316;\nnums.push_back(nums_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int rob(vector<int>& nums) {         int len = nums.size();         if (len == 0) {             return 0;         }         if (len == 1) {             return nums[0];         }         int prevPrev = nums[0];         int prev = max(nums[0], nums[1]);         for (int i = 2; i < len; i++) {             int curr = max(prev, nums[i] + prevPrev);             prevPrev = prev;             prev = curr;         }         return prev;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/198-house-robber.cpp/Solution/rob(vector<int>&)"
    },
    {
        "f": [],
        "fm": "int exploreIsland(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited) {         int result = 0;         int rows = grid.size();         int cols = 0;         if (rows > 0) cols = grid[0].size();         queue<vector<int>> q;         q.push({i, j});         while (!q.empty()) {             vector<int> front = q.front();             q.pop();             i = front[0];             j = front[1];             if (visited[i][j]) continue;             visited[i][j] = true;             if (grid[i][j] == '1') {                 result = 1;                 if ((i-1 >= 0) && !visited[i-1][j]) q.push({i-1, j});                 if ((i+1 < rows) && !visited[i+1][j]) q.push({i+1, j});                 if ((j-1 >= 0) && !visited[i][j-1]) q.push({i, j-1});                 if ((j+1 < cols) && !visited[i][j+1]) q.push({i, j+1});             }         }         return result;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_exploreIsland_int_int_vector_vector_char_vector_vector_bool_random_0(void) {\n{\nAKA_test_case_name=\"Solution_exploreIsland_int_int_vector_vector_char_vector_vector_bool_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/200-number-of-islands.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint i=-2047393275;\n\n\nint j=-1751772789;\nvector<vector<char>> grid;\nvector<vector<bool>> visited;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode i */\n/* NormalNumberDataNode j */\n/* VectorDataNode grid */\nvector<char> grid_element0;\nchar grid_element0_element0=53;\ngrid_element0.push_back(grid_element0_element0);\nchar grid_element0_element1=-66;\ngrid_element0.push_back(grid_element0_element1);\ngrid.push_back(grid_element0);\nvector<char> grid_element1;\nchar grid_element1_element0=-3;\ngrid_element1.push_back(grid_element1_element0);\ngrid.push_back(grid_element1);\nvector<char> grid_element2;\nchar grid_element2_element0=-123;\ngrid_element2.push_back(grid_element2_element0);\nchar grid_element2_element1=-26;\ngrid_element2.push_back(grid_element2_element1);\nchar grid_element2_element2=108;\ngrid_element2.push_back(grid_element2_element2);\ngrid.push_back(grid_element2);\n/* VectorDataNode visited */\nvector<bool> visited_element0;\nbool visited_element0_element0=false;\nvisited_element0.push_back(visited_element0_element0);\nvisited.push_back(visited_element0);\nvector<bool> visited_element1;\nbool visited_element1_element0=true;\nvisited_element1.push_back(visited_element1_element0);\nbool visited_element1_element1=false;\nvisited_element1.push_back(visited_element1_element1);\nvisited.push_back(visited_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_exploreIsland_int_int_vector_vector_char_vector_vector_bool_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->exploreIsland(i,j,grid,visited);\nAKA_fCall++;AKA_mark(\"Return from: ./5/200-number-of-islands.cpp/Solution/exploreIsland(int,int,vector<vector<char>>&,vector<vector<bool>>&)\");\n\n\nvector<vector<char>> EXPECTED_grid;\n\nvector<vector<bool>> EXPECTED_visited;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/200-number-of-islands.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint i=-2047393275;\n\n\nint j=-1751772789;\nvector<vector<char>> grid;\nvector<vector<bool>> visited;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode i */\n/* NormalNumberDataNode j */\n/* VectorDataNode grid */\nvector<char> grid_element0;\nchar grid_element0_element0=53;\ngrid_element0.push_back(grid_element0_element0);\nchar grid_element0_element1=-66;\ngrid_element0.push_back(grid_element0_element1);\ngrid.push_back(grid_element0);\nvector<char> grid_element1;\nchar grid_element1_element0=-3;\ngrid_element1.push_back(grid_element1_element0);\ngrid.push_back(grid_element1);\nvector<char> grid_element2;\nchar grid_element2_element0=-123;\ngrid_element2.push_back(grid_element2_element0);\nchar grid_element2_element1=-26;\ngrid_element2.push_back(grid_element2_element1);\nchar grid_element2_element2=108;\ngrid_element2.push_back(grid_element2_element2);\ngrid.push_back(grid_element2);\n/* VectorDataNode visited */\nvector<bool> visited_element0;\nbool visited_element0_element0=false;\nvisited_element0.push_back(visited_element0_element0);\nvisited.push_back(visited_element0);\nvector<bool> visited_element1;\nbool visited_element1_element0=true;\nvisited_element1.push_back(visited_element1_element0);\nbool visited_element1_element1=false;\nvisited_element1.push_back(visited_element1_element1);\nvisited.push_back(visited_element1);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int exploreIsland(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited) {         int result = 0;         int rows = grid.size();         int cols = 0;         if (rows > 0) cols = grid[0].size();         queue<vector<int>> q;         q.push({i, j});         while (!q.empty()) {             vector<int> front = q.front();             q.pop();             i = front[0];             j = front[1];             if (visited[i][j]) continue;             visited[i][j] = true;             if (grid[i][j] == '1') {                 result = 1;                 if ((i-1 >= 0) && !visited[i-1][j]) q.push({i-1, j});                 if ((i+1 < rows) && !visited[i+1][j]) q.push({i+1, j});                 if ((j-1 >= 0) && !visited[i][j-1]) q.push({i, j-1});                 if ((j+1 < cols) && !visited[i][j+1]) q.push({i, j+1});             }         }         return result;     }          int numIslands(vector<vector<char>>& grid) {         int result = 0;         int rows = grid.size();         int cols = 0;         if (rows > 0) cols = grid[0].size();         vector<vector<bool>> visited(rows, vector<bool>(cols, false));         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (visited[i][j]) continue;                 if (grid[i][j] == '1') {                     result += exploreIsland(i, j, grid, visited);                 } else {                     visited[i][j] = true;                 }             }         }         return result;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/200-number-of-islands.cpp/Solution/exploreIsland(int,int,vector<vector<char>>&,vector<vector<bool>>&)"
    },
    {
        "f": [],
        "fm": "int numIslands(vector<vector<char>>& grid) {         int result = 0;         int rows = grid.size();         int cols = 0;         if (rows > 0) cols = grid[0].size();         vector<vector<bool>> visited(rows, vector<bool>(cols, false));         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (visited[i][j]) continue;                 if (grid[i][j] == '1') {                     result += exploreIsland(i, j, grid, visited);                 } else {                     visited[i][j] = true;                 }             }         }         return result;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_numIslands_vector_vector_char_random_4(void) {\n{\nAKA_test_case_name=\"Solution_numIslands_vector_vector_char_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/200-number-of-islands.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<char>> grid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode grid */\nvector<char> grid_element0;\nchar grid_element0_element0=-19;\ngrid_element0.push_back(grid_element0_element0);\ngrid.push_back(grid_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_numIslands_vector_vector_char_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->numIslands(grid);\nAKA_fCall++;AKA_mark(\"Return from: ./5/200-number-of-islands.cpp/Solution/numIslands(vector<vector<char>>&)\");\n\n\nvector<vector<char>> EXPECTED_grid;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/200-number-of-islands.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<char>> grid;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode grid */\nvector<char> grid_element0;\nchar grid_element0_element0=-19;\ngrid_element0.push_back(grid_element0_element0);\ngrid.push_back(grid_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int exploreIsland(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited) {         int result = 0;         int rows = grid.size();         int cols = 0;         if (rows > 0) cols = grid[0].size();         queue<vector<int>> q;         q.push({i, j});         while (!q.empty()) {             vector<int> front = q.front();             q.pop();             i = front[0];             j = front[1];             if (visited[i][j]) continue;             visited[i][j] = true;             if (grid[i][j] == '1') {                 result = 1;                 if ((i-1 >= 0) && !visited[i-1][j]) q.push({i-1, j});                 if ((i+1 < rows) && !visited[i+1][j]) q.push({i+1, j});                 if ((j-1 >= 0) && !visited[i][j-1]) q.push({i, j-1});                 if ((j+1 < cols) && !visited[i][j+1]) q.push({i, j+1});             }         }         return result;     }          int numIslands(vector<vector<char>>& grid) {         int result = 0;         int rows = grid.size();         int cols = 0;         if (rows > 0) cols = grid[0].size();         vector<vector<bool>> visited(rows, vector<bool>(cols, false));         for (int i = 0; i < rows; i++) {             for (int j = 0; j < cols; j++) {                 if (visited[i][j]) continue;                 if (grid[i][j] == '1') {                     result += exploreIsland(i, j, grid, visited);                 } else {                     visited[i][j] = true;                 }             }         }         return result;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/200-number-of-islands.cpp/Solution/numIslands(vector<vector<char>>&)"
    },
    {
        "f": [],
        "fm": "ListNode* reverseList(ListNode* head) {         ListNode* p1 = nullptr;         ListNode* p2 = head;         while (p2 != nullptr) {             ListNode* p3 = p2->next;             p2->next = p1;             p1 = p2;             p2 = p3;         }         return p1;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_reverseList_ListNodemul_random_1(void) {\n{\nAKA_test_case_name=\"Solution_reverseList_ListNodemul_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/206-reverse-linked-list.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-646613311;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/206-reverse-linked-list.cpp/reverseList(ListNode*)/head/AKA_VECTOR_INIT_head_0/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=-1975632251;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/206-reverse-linked-list.cpp/reverseList(ListNode*)/head/AKA_VECTOR_INIT_head_1/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_reverseList_ListNodemul_random_1\");ListNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->reverseList(head);\nAKA_fCall++;AKA_mark(\"Return from: ./5/206-reverse-linked-list.cpp/Solution/reverseList(ListNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/206-reverse-linked-list.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head0_x=-646613311;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/206-reverse-linked-list.cpp/reverseList(ListNode*)/head/AKA_VECTOR_INIT_head_0/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int) */\n/* NormalNumberDataNode x */\nint head1_x=-1975632251;\nAKA_mark(\"Calling: ./5/141-linked-list-cycle.cpp/ListNode/ListNode(int)|ROOT/206-reverse-linked-list.cpp/reverseList(ListNode*)/head/AKA_VECTOR_INIT_head_1/head/ListNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     ListNode* reverseList(ListNode* head) {         ListNode* p1 = nullptr;         ListNode* p2 = head;         while (p2 != nullptr) {             ListNode* p3 = p2->next;             p2->next = p1;             p1 = p2;             p2 = p3;         }         return p1;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/206-reverse-linked-list.cpp/Solution/reverseList(ListNode*)"
    },
    {
        "f": [],
        "fm": "bool dfs(int i, vector<bool>& visited, unordered_set<int>& visiting, unordered_map<int, vector<int>>& graph) {         if (visiting.find(i) != visiting.end()) return false;         visiting.emplace(i);         for (int n : graph[i]) {             if (!visited[i]) {                 bool finishPossible = dfs(n, visited, visiting, graph);                 if (!finishPossible) return false;             }         }         visited[i] = true;         visiting.erase(i);         return true;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_dfs_int_vector_bool_unordered_set_int_unordered_map_int_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_dfs_int_vector_bool_unordered_set_int_unordered_map_int_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/207-course-schedule.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint i=1552415750;\nvector<bool> visited;\nunordered_set<int> visiting;\nunordered_map<int, vector<int>> graph;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode i */\n/* VectorDataNode visited */\nbool visited_element0=false;\nvisited.push_back(visited_element0);\nbool visited_element1=true;\nvisited.push_back(visited_element1);\n/* UnorderedSetDataNode visiting */\n/* UnorderedMapDataNode graph */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_dfs_int_vector_bool_unordered_set_int_unordered_map_int_vector_int_random_2\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->dfs(i,visited,visiting,graph);\nAKA_fCall++;AKA_mark(\"Return from: ./5/207-course-schedule.cpp/Solution/dfs(int,vector<bool>&,unordered_set<int>&,unordered_map<int,vector<int>>&)\");\n\n\nvector<bool> EXPECTED_visited;\n\nunordered_set<int> EXPECTED_visiting;\n\nunordered_map<int, vector<int>> EXPECTED_graph;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/207-course-schedule.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint i=1552415750;\nvector<bool> visited;\nunordered_set<int> visiting;\nunordered_map<int, vector<int>> graph;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode i */\n/* VectorDataNode visited */\nbool visited_element0=false;\nvisited.push_back(visited_element0);\nbool visited_element1=true;\nvisited.push_back(visited_element1);\n/* UnorderedSetDataNode visiting */\n/* UnorderedMapDataNode graph */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     bool dfs(int i, vector<bool>& visited, unordered_set<int>& visiting, unordered_map<int, vector<int>>& graph) {         if (visiting.find(i) != visiting.end()) return false;         visiting.emplace(i);         for (int n : graph[i]) {             if (!visited[i]) {                 bool finishPossible = dfs(n, visited, visiting, graph);                 if (!finishPossible) return false;             }         }         visited[i] = true;         visiting.erase(i);         return true;     }          bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {         unordered_map<int, vector<int>> graph;         for (const vector<int>& prereq : prerequisites) {             auto it = graph.find(prereq[0]);             if (it != graph.end()) {                 (it->second).push_back(prereq[1]);             } else {                 graph[prereq[0]] = {prereq[1]};             }         }                  vector<bool> visited(numCourses, false);         unordered_set<int> visiting;                  for (int i = 0; i < numCourses; i++) {             if (!visited[i]) {                 bool finishPossible = dfs(i, visited, visiting, graph);                 if (!finishPossible) return false;             }         }         return true;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/207-course-schedule.cpp/Solution/dfs(int,vector<bool>&,unordered_set<int>&,unordered_map<int,vector<int>>&)"
    },
    {
        "f": [],
        "fm": "bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {         unordered_map<int, vector<int>> graph;         for (const vector<int>& prereq : prerequisites) {             auto it = graph.find(prereq[0]);             if (it != graph.end()) {                 (it->second).push_back(prereq[1]);             } else {                 graph[prereq[0]] = {prereq[1]};             }         }                  vector<bool> visited(numCourses, false);         unordered_set<int> visiting;                  for (int i = 0; i < numCourses; i++) {             if (!visited[i]) {                 bool finishPossible = dfs(i, visited, visiting, graph);                 if (!finishPossible) return false;             }         }         return true;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_canFinish_int_vector_vector_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_canFinish_int_vector_vector_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/207-course-schedule.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint numCourses=7;\nvector<vector<int>> prerequisites;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode numCourses */\n/* VectorDataNode prerequisites */\nvector<int> prerequisites_element0;\nint prerequisites_element0_element0=760254085;\nprerequisites_element0.push_back(prerequisites_element0_element0);\nint prerequisites_element0_element1=1220108382;\nprerequisites_element0.push_back(prerequisites_element0_element1);\nint prerequisites_element0_element2=-170123810;\nprerequisites_element0.push_back(prerequisites_element0_element2);\nprerequisites.push_back(prerequisites_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_canFinish_int_vector_vector_int_random_1\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->canFinish(numCourses,prerequisites);\nAKA_fCall++;AKA_mark(\"Return from: ./5/207-course-schedule.cpp/Solution/canFinish(int,vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_prerequisites;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/207-course-schedule.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\n\n\nint numCourses=7;\nvector<vector<int>> prerequisites;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalNumberDataNode numCourses */\n/* VectorDataNode prerequisites */\nvector<int> prerequisites_element0;\nint prerequisites_element0_element0=760254085;\nprerequisites_element0.push_back(prerequisites_element0_element0);\nint prerequisites_element0_element1=1220108382;\nprerequisites_element0.push_back(prerequisites_element0_element1);\nint prerequisites_element0_element2=-170123810;\nprerequisites_element0.push_back(prerequisites_element0_element2);\nprerequisites.push_back(prerequisites_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     bool dfs(int i, vector<bool>& visited, unordered_set<int>& visiting, unordered_map<int, vector<int>>& graph) {         if (visiting.find(i) != visiting.end()) return false;         visiting.emplace(i);         for (int n : graph[i]) {             if (!visited[i]) {                 bool finishPossible = dfs(n, visited, visiting, graph);                 if (!finishPossible) return false;             }         }         visited[i] = true;         visiting.erase(i);         return true;     }          bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {         unordered_map<int, vector<int>> graph;         for (const vector<int>& prereq : prerequisites) {             auto it = graph.find(prereq[0]);             if (it != graph.end()) {                 (it->second).push_back(prereq[1]);             } else {                 graph[prereq[0]] = {prereq[1]};             }         }                  vector<bool> visited(numCourses, false);         unordered_set<int> visiting;                  for (int i = 0; i < numCourses; i++) {             if (!visited[i]) {                 bool finishPossible = dfs(i, visited, visiting, graph);                 if (!finishPossible) return false;             }         }         return true;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/207-course-schedule.cpp/Solution/canFinish(int,vector<vector<int>>&)"
    },
    {
        "f": [],
        "fm": "int findKthLargest(vector<int>& nums, int k) {         priority_queue<int, vector<int>, greater<int>> min_heap;         for (int i = 0; i < nums.size(); i++) {             if (i < k) {                 min_heap.emplace(nums[i]);             } else {                 if (nums[i] > min_heap.top()) {                     min_heap.pop();                     min_heap.emplace(nums[i]);                 }             }         }         return min_heap.top();     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_findKthLargest_vector_int_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_findKthLargest_vector_int_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/215-kth-largest-element-in-array.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint k=727741533;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=1052499405;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findKthLargest_vector_int_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findKthLargest(nums,k);\nAKA_fCall++;AKA_mark(\"Return from: ./5/215-kth-largest-element-in-array.cpp/Solution/findKthLargest(vector<int>&,int)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/215-kth-largest-element-in-array.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint k=727741533;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=1052499405;\nnums.push_back(nums_element0);\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_findKthLargest_vector_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_findKthLargest_vector_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/215-kth-largest-element-in-array.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint k=-419224365;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-1880432475;\nnums.push_back(nums_element0);\nint nums_element1=1148523953;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findKthLargest_vector_int_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findKthLargest(nums,k);\nAKA_fCall++;AKA_mark(\"Return from: ./5/215-kth-largest-element-in-array.cpp/Solution/findKthLargest(vector<int>&,int)\");\n\n\nvector<int> EXPECTED_nums;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/215-kth-largest-element-in-array.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> nums;\n\n\nint k=-419224365;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode nums */\nint nums_element0=-1880432475;\nnums.push_back(nums_element0);\nint nums_element1=1148523953;\nnums.push_back(nums_element1);\n/* NormalNumberDataNode k */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int findKthLargest(vector<int>& nums, int k) {         priority_queue<int, vector<int>, greater<int>> min_heap;         for (int i = 0; i < nums.size(); i++) {             if (i < k) {                 min_heap.emplace(nums[i]);             } else {                 if (nums[i] > min_heap.top()) {                     min_heap.pop();                     min_heap.emplace(nums[i]);                 }             }         }         return min_heap.top();     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/215-kth-largest-element-in-array.cpp/Solution/findKthLargest(vector<int>&,int)"
    },
    {
        "f": [],
        "fm": "int maximalSquare(vector<vector<char>>& matrix) {         int rows = matrix.size();         if (rows == 0) return 0;         int cols = matrix[0].size();         vector<vector<int>> maxSquareCorner(rows + 1, vector<int>(cols + 1, 0));         int result = 0;         for (int i = 1; i <= rows; i++) {             for (int j = 1; j <= cols; j++) {                 if (matrix[i - 1][j - 1] == '1') {                     maxSquareCorner[i][j] = min(maxSquareCorner[i - 1][j - 1], min(maxSquareCorner[i - 1][j], maxSquareCorner[i][j - 1])) + 1;                     result = max(result, maxSquareCorner[i][j]);                 }             }         }         return result * result;     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maximalSquare_vector_vector_char_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maximalSquare_vector_vector_char_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/221-maximal-square.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<char>> matrix;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode matrix */\nvector<char> matrix_element0;\nchar matrix_element0_element0=101;\nmatrix_element0.push_back(matrix_element0_element0);\nchar matrix_element0_element1=1;\nmatrix_element0.push_back(matrix_element0_element1);\nmatrix.push_back(matrix_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maximalSquare_vector_vector_char_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maximalSquare(matrix);\nAKA_fCall++;AKA_mark(\"Return from: ./5/221-maximal-square.cpp/Solution/maximalSquare(vector<vector<char>>&)\");\n\n\nvector<vector<char>> EXPECTED_matrix;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: /Solution()|ROOT/221-maximal-square.cpp/GLOBAL/AKA_INSTANCE___Solution/AKA_INSTANCE___Solution/Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<char>> matrix;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode matrix */\nvector<char> matrix_element0;\nchar matrix_element0_element0=101;\nmatrix_element0.push_back(matrix_element0_element0);\nchar matrix_element0_element1=1;\nmatrix_element0.push_back(matrix_element0_element1);\nmatrix.push_back(matrix_element0);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution { public:     int maximalSquare(vector<vector<char>>& matrix) {         int rows = matrix.size();         if (rows == 0) return 0;         int cols = matrix[0].size();         vector<vector<int>> maxSquareCorner(rows + 1, vector<int>(cols + 1, 0));         int result = 0;         for (int i = 1; i <= rows; i++) {             for (int j = 1; j <= cols; j++) {                 if (matrix[i - 1][j - 1] == '1') {                     maxSquareCorner[i][j] = min(maxSquareCorner[i - 1][j - 1], min(maxSquareCorner[i - 1][j], maxSquareCorner[i][j - 1])) + 1;                     result = max(result, maxSquareCorner[i][j]);                 }             }         }         return result * result;     } };",
        "c": [
            ""
        ],
        "path_fm": "/mnt/sdb2/LAB/test/5/221-maximal-square.cpp/Solution/maximalSquare(vector<vector<char>>&)"
    }
]