[
    {
        "f": [],
        "fm": "bool is_balanced(TreeNode *root, int &height) {\r     if (NULL == root) {\r       height = 0;\r \r       return true;\r     }\r \r     int left_height;\r     int right_height;\r     bool is_left_balanced = is_balanced(root->left, left_height);\r     bool is_right_balanced = is_balanced(root->right, right_height);\r \r     height = 1 + max(left_height, right_height);\r \r     if (is_left_balanced && is_right_balanced) {\r       return (abs(left_height - right_height) <= 1) ? true : false;\r     }\r     else {\r       return false;\r     }\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_is_balanced_TreeNodemul_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_is_balanced_TreeNodemul_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\balanced_binary_tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-223791407;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-1771152286;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=0;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left2_x=0;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_2 = new ::TreeNode(root0_left2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_2).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_2);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint height=1753246228;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode height */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_is_balanced_TreeNodemul_int_random_1\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->is_balanced(root,height);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\test\\\\balanced_binary_tree.cpp\\\\Solution\\\\is_balanced(TreeNode*,int&)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\balanced_binary_tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-223791407;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-1771152286;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=0;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left2_x=0;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_2 = new ::TreeNode(root0_left2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_2).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_2);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint height=1753246228;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode height */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   bool is_balanced(TreeNode *root, int &height) {\r     if (NULL == root) {\r       height = 0;\r \r       return true;\r     }\r \r     int left_height;\r     int right_height;\r     bool is_left_balanced = is_balanced(root->left, left_height);\r     bool is_right_balanced = is_balanced(root->right, right_height);\r \r     height = 1 + max(left_height, right_height);\r \r     if (is_left_balanced && is_right_balanced) {\r       return (abs(left_height - right_height) <= 1) ? true : false;\r     }\r     else {\r       return false;\r     }\r   }\r \r   bool isBalanced(TreeNode *root) {\r     int height;\r \r     return is_balanced(root, height);\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Lab\\test-cpp\\leetcode\\prj-data\\yingl_LeetCodeInCpp\\test\\balanced_binary_tree.cpp\\Solution\\is_balanced(TreeNode*,int&)"
    },
    {
        "f": [],
        "fm": "bool isBalanced(TreeNode *root) {\r     int height;\r \r     return is_balanced(root, height);\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_isBalanced_TreeNodemul_random_1(void) {\n{\nAKA_test_case_name=\"Solution_isBalanced_TreeNodemul_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\balanced_binary_tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=2070335381;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\isBalanced(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_isBalanced_TreeNodemul_random_1\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->isBalanced(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\test\\\\balanced_binary_tree.cpp\\\\Solution\\\\isBalanced(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\balanced_binary_tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-223791407;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-1771152286;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=0;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left2_x=0;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_2 = new ::TreeNode(root0_left2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_2).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_2);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint height=1753246228;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode height */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   bool is_balanced(TreeNode *root, int &height) {\r     if (NULL == root) {\r       height = 0;\r \r       return true;\r     }\r \r     int left_height;\r     int right_height;\r     bool is_left_balanced = is_balanced(root->left, left_height);\r     bool is_right_balanced = is_balanced(root->right, right_height);\r \r     height = 1 + max(left_height, right_height);\r \r     if (is_left_balanced && is_right_balanced) {\r       return (abs(left_height - right_height) <= 1) ? true : false;\r     }\r     else {\r       return false;\r     }\r   }\r \r   bool isBalanced(TreeNode *root) {\r     int height;\r \r     return is_balanced(root, height);\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Lab\\test-cpp\\leetcode\\prj-data\\yingl_LeetCodeInCpp\\test\\balanced_binary_tree.cpp\\Solution\\isBalanced(TreeNode*)"
    },
    {
        "f": [],
        "fm": "TreeNode* build_tree(vector<int> &inorder,\r       int in_start,\r       int in_end,\r       vector<int> &postorder,\r       int post_start,\r       int post_end) {\r     if (post_start > post_end) {\r       return NULL;\r     }\r     else if (post_start == post_end) {\r       return new TreeNode(postorder[post_start]);\r     }\r \r     int i = 0;\r \r     for ( ; (in_start + i) <= in_end; ++i) {\r       if (inorder[in_start + i] == postorder[post_end]) {\r         break;\r       }\r     }\r \r     TreeNode *root = new TreeNode(postorder[post_end]);\r \r     root->left = build_tree(inorder,\r         in_start,\r         in_end + (i - 1),\r         postorder,\r         post_start,\r         post_start + (i - 1));\r     root->right = build_tree(inorder,\r         in_start + (i + 1),\r         in_end,\r         postorder,\r         post_start + i,\r         post_end - 1);\r \r     return root;\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_build_tree_vector_int_int_int_vector_int_int_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_build_tree_vector_int_int_int_vector_int_int_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\construct_binary_tree_from_inorder_and_postorder_traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> inorder;\n\n\nint in_start=1;\n\n\nint in_end=1;\nvector<int> postorder;\n\n\nint post_start=2110078143;\n\n\nint post_end=-2099836825;\nTreeNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode inorder */\nint inorder_element0=1596716719;\ninorder.push_back(inorder_element0);\n/* NormalNumberDataNode in_start */\n/* NormalNumberDataNode in_end */\n/* VectorDataNode postorder */\nint postorder_element0=-1769298380;\npostorder.push_back(postorder_element0);\nint postorder_element1=-1764758047;\npostorder.push_back(postorder_element1);\n/* NormalNumberDataNode post_start */\n/* NormalNumberDataNode post_end */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_build_tree_vector_int_int_int_vector_int_int_int_random_1\");TreeNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->build_tree(inorder,in_start,in_end,postorder,post_start,post_end);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\test\\\\construct_binary_tree_from_inorder_and_postorder_traversal.cpp\\\\Solution\\\\build_tree(vector<int>&,int,int,vector<int>&,int,int)\");\n\n\nvector<int> EXPECTED_inorder;\n\nvector<int> EXPECTED_postorder;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\balanced_binary_tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-223791407;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-1771152286;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left1_x=0;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode(root0_left1_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left2_x=0;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\is_balanced(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[2]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_2 = new ::TreeNode(root0_left2_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_2).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_2);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint height=1753246228;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode height */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_build_tree_vector_int_int_int_vector_int_int_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_build_tree_vector_int_int_int_vector_int_int_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\construct_binary_tree_from_inorder_and_postorder_traversal.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> inorder;\n\n\nint in_start=0;\n\n\nint in_end=7;\nvector<int> postorder;\n\n\nint post_start=-575527104;\n\n\nint post_end=26872311;\nTreeNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode inorder */\nint inorder_element0=-1163882741;\ninorder.push_back(inorder_element0);\nint inorder_element1=-409523066;\ninorder.push_back(inorder_element1);\nint inorder_element2=1701290225;\ninorder.push_back(inorder_element2);\n/* NormalNumberDataNode in_start */\n/* NormalNumberDataNode in_end */\n/* VectorDataNode postorder */\nint postorder_element0=-1352726722;\npostorder.push_back(postorder_element0);\nint postorder_element1=1694219103;\npostorder.push_back(postorder_element1);\n/* NormalNumberDataNode post_start */\n/* NormalNumberDataNode post_end */\n/* PointerStructureDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_build_tree_vector_int_int_int_vector_int_int_int_random_4\");TreeNode* AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->build_tree(inorder,in_start,in_end,postorder,post_start,post_end);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\test\\\\construct_binary_tree_from_inorder_and_postorder_traversal.cpp\\\\Solution\\\\build_tree(vector<int>&,int,int,vector<int>&,int,int)\");\n\n\nvector<int> EXPECTED_inorder;\n\nvector<int> EXPECTED_postorder;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\balanced_binary_tree.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=2070335381;\nAKA_mark(\"Calling: .\\\\test\\\\balanced_binary_tree.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\balanced_binary_tree.cpp\\\\isBalanced(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   // 参考construct_binary_tree_from_preorder_and_inorder_traversal.cpp\r   TreeNode* build_tree(vector<int> &inorder,\r       int in_start,\r       int in_end,\r       vector<int> &postorder,\r       int post_start,\r       int post_end) {\r     if (post_start > post_end) {\r       return NULL;\r     }\r     else if (post_start == post_end) {\r       return new TreeNode(postorder[post_start]);\r     }\r \r     int i = 0;\r \r     for ( ; (in_start + i) <= in_end; ++i) {\r       if (inorder[in_start + i] == postorder[post_end]) {\r         break;\r       }\r     }\r \r     TreeNode *root = new TreeNode(postorder[post_end]);\r \r     root->left = build_tree(inorder,\r         in_start,\r         in_end + (i - 1),\r         postorder,\r         post_start,\r         post_start + (i - 1));\r     root->right = build_tree(inorder,\r         in_start + (i + 1),\r         in_end,\r         postorder,\r         post_start + i,\r         post_end - 1);\r \r     return root;\r   }\r \r   TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {\r       return build_tree(inorder,\r           0,\r           inorder.size() - 1,\r           postorder,\r           0,\r           postorder.size() - 1); \r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Lab\\test-cpp\\leetcode\\prj-data\\yingl_LeetCodeInCpp\\test\\construct_binary_tree_from_inorder_and_postorder_traversal.cpp\\Solution\\build_tree(vector<int>&,int,int,vector<int>&,int,int)"
    }
]