[
    {
        "f": [],
        "fm": "int ladderLength(string start, string end, unordered_set<string> &dict) {\r     int len = 1;\r     int curr = 0;\r     int next = 1;\r     queue<string> queues[2];\r \r     queues[curr].push(start);\r \r     while (!queues[curr].empty()) {\r       while (!queues[curr].empty()) {\r         string str(queues[curr].front());\r \r         queues[curr].pop();\r \r         for (int i = 0; i < str.size(); ++i) {\r           for (char c = 'a'; c <= 'z'; ++c) {\r             if (c == str[i]) {\r               continue;\r             }\r \r             char tmp = str[i];\r \r             str[i] = c;\r \r             if (str == end) {\r               return len + 1;\r             }\r             else {\r               if (dict.count(str) > 0) {\r                 queues[next].push(str);\r                 dict.erase(str);\r               }\r             }\r \r             str[i] = tmp;\r           }\r         }\r       }\r \r       swap(curr, next);\r       ++len;\r     }\r \r     return 0;\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_ladderLength_string_string_unordered_set_string_random_4(void) {\n{\nAKA_test_case_name=\"Solution_ladderLength_string_string_unordered_set_string_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\word_ladder.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName2731 = new char[2];akaRandomName2731[0] = 107;akaRandomName2731[1] = '\\0';string start=akaRandomName2731;\nchar* akaRandomName247754 = new char[2];akaRandomName247754[0] = -120;akaRandomName247754[1] = '\\0';string end=akaRandomName247754;\nunordered_set<string> dict;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode start */\n/* NormalStringDataNode end */\n/* UnorderedSetDataNode dict */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_ladderLength_string_string_unordered_set_string_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->ladderLength(start,end,dict);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-30\\\\word_ladder.cpp\\\\Solution\\\\ladderLength(string,string,unordered_set<string>&)\");\n\n\nunordered_set<string> EXPECTED_dict;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\word_ladder.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName37977 = new char[2];akaRandomName37977[0] = 107;akaRandomName37977[1] = '\\0';string start=akaRandomName37977;\nchar* akaRandomName444573 = new char[2];akaRandomName444573[0] = -120;akaRandomName444573[1] = '\\0';string end=akaRandomName444573;\nunordered_set<string> dict;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode start */\n/* NormalStringDataNode end */\n/* UnorderedSetDataNode dict */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   // 广度优先搜索\r   int ladderLength(string start, string end, unordered_set<string> &dict) {\r     int len = 1;\r     int curr = 0;\r     int next = 1;\r     queue<string> queues[2];\r \r     queues[curr].push(start);\r \r     while (!queues[curr].empty()) {\r       while (!queues[curr].empty()) {\r         string str(queues[curr].front());\r \r         queues[curr].pop();\r \r         for (int i = 0; i < str.size(); ++i) {\r           for (char c = 'a'; c <= 'z'; ++c) {\r             if (c == str[i]) {\r               continue;\r             }\r \r             char tmp = str[i];\r \r             str[i] = c;\r \r             if (str == end) {\r               return len + 1;\r             }\r             else {\r               if (dict.count(str) > 0) {\r                 queues[next].push(str);\r                 dict.erase(str);\r               }\r             }\r \r             str[i] = tmp;\r           }\r         }\r       }\r \r       swap(curr, next);\r       ++len;\r     }\r \r     return 0;\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Lab\\test-cpp\\leetcode\\prj-data\\yingl_LeetCodeInCpp\\com-30\\word_ladder.cpp\\Solution\\ladderLength(string,string,unordered_set<string>&)"
    },
    {
        "f": [],
        "fm": "void build_ladder(unordered_map<string, vector<string> > &traces,\r       const string &word,\r       vector<string> &ladder,\r       vector<vector<string> > &ladders) {\r     if (0 == traces[word].size()) {\r       ladder.push_back(word);\r \r       vector<string> tmp = ladder;\r \r       reverse(tmp.begin(), tmp.end());\r       ladders.push_back(tmp);\r \r       ladder.pop_back();\r     }\r     else {\r       ladder.push_back(word);\r \r       for (vector<string>::iterator it = traces[word].begin();\r           it != traces[word].end(); ++it) {\r         build_ladder(traces, *it, ladder, ladders);\r       }\r \r       ladder.pop_back();\r     }\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_build_ladder_unordered_map_string_vector_string_string_const_vector_string_vector_vector_string_random_2(void) {\n{\nAKA_test_case_name=\"Solution_build_ladder_unordered_map_string_vector_string_string_const_vector_string_vector_vector_string_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\word_ladder_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nunordered_map<string, vector<string>> traces;\nchar* akaRandomName85067 = new char[2];akaRandomName85067[0] = -44;akaRandomName85067[1] = '\\0';string word=akaRandomName85067;\nvector<string> ladder;\nvector<vector<string>> ladders;\n\n/* RootDataNode STATIC */\n/* UnorderedMapDataNode traces */\n/* NormalStringDataNode word */\n/* VectorDataNode ladder */\nchar* akaRandomName983808 = new char[2];akaRandomName983808[0] = -27;akaRandomName983808[1] = '\\0';string ladder_element0=akaRandomName983808;\nladder.push_back(ladder_element0);\nchar* akaRandomName679773 = new char[2];akaRandomName679773[0] = 17;akaRandomName679773[1] = '\\0';string ladder_element1=akaRandomName679773;\nladder.push_back(ladder_element1);\n/* VectorDataNode ladders */\nvector<string> ladders_element0;\nchar* akaRandomName600650 = new char[2];akaRandomName600650[0] = -109;akaRandomName600650[1] = '\\0';string ladders_element0_element0=akaRandomName600650;\nladders_element0.push_back(ladders_element0_element0);\nchar* akaRandomName20460 = new char[2];akaRandomName20460[0] = -89;akaRandomName20460[1] = '\\0';string ladders_element0_element1=akaRandomName20460;\nladders_element0.push_back(ladders_element0_element1);\nladders.push_back(ladders_element0);\nvector<string> ladders_element1;\nchar* akaRandomName398244 = new char[2];akaRandomName398244[0] = 9;akaRandomName398244[1] = '\\0';string ladders_element1_element0=akaRandomName398244;\nladders_element1.push_back(ladders_element1_element0);\nchar* akaRandomName940318 = new char[2];akaRandomName940318[0] = 5;akaRandomName940318[1] = '\\0';string ladders_element1_element1=akaRandomName940318;\nladders_element1.push_back(ladders_element1_element1);\nchar* akaRandomName201577 = new char[2];akaRandomName201577[0] = -9;akaRandomName201577[1] = '\\0';string ladders_element1_element2=akaRandomName201577;\nladders_element1.push_back(ladders_element1_element2);\nladders.push_back(ladders_element1);\nvector<string> ladders_element2;\nchar* akaRandomName764331 = new char[2];akaRandomName764331[0] = -20;akaRandomName764331[1] = '\\0';string ladders_element2_element0=akaRandomName764331;\nladders_element2.push_back(ladders_element2_element0);\nchar* akaRandomName976462 = new char[2];akaRandomName976462[0] = -86;akaRandomName976462[1] = '\\0';string ladders_element2_element1=akaRandomName976462;\nladders_element2.push_back(ladders_element2_element1);\nchar* akaRandomName97988 = new char[2];akaRandomName97988[0] = 56;akaRandomName97988[1] = '\\0';string ladders_element2_element2=akaRandomName97988;\nladders_element2.push_back(ladders_element2_element2);\nladders.push_back(ladders_element2);\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_build_ladder_unordered_map_string_vector_string_string_const_vector_string_vector_vector_string_random_2\");AKA_INSTANCE___Solution->build_ladder(traces,word,ladder,ladders);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-30\\\\word_ladder_ii.cpp\\\\Solution\\\\build_ladder(unordered_map<string,vector<string>>&,string const&,vector<string>&,vector<vector<string>>&)\");\n\n/* error assertion */\nunordered_map<string, vector<string>> EXPECTED_traces;\n\nvector<string> EXPECTED_ladder;\n\nvector<vector<string>> EXPECTED_ladders;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\word_ladder.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName37977 = new char[2];akaRandomName37977[0] = 107;akaRandomName37977[1] = '\\0';string start=akaRandomName37977;\nchar* akaRandomName444573 = new char[2];akaRandomName444573[0] = -120;akaRandomName444573[1] = '\\0';string end=akaRandomName444573;\nunordered_set<string> dict;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode start */\n/* NormalStringDataNode end */\n/* UnorderedSetDataNode dict */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r protected:\r   void build_ladder(unordered_map<string, vector<string> > &traces,\r       const string &word,\r       vector<string> &ladder,\r       vector<vector<string> > &ladders) {\r     if (0 == traces[word].size()) {\r       ladder.push_back(word);\r \r       vector<string> tmp = ladder;\r \r       reverse(tmp.begin(), tmp.end());\r       ladders.push_back(tmp);\r \r       ladder.pop_back();\r     }\r     else {\r       ladder.push_back(word);\r \r       for (vector<string>::iterator it = traces[word].begin();\r           it != traces[word].end(); ++it) {\r         build_ladder(traces, *it, ladder, ladders);\r       }\r \r       ladder.pop_back();\r     }\r   }\r \r public:\r   // 分层BFS遍历，同时记录前缀，当某一层出现end时结束，生成ladder。\r   vector<vector<string> > findLadders(string start, string end, unordered_set<string> &dict) {\r     vector<vector<string> > ladders;\r     unordered_map<string, vector<string> > traces;\r     unordered_set<string> levels[2];\r     int curr = 0;\r     int prev = 1;\r \r     for (unordered_set<std::string>::iterator it = dict.begin();\r         it != dict.end();\r         ++it) {\r       traces[*it] = vector<string>();\r     }\r \r     levels[curr].insert(start);\r \r     while (true) {\r       swap(curr, prev);\r \r       for (unordered_set<string>::iterator it = levels[prev].begin();\r           it != levels[prev].end();\r           ++it) {\r         dict.erase(*it);\r       }\r \r       levels[curr].clear();\r \r       for (unordered_set<string>::iterator it = levels[prev].begin();\r           it != levels[prev].end();\r           ++it) {\r         for (size_t pos = 0; pos < it->size(); ++pos) {\r           string word = *it;\r \r           for (char c = 'a'; c <= 'z'; ++c) {\r             if (word[pos] == c) {\r               continue;\r             }\r \r             word[pos] = c;\r \r             if ((dict.count(word) > 0) || (word == end)) {\r               traces[word].push_back(*it);\r               levels[curr].insert(word);\r             }\r           }\r         }\r       }\r \r       if (0 == levels[curr].size()) {\r         return ladders;\r       }\r \r       if (levels[curr].count(end) > 0) {\r         break;\r       }\r     }\r \r     vector<string> ladder;\r \r     build_ladder(traces, end, ladder, ladders);\r \r     return ladders;\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Lab\\test-cpp\\leetcode\\prj-data\\yingl_LeetCodeInCpp\\com-30\\word_ladder_ii.cpp\\Solution\\build_ladder(unordered_map<string,vector<string>>&,string const&,vector<string>&,vector<vector<string>>&)"
    },
    {
        "f": [],
        "fm": "vector<vector<string> > findLadders(string start, string end, unordered_set<string> &dict) {\r     vector<vector<string> > ladders;\r     unordered_map<string, vector<string> > traces;\r     unordered_set<string> levels[2];\r     int curr = 0;\r     int prev = 1;\r \r     for (unordered_set<std::string>::iterator it = dict.begin();\r         it != dict.end();\r         ++it) {\r       traces[*it] = vector<string>();\r     }\r \r     levels[curr].insert(start);\r \r     while (true) {\r       swap(curr, prev);\r \r       for (unordered_set<string>::iterator it = levels[prev].begin();\r           it != levels[prev].end();\r           ++it) {\r         dict.erase(*it);\r       }\r \r       levels[curr].clear();\r \r       for (unordered_set<string>::iterator it = levels[prev].begin();\r           it != levels[prev].end();\r           ++it) {\r         for (size_t pos = 0; pos < it->size(); ++pos) {\r           string word = *it;\r \r           for (char c = 'a'; c <= 'z'; ++c) {\r             if (word[pos] == c) {\r               continue;\r             }\r \r             word[pos] = c;\r \r             if ((dict.count(word) > 0) || (word == end)) {\r               traces[word].push_back(*it);\r               levels[curr].insert(word);\r             }\r           }\r         }\r       }\r \r       if (0 == levels[curr].size()) {\r         return ladders;\r       }\r \r       if (levels[curr].count(end) > 0) {\r         break;\r       }\r     }\r \r     vector<string> ladder;\r \r     build_ladder(traces, end, ladder, ladders);\r \r     return ladders;\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_findLadders_string_string_unordered_set_string_random_2(void) {\n{\nAKA_test_case_name=\"Solution_findLadders_string_string_unordered_set_string_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\word_ladder_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName13852 = new char[2];akaRandomName13852[0] = 107;akaRandomName13852[1] = '\\0';string start=akaRandomName13852;\nchar* akaRandomName491335 = new char[2];akaRandomName491335[0] = 85;akaRandomName491335[1] = '\\0';string end=akaRandomName491335;\nunordered_set<string> dict;\nvector<vector<string>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode start */\n/* NormalStringDataNode end */\n/* UnorderedSetDataNode dict */\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findLadders_string_string_unordered_set_string_random_2\");vector<vector<string>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findLadders(start,end,dict);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-30\\\\word_ladder_ii.cpp\\\\Solution\\\\findLadders(string,string,unordered_set<string>&)\");\n\n\nunordered_set<string> EXPECTED_dict;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\word_ladder.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName37977 = new char[2];akaRandomName37977[0] = 107;akaRandomName37977[1] = '\\0';string start=akaRandomName37977;\nchar* akaRandomName444573 = new char[2];akaRandomName444573[0] = -120;akaRandomName444573[1] = '\\0';string end=akaRandomName444573;\nunordered_set<string> dict;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode start */\n/* NormalStringDataNode end */\n/* UnorderedSetDataNode dict */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r protected:\r   void build_ladder(unordered_map<string, vector<string> > &traces,\r       const string &word,\r       vector<string> &ladder,\r       vector<vector<string> > &ladders) {\r     if (0 == traces[word].size()) {\r       ladder.push_back(word);\r \r       vector<string> tmp = ladder;\r \r       reverse(tmp.begin(), tmp.end());\r       ladders.push_back(tmp);\r \r       ladder.pop_back();\r     }\r     else {\r       ladder.push_back(word);\r \r       for (vector<string>::iterator it = traces[word].begin();\r           it != traces[word].end(); ++it) {\r         build_ladder(traces, *it, ladder, ladders);\r       }\r \r       ladder.pop_back();\r     }\r   }\r \r public:\r   // 分层BFS遍历，同时记录前缀，当某一层出现end时结束，生成ladder。\r   vector<vector<string> > findLadders(string start, string end, unordered_set<string> &dict) {\r     vector<vector<string> > ladders;\r     unordered_map<string, vector<string> > traces;\r     unordered_set<string> levels[2];\r     int curr = 0;\r     int prev = 1;\r \r     for (unordered_set<std::string>::iterator it = dict.begin();\r         it != dict.end();\r         ++it) {\r       traces[*it] = vector<string>();\r     }\r \r     levels[curr].insert(start);\r \r     while (true) {\r       swap(curr, prev);\r \r       for (unordered_set<string>::iterator it = levels[prev].begin();\r           it != levels[prev].end();\r           ++it) {\r         dict.erase(*it);\r       }\r \r       levels[curr].clear();\r \r       for (unordered_set<string>::iterator it = levels[prev].begin();\r           it != levels[prev].end();\r           ++it) {\r         for (size_t pos = 0; pos < it->size(); ++pos) {\r           string word = *it;\r \r           for (char c = 'a'; c <= 'z'; ++c) {\r             if (word[pos] == c) {\r               continue;\r             }\r \r             word[pos] = c;\r \r             if ((dict.count(word) > 0) || (word == end)) {\r               traces[word].push_back(*it);\r               levels[curr].insert(word);\r             }\r           }\r         }\r       }\r \r       if (0 == levels[curr].size()) {\r         return ladders;\r       }\r \r       if (levels[curr].count(end) > 0) {\r         break;\r       }\r     }\r \r     vector<string> ladder;\r \r     build_ladder(traces, end, ladder, ladders);\r \r     return ladders;\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Lab\\test-cpp\\leetcode\\prj-data\\yingl_LeetCodeInCpp\\com-30\\word_ladder_ii.cpp\\Solution\\findLadders(string,string,unordered_set<string>&)"
    }
]