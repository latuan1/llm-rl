[
    {
        "f": [],
        "fm": "int maxProfit(vector<int> &prices) {\r     int profit = 0;\r     int size = prices.size();\r     int buy_price = -1;\r     int i;\r \r     for (i = 0; i < (size - 1); ++i) {\r       if (-1 == buy_price) {\r         if (prices[i] < prices[i + 1]) {\r           buy_price = prices[i];\r         }\r         else {\r           continue;\r         }\r       }\r       else {\r         if (prices[i] > prices[i + 1]) {\r           profit += prices[i] - buy_price;\r           buy_price = -1;\r         }\r       }\r     }\r \r     if (buy_price != -1) {\r       profit += prices[i] - buy_price;\r     }\r \r     return profit;\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_0(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-2\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=1905272755;\nprices.push_back(prices_element0);\nint prices_element1=-1587472013;\nprices.push_back(prices_element1);\nint prices_element2=-1625165271;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_3\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-2\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=1905272755;\nprices.push_back(prices_element0);\nint prices_element1=-1587472013;\nprices.push_back(prices_element1);\nint prices_element2=-1625165271;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1733332494;\nprices.push_back(prices_element0);\nint prices_element1=1141720061;\nprices.push_back(prices_element1);\nint prices_element2=1229527842;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-2\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1733332494;\nprices.push_back(prices_element0);\nint prices_element1=1141720061;\nprices.push_back(prices_element1);\nint prices_element2=1229527842;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   int maxProfit(vector<int> &prices) {\r     int profit = 0;\r     int size = prices.size();\r     int buy_price = -1;\r     int i;\r \r     for (i = 0; i < (size - 1); ++i) {\r       if (-1 == buy_price) {\r         if (prices[i] < prices[i + 1]) {\r           buy_price = prices[i];\r         }\r         else {\r           continue;\r         }\r       }\r       else {\r         if (prices[i] > prices[i + 1]) {\r           profit += prices[i] - buy_price;\r           buy_price = -1;\r         }\r       }\r     }\r \r     if (buy_price != -1) {\r       profit += prices[i] - buy_price;\r     }\r \r     return profit;\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Lab\\test-cpp\\leetcode\\prj-data\\yingl_LeetCodeInCpp\\com-2\\best_time_to_buy_and_sell_stock_ii.cpp\\Solution\\maxProfit(vector<int>&)"
    },
    {
        "f": [],
        "fm": "int maxProfit(vector<int> &prices) {\r     if (prices.size() <= 1) {\r       return 0;\r     }\r \r     int max_profit = 0;\r     int max_profit_1 = 0;\r     int max_profit_2 = 0;\r     int size = prices.size();\r     int min_price = prices[0];\r     int max_price = prices[size - 1];\r     vector<int> profits(size, 0);\r     int i;\r \r     for (i = 1; i < size; ++i) {\r       int profit = prices[i] - min_price;\r \r       if (profit < 0) {\r         min_price = prices[i];\r       }\r       else {\r         if (profit > max_profit_1) {\r           max_profit_1 = profit;\r         }\r       }\r \r       profits[i] = max_profit_1;\r     }\r \r     // 从后向前，搜索第2次交易的机会。这样可以利用第一次的成果！\r     for (i = size - 2; i >= 0; --i) {\r       int profit = max_price - prices[i];\r \r       if (profit < 0) {\r         max_price = prices[i];\r       }\r       else {\r         if (profit > max_profit_2) {\r           max_profit_2 = profit;\r         }\r \r         if ((max_profit_2 + profits[i]) > max_profit) {\r           max_profit = max_profit_2 + profits[i];\r         }\r       }\r     }\r \r     return max_profit;\r   }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_directed_1(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_directed_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_iii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* element #0 : null value -> no code */\nprices.push_back(prices_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_directed_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-2\\\\best_time_to_buy_and_sell_stock_iii.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_iii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=1246984589;\nprices.push_back(prices_element0);\nint prices_element1=-1113141865;\nprices.push_back(prices_element1);\nint prices_element2=1365590622;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-2\\\\best_time_to_buy_and_sell_stock_iii.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=1905272755;\nprices.push_back(prices_element0);\nint prices_element1=-1587472013;\nprices.push_back(prices_element1);\nint prices_element2=-1625165271;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 2,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_iii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-104835368;\nprices.push_back(prices_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\com-2\\\\best_time_to_buy_and_sell_stock_iii.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\best_time_to_buy_and_sell_stock_ii.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=-1733332494;\nprices.push_back(prices_element0);\nint prices_element1=1141720061;\nprices.push_back(prices_element1);\nint prices_element2=1229527842;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   int maxProfit(vector<int> &prices) {\r     if (prices.size() <= 1) {\r       return 0;\r     }\r \r     int max_profit = 0;\r     int max_profit_1 = 0;\r     int max_profit_2 = 0;\r     int size = prices.size();\r     int min_price = prices[0];\r     int max_price = prices[size - 1];\r     vector<int> profits(size, 0);\r     int i;\r \r     for (i = 1; i < size; ++i) {\r       int profit = prices[i] - min_price;\r \r       if (profit < 0) {\r         min_price = prices[i];\r       }\r       else {\r         if (profit > max_profit_1) {\r           max_profit_1 = profit;\r         }\r       }\r \r       profits[i] = max_profit_1;\r     }\r \r     // 从后向前，搜索第2次交易的机会。这样可以利用第一次的成果！\r     for (i = size - 2; i >= 0; --i) {\r       int profit = max_price - prices[i];\r \r       if (profit < 0) {\r         max_price = prices[i];\r       }\r       else {\r         if (profit > max_profit_2) {\r           max_profit_2 = profit;\r         }\r \r         if ((max_profit_2 + profits[i]) > max_profit) {\r           max_profit = max_profit_2 + profits[i];\r         }\r       }\r     }\r \r     return max_profit;\r   }\r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Lab\\test-cpp\\leetcode\\prj-data\\yingl_LeetCodeInCpp\\com-2\\best_time_to_buy_and_sell_stock_iii.cpp\\Solution\\maxProfit(vector<int>&)"
    }
]