[
    {
        "f": [],
        "fm": "int maxNumberOfApples(vector<int>& a) {\r         \r         int res = 0;\r         int n = a.size();\r         \r         sort(a.begin(), a.end());\r         int sum = 0;\r         \r         for(auto &x : a) {\r             \r             sum += x;\r             \r             if(sum <= 5000)                                 res++;\r             else                                            break;\r         }\r         \r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxNumberOfApples_vector_int_random_1(void) {\n{\nAKA_test_case_name=\"Solution_maxNumberOfApples_vector_int_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1196-how-many-apples-can-you-put-into-the-basket.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> a;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode a */\nint a_element0=972264991;\na.push_back(a_element0);\nint a_element1=1174248321;\na.push_back(a_element1);\nint a_element2=-210569922;\na.push_back(a_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxNumberOfApples_vector_int_random_1\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxNumberOfApples(a);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p20\\\\1196-how-many-apples-can-you-put-into-the-basket\\\\1196-how-many-apples-can-you-put-into-the-basket.cpp\\\\Solution\\\\maxNumberOfApples(vector<int>&)\");\n\n\nvector<int> EXPECTED_a;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1165-single-row-keyboard.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName235633 = new char[2];akaRandomName235633[0] = 105;akaRandomName235633[1] = '\\0';string keyboard=akaRandomName235633;\nchar* akaRandomName469141 = new char[2];akaRandomName469141[0] = -18;akaRandomName469141[1] = '\\0';string word=akaRandomName469141;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode keyboard */\n/* NormalStringDataNode word */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r    \r     int maxNumberOfApples(vector<int>& a) {\r         \r         int res = 0;\r         int n = a.size();\r         \r         sort(a.begin(), a.end());\r         int sum = 0;\r         \r         for(auto &x : a) {\r             \r             sum += x;\r             \r             if(sum <= 5000)                                 res++;\r             else                                            break;\r         }\r         \r         return res;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p20\\1196-how-many-apples-can-you-put-into-the-basket\\1196-how-many-apples-can-you-put-into-the-basket.cpp\\Solution\\maxNumberOfApples(vector<int>&)"
    },
    {
        "f": [],
        "fm": "int smallestCommonElement(vector<vector<int>>& mat) {\r     \r         int n = mat.size();\r         int m = mat[0].size();\r         \r         map<int, int> mp;\r         \r         for(int i=0; i<n; i++) {\r             \r             map<int, int> u;\r             \r             for(int j=0; j<m; j++)                              u[mat[i][j]]++;                \r             \r             for(auto &x : u) {\r                \r                 if(x.second >= 1)                               mp[x.first]++;\r                 if(mp[x.first] == n)                            return x.first;\r             }\r         }\r         \r         return -1;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_smallestCommonElement_vector_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_smallestCommonElement_vector_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1198-find-smallest-common-element-in-all-rows.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> mat;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode mat */\nvector<int> mat_element0;\nint mat_element0_element0=1425332934;\nmat_element0.push_back(mat_element0_element0);\nint mat_element0_element1=1575682457;\nmat_element0.push_back(mat_element0_element1);\nmat.push_back(mat_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_smallestCommonElement_vector_vector_int_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->smallestCommonElement(mat);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p20\\\\1198-find-smallest-common-element-in-all-rows\\\\1198-find-smallest-common-element-in-all-rows.cpp\\\\Solution\\\\smallestCommonElement(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_mat;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1165-single-row-keyboard.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName235633 = new char[2];akaRandomName235633[0] = 105;akaRandomName235633[1] = '\\0';string keyboard=akaRandomName235633;\nchar* akaRandomName469141 = new char[2];akaRandomName469141[0] = -18;akaRandomName469141[1] = '\\0';string word=akaRandomName469141;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode keyboard */\n/* NormalStringDataNode word */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_smallestCommonElement_vector_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_smallestCommonElement_vector_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1198-find-smallest-common-element-in-all-rows.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> mat;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode mat */\nvector<int> mat_element0;\nint mat_element0_element0=-1311850801;\nmat_element0.push_back(mat_element0_element0);\nmat.push_back(mat_element0);\nvector<int> mat_element1;\nint mat_element1_element0=-1618103262;\nmat_element1.push_back(mat_element1_element0);\nmat.push_back(mat_element1);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_smallestCommonElement_vector_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->smallestCommonElement(mat);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p20\\\\1198-find-smallest-common-element-in-all-rows\\\\1198-find-smallest-common-element-in-all-rows.cpp\\\\Solution\\\\smallestCommonElement(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_mat;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head0_x=-996019834;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head0_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode() */\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode()|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int,ListNode*)\\\\next\\\\next[0]\\\\next\\\\ListNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_head0_next_0 = new ::ListNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head0_next_0).next;\nAKA_VECTOR_INIT_head0_next.push_back(AKA_VECTOR_INIT_head0_next_0);\nListNode* head0_next = AKA_VECTOR_INIT_head0_next[0];\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x,head0_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode() */\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode()|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[0]\\\\next\\\\ListNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head1_x=0;\n/* PointerStructureDataNode next */\nListNode* head1_next;\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x,head1_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head2_x=0;\n/* PointerStructureDataNode next */\nListNode* head2_next;\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_2\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::ListNode(head2_x,head2_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     int smallestCommonElement(vector<vector<int>>& mat) {\r     \r         int n = mat.size();\r         int m = mat[0].size();\r         \r         map<int, int> mp;\r         \r         for(int i=0; i<n; i++) {\r             \r             map<int, int> u;\r             \r             for(int j=0; j<m; j++)                              u[mat[i][j]]++;                \r             \r             for(auto &x : u) {\r                \r                 if(x.second >= 1)                               mp[x.first]++;\r                 if(mp[x.first] == n)                            return x.first;\r             }\r         }\r         \r         return -1;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p20\\1198-find-smallest-common-element-in-all-rows\\1198-find-smallest-common-element-in-all-rows.cpp\\Solution\\smallestCommonElement(vector<vector<int>>&)"
    },
    {
        "f": [],
        "fm": "int maxProfit(vector<int>& prices) {\r     \r         int n = prices.size();\r         \r         if(n <= 1)                          return 0;\r         \r         int maxi = 0;\r         int minLeft = prices[0];            // Min prices from left side\r         \r         for(int i=1; i<n; i++) {\r             maxi = max(maxi, prices[i] - minLeft);\r             minLeft = min(minLeft, prices[i]);\r         }        \r         \r         return maxi;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_4(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_4\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\121-best-time-to-buy-and-sell-stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=44166762;\nprices.push_back(prices_element0);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_4\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p20\\\\121-best-time-to-buy-and-sell-stock\\\\121-best-time-to-buy-and-sell-stock.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1165-single-row-keyboard.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName235633 = new char[2];akaRandomName235633[0] = 105;akaRandomName235633[1] = '\\0';string keyboard=akaRandomName235633;\nchar* akaRandomName469141 = new char[2];akaRandomName469141[0] = -18;akaRandomName469141[1] = '\\0';string word=akaRandomName469141;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode keyboard */\n/* NormalStringDataNode word */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_maxProfit_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_maxProfit_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\121-best-time-to-buy-and-sell-stock.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> prices;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode prices */\nint prices_element0=1617407082;\nprices.push_back(prices_element0);\nint prices_element1=424837491;\nprices.push_back(prices_element1);\nint prices_element2=-992403470;\nprices.push_back(prices_element2);\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_maxProfit_vector_int_random_0\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->maxProfit(prices);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p20\\\\121-best-time-to-buy-and-sell-stock\\\\121-best-time-to-buy-and-sell-stock.cpp\\\\Solution\\\\maxProfit(vector<int>&)\");\n\n\nvector<int> EXPECTED_prices;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head0_x=-996019834;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head0_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode() */\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode()|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int,ListNode*)\\\\next\\\\next[0]\\\\next\\\\ListNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_head0_next_0 = new ::ListNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head0_next_0).next;\nAKA_VECTOR_INIT_head0_next.push_back(AKA_VECTOR_INIT_head0_next_0);\nListNode* head0_next = AKA_VECTOR_INIT_head0_next[0];\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x,head0_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode() */\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode()|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[0]\\\\next\\\\ListNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head1_x=0;\n/* PointerStructureDataNode next */\nListNode* head1_next;\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x,head1_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head2_x=0;\n/* PointerStructureDataNode next */\nListNode* head2_next;\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_2\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::ListNode(head2_x,head2_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     int maxProfit(vector<int>& prices) {\r     \r         int n = prices.size();\r         \r         if(n <= 1)                          return 0;\r         \r         int maxi = 0;\r         int minLeft = prices[0];            // Min prices from left side\r         \r         for(int i=1; i<n; i++) {\r             maxi = max(maxi, prices[i] - minLeft);\r             minLeft = min(minLeft, prices[i]);\r         }        \r         \r         return maxi;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p20\\121-best-time-to-buy-and-sell-stock\\121-best-time-to-buy-and-sell-stock.cpp\\Solution\\maxProfit(vector<int>&)"
    },
    {
        "f": [],
        "fm": "vector<int> arraysIntersection(vector<int>& a1, vector<int>& a2, vector<int>& a3) {\r     \r         vector<int> res;\r         \r         int i = a1.size() - 1;\r         int j = a2.size() - 1;\r         int k = a3.size() - 1;\r         \r         while(i >= 0 && j >= 0 && k >= 0) {\r             \r            if(a1[i] > a2[j] || a1[i] > a3[k])                              i--;\r            else if(a2[j] > a3[k] || a2[j] > a1[i])                         j--;\r            else if(a3[k] > a1[i] || a3[k] > a2[j])                         k--;\r           \r            else {\r                \r                res.push_back(a1[i]);\r                \r                i--;\r                j--;\r                k--;\r            }\r         }\r         \r         reverse(res.begin(), res.end());\r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_arraysIntersection_vector_int_vector_int_vector_int_random_2(void) {\n{\nAKA_test_case_name=\"Solution_arraysIntersection_vector_int_vector_int_vector_int_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1213-intersection-of-three-sorted-arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> a1;\nvector<int> a2;\nvector<int> a3;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode a1 */\nint a1_element0=1773288191;\na1.push_back(a1_element0);\nint a1_element1=-1848372220;\na1.push_back(a1_element1);\n/* VectorDataNode a2 */\nint a2_element0=-289562305;\na2.push_back(a2_element0);\n/* VectorDataNode a3 */\nint a3_element0=710277297;\na3.push_back(a3_element0);\nint a3_element1=518740012;\na3.push_back(a3_element1);\nint a3_element2=-1140066175;\na3.push_back(a3_element2);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_arraysIntersection_vector_int_vector_int_vector_int_random_2\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->arraysIntersection(a1,a2,a3);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p20\\\\1213-intersection-of-three-sorted-arrays\\\\1213-intersection-of-three-sorted-arrays.cpp\\\\Solution\\\\arraysIntersection(vector<int>&,vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_a1;\n\nvector<int> EXPECTED_a2;\n\nvector<int> EXPECTED_a3;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1165-single-row-keyboard.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName235633 = new char[2];akaRandomName235633[0] = 105;akaRandomName235633[1] = '\\0';string keyboard=akaRandomName235633;\nchar* akaRandomName469141 = new char[2];akaRandomName469141[0] = -18;akaRandomName469141[1] = '\\0';string word=akaRandomName469141;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode keyboard */\n/* NormalStringDataNode word */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            },
            {
                "id": 1,
                "dt": {},
                "td": "void AKA_TEST_Solution_arraysIntersection_vector_int_vector_int_vector_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_arraysIntersection_vector_int_vector_int_vector_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1213-intersection-of-three-sorted-arrays.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<int> a1;\nvector<int> a2;\nvector<int> a3;\nvector<int> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode a1 */\nint a1_element0=-703479029;\na1.push_back(a1_element0);\nint a1_element1=1989785316;\na1.push_back(a1_element1);\n/* VectorDataNode a2 */\nint a2_element0=-673171125;\na2.push_back(a2_element0);\nint a2_element1=613918332;\na2.push_back(a2_element1);\n/* VectorDataNode a3 */\nint a3_element0=-1505689288;\na3.push_back(a3_element0);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_arraysIntersection_vector_int_vector_int_vector_int_random_0\");vector<int> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->arraysIntersection(a1,a2,a3);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p20\\\\1213-intersection-of-three-sorted-arrays\\\\1213-intersection-of-three-sorted-arrays.cpp\\\\Solution\\\\arraysIntersection(vector<int>&,vector<int>&,vector<int>&)\");\n\n\nvector<int> EXPECTED_a1;\n\nvector<int> EXPECTED_a2;\n\nvector<int> EXPECTED_a3;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<ListNode*> AKA_VECTOR_INIT_head;\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head0_x=-996019834;\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head0_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode() */\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode()|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int,ListNode*)\\\\next\\\\next[0]\\\\next\\\\ListNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_head0_next_0 = new ::ListNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head0_next_0).next;\nAKA_VECTOR_INIT_head0_next.push_back(AKA_VECTOR_INIT_head0_next_0);\nListNode* head0_next = AKA_VECTOR_INIT_head0_next[0];\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0 = new ::ListNode(head0_x,head0_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\nstd::vector<ListNode*> AKA_VECTOR_INIT_head_0_DOT_next;\n/* SubStructDataNode next */\n/* ConstructorDataNode ListNode() */\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode()|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_0\\\\head\\\\next\\\\next[0]\\\\next\\\\ListNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_head_0_DOT_next_0 = new ::ListNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_0_DOT_next_0).next;\nAKA_VECTOR_INIT_head_0_DOT_next.push_back(AKA_VECTOR_INIT_head_0_DOT_next_0);\n(*AKA_VECTOR_INIT_head_0).next = AKA_VECTOR_INIT_head_0_DOT_next[0];\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_0);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head1_x=0;\n/* PointerStructureDataNode next */\nListNode* head1_next;\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_1\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_1 = new ::ListNode(head1_x,head1_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_1).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_1);\n\n\n/* SubStructDataNode head */\n/* ConstructorDataNode ListNode(int,ListNode*) */\n/* NormalNumberDataNode x */\nint head2_x=0;\n/* PointerStructureDataNode next */\nListNode* head2_next;\nAKA_mark(\"Calling: .\\\\p19\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\ListNode\\\\ListNode(int,ListNode*)|ROOT\\\\1171-remove-zero-sum-consecutive-nodes-from-linked-list.cpp\\\\removeZeroSumSublists(ListNode*)\\\\head\\\\AKA_VECTOR_INIT_head_2\\\\head\\\\ListNode(int,ListNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_head_2 = new ::ListNode(head2_x,head2_next);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode next */\n(*AKA_VECTOR_INIT_head_2).next;\n\nAKA_VECTOR_INIT_head.push_back(AKA_VECTOR_INIT_head_2);\n\nListNode* head = AKA_VECTOR_INIT_head[0];\nListNode* AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode head */\n/* PointerStructureDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     vector<int> arraysIntersection(vector<int>& a1, vector<int>& a2, vector<int>& a3) {\r     \r         vector<int> res;\r         \r         int i = a1.size() - 1;\r         int j = a2.size() - 1;\r         int k = a3.size() - 1;\r         \r         while(i >= 0 && j >= 0 && k >= 0) {\r             \r            if(a1[i] > a2[j] || a1[i] > a3[k])                              i--;\r            else if(a2[j] > a3[k] || a2[j] > a1[i])                         j--;\r            else if(a3[k] > a1[i] || a3[k] > a2[j])                         k--;\r           \r            else {\r                \r                res.push_back(a1[i]);\r                \r                i--;\r                j--;\r                k--;\r            }\r         }\r         \r         reverse(res.begin(), res.end());\r         return res;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p20\\1213-intersection-of-three-sorted-arrays\\1213-intersection-of-three-sorted-arrays.cpp\\Solution\\arraysIntersection(vector<int>&,vector<int>&,vector<int>&)"
    },
    {
        "f": [],
        "fm": "bool twoSumBSTs(TreeNode* root1, TreeNode* root2, int target) {\r     \r         if(root1 == NULL && root2 == NULL)                                      return false;\r         \r         vector<int> res1, res2;\r         \r         // Inorder of BST gives us sorted array\r         \r         inorder(root1, res1);\r         inorder(root2, res2);\r         \r         int i = 0, j = res2.size() - 1;\r         \r         while(i < res1.size() && j >= 0) {\r             \r             if(res1[i] + res2[j] == target)                            return true;\r             else if(res1[i] + res2[j] > target)                        j--;\r             else if(res1[i] + res2[j] < target)                        i++;\r         }\r         \r         return false;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_twoSumBSTs_TreeNodemul_TreeNodemul_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_twoSumBSTs_TreeNodemul_TreeNodemul_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1214-two-sum-bsts.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root1;\n\n\n/* SubStructDataNode root1 */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p20\\\\1214-two-sum-bsts\\\\1214-two-sum-bsts.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\1214-two-sum-bsts.cpp\\\\twoSumBSTs(TreeNode*,TreeNode*,int)\\\\root1\\\\AKA_VECTOR_INIT_root1_0\\\\root1\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root1_0 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root1_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root1_0).right;\n\nAKA_VECTOR_INIT_root1.push_back(AKA_VECTOR_INIT_root1_0);\n\nTreeNode* root1 = AKA_VECTOR_INIT_root1[0];\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root2;\n\n\n/* SubStructDataNode root2 */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p20\\\\1214-two-sum-bsts\\\\1214-two-sum-bsts.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\1214-two-sum-bsts.cpp\\\\twoSumBSTs(TreeNode*,TreeNode*,int)\\\\root2\\\\AKA_VECTOR_INIT_root2_0\\\\root2\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root2_0 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root2_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root2_0).right;\n\nAKA_VECTOR_INIT_root2.push_back(AKA_VECTOR_INIT_root2_0);\n\nTreeNode* root2 = AKA_VECTOR_INIT_root2[0];\n\n\nint target=-1133083598;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root1 */\n/* PointerStructureDataNode root2 */\n/* NormalNumberDataNode target */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_twoSumBSTs_TreeNodemul_TreeNodemul_int_random_3\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->twoSumBSTs(root1,root2,target);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p20\\\\1214-two-sum-bsts\\\\1214-two-sum-bsts.cpp\\\\Solution\\\\twoSumBSTs(TreeNode*,TreeNode*,int)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\1165-single-row-keyboard.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName235633 = new char[2];akaRandomName235633[0] = 105;akaRandomName235633[1] = '\\0';string keyboard=akaRandomName235633;\nchar* akaRandomName469141 = new char[2];akaRandomName469141[0] = -18;akaRandomName469141[1] = '\\0';string word=akaRandomName469141;\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode keyboard */\n/* NormalStringDataNode word */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r   \r     void inorder(TreeNode* root, vector<int> &res) {\r         \r         if(root == NULL)                                                        return;\r         \r         // inorder means left -> root -> right\r         \r         inorder(root->left, res);\r         res.push_back(root->val);\r         inorder(root->right, res);\r         \r         return;\r     }\r     \r     bool twoSumBSTs(TreeNode* root1, TreeNode* root2, int target) {\r     \r         if(root1 == NULL && root2 == NULL)                                      return false;\r         \r         vector<int> res1, res2;\r         \r         // Inorder of BST gives us sorted array\r         \r         inorder(root1, res1);\r         inorder(root2, res2);\r         \r         int i = 0, j = res2.size() - 1;\r         \r         while(i < res1.size() && j >= 0) {\r             \r             if(res1[i] + res2[j] == target)                            return true;\r             else if(res1[i] + res2[j] > target)                        j--;\r             else if(res1[i] + res2[j] < target)                        i++;\r         }\r         \r         return false;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "D:\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p20\\1214-two-sum-bsts\\1214-two-sum-bsts.cpp\\Solution\\twoSumBSTs(TreeNode*,TreeNode*,int)"
    }
]