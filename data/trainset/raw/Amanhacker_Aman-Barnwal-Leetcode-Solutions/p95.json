[
    {
        "f": [],
        "fm": "bool checkRecord(string s) {\r     \r         int n = s.length();\r         int abs = 0;\r         \r         for(int i=0; i<n; i++) {\r             \r             if(s[i] == 'A')                               abs++;\r             \r             else if(s[i] == 'L') {\r                 \r                 int late = 1;\r                 \r                 while(i + 1 < n && s[i] == s[i+1]) {\r                     late++;\r                     i++;\r                 }\r                 \r                 if(late >= 3)                             return false;\r             }\r         }\r         \r         if(abs >= 2)                                      return false;        \r         \r         return true;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_checkRecord_string_random_1(void) {\n{\nAKA_test_case_name=\"Solution_checkRecord_string_random_1\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\551-student-attendance-record-i.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName999418 = new char[2];akaRandomName999418[0] = 120;akaRandomName999418[1] = '\\0';string s=akaRandomName999418;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_checkRecord_string_random_1\");bool AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->checkRecord(s);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p95\\\\551-student-attendance-record-i\\\\551-student-attendance-record-i.cpp\\\\Solution\\\\checkRecord(string)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\551-student-attendance-record-i.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nchar* akaRandomName947013 = new char[2];akaRandomName947013[0] = 120;akaRandomName947013[1] = '\\0';string s=akaRandomName947013;\n\n\nbool AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* NormalStringDataNode s */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     bool checkRecord(string s) {\r     \r         int n = s.length();\r         int abs = 0;\r         \r         for(int i=0; i<n; i++) {\r             \r             if(s[i] == 'A')                               abs++;\r             \r             else if(s[i] == 'L') {\r                 \r                 int late = 1;\r                 \r                 while(i + 1 < n && s[i] == s[i+1]) {\r                     late++;\r                     i++;\r                 }\r                 \r                 if(late >= 3)                             return false;\r             }\r         }\r         \r         if(abs >= 2)                                      return false;        \r         \r         return true;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p95\\551-student-attendance-record-i\\551-student-attendance-record-i.cpp\\Solution\\checkRecord(string)"
    },
    {
        "f": [],
        "fm": "vector<vector<int>> merge(vector<vector<int>>& v) {\r     \r         vector<vector<int>> res;\r         int n = v.size();\r         \r         if(n == 0)                                return res;\r         \r         sort(v.begin(), v.end());\r         \r         res.push_back(v[0]);\r         \r         int j = 0;\r         \r         for(int i=1; i<n; i++) {\r             \r             // If intervals are overlapping\r             if(res[j][1] >= v[i][0])                 res[j][1] = max(res[j][1], v[i][1]);\r             \r             else {\r                 \r                 res.push_back(v[i]);\r                 j++;\r             }\r         }\r         \r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_merge_vector_vector_int_random_3(void) {\n{\nAKA_test_case_name=\"Solution_merge_vector_vector_int_random_3\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\56-merge-intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> v;\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode v */\nvector<int> v_element0;\nint v_element0_element0=384517499;\nv_element0.push_back(v_element0_element0);\nv.push_back(v_element0);\nvector<int> v_element1;\nint v_element1_element0=1105050101;\nv_element1.push_back(v_element1_element0);\nint v_element1_element1=-1458291059;\nv_element1.push_back(v_element1_element1);\nint v_element1_element2=1001360780;\nv_element1.push_back(v_element1_element2);\nv.push_back(v_element1);\n/* VectorDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_merge_vector_vector_int_random_3\");vector<vector<int>> AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->merge(v);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p95\\\\56-merge-intervals\\\\56-merge-intervals.cpp\\\\Solution\\\\merge(vector<vector<int>>&)\");\n\n\nvector<vector<int>> EXPECTED_v;\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\56-merge-intervals.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nvector<vector<int>> v;\nvector<vector<int>> AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* VectorDataNode v */\nvector<int> v_element0;\nint v_element0_element0=384517499;\nv_element0.push_back(v_element0_element0);\nv.push_back(v_element0);\nvector<int> v_element1;\nint v_element1_element0=1105050101;\nv_element1.push_back(v_element1_element0);\nint v_element1_element1=-1458291059;\nv_element1.push_back(v_element1_element1);\nint v_element1_element2=1001360780;\nv_element1.push_back(v_element1_element2);\nv.push_back(v_element1);\n/* VectorDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r     \r     vector<vector<int>> merge(vector<vector<int>>& v) {\r     \r         vector<vector<int>> res;\r         int n = v.size();\r         \r         if(n == 0)                                return res;\r         \r         sort(v.begin(), v.end());\r         \r         res.push_back(v[0]);\r         \r         int j = 0;\r         \r         for(int i=1; i<n; i++) {\r             \r             // If intervals are overlapping\r             if(res[j][1] >= v[i][0])                 res[j][1] = max(res[j][1], v[i][1]);\r             \r             else {\r                 \r                 res.push_back(v[i]);\r                 j++;\r             }\r         }\r         \r         return res;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p95\\56-merge-intervals\\56-merge-intervals.cpp\\Solution\\merge(vector<vector<int>>&)"
    },
    {
        "f": [],
        "fm": "void dfs(TreeNode* root, int &sum) {\r         \r         if(root == NULL)                        return;\r         \r         int temp = 0, t = 0;\r         \r         // For every node\r         sumAllNodes(root->left, t);\r         temp = t;\r         \r         t = 0;\r         \r         sumAllNodes(root->right, t);\r         temp = abs(temp - t);\r         \r         sum += temp;\r         \r         dfs(root->left, sum);\r         dfs(root->right, sum);\r         \r         return;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_dfs_TreeNodemul_int_random_0(void) {\n{\nAKA_test_case_name=\"Solution_dfs_TreeNodemul_int_random_0\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\563-binary-tree-tilt.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-850535950;\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\563-binary-tree-tilt.cpp\\\\dfs(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-210272685;\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\563-binary-tree-tilt.cpp\\\\dfs(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\563-binary-tree-tilt.cpp\\\\dfs(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint sum=-663151992;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode sum */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_dfs_TreeNodemul_int_random_0\");AKA_INSTANCE___Solution->dfs(root,sum);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\Solution\\\\dfs(TreeNode*,int&)\");\n\n/* error assertion */\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\563-binary-tree-tilt.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=-850535950;\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\563-binary-tree-tilt.cpp\\\\dfs(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root_0_DOT_left;\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_left0_x=-210272685;\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\563-binary-tree-tilt.cpp\\\\dfs(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[0]\\\\left\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_0 = new ::TreeNode(root0_left0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_0).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_0);\n/* SubStructDataNode left */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\563-binary-tree-tilt.cpp\\\\dfs(TreeNode*,int&)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\left\\\\left[1]\\\\left\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0_DOT_left_1 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0_DOT_left_1).right;\nAKA_VECTOR_INIT_root_0_DOT_left.push_back(AKA_VECTOR_INIT_root_0_DOT_left_1);\n(*AKA_VECTOR_INIT_root_0).left = AKA_VECTOR_INIT_root_0_DOT_left[0];\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint sum=-663151992;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode sum */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \r     void sumAllNodes(TreeNode* root, int &t) {\r         \r         if(root == NULL)                        return;\r         \r         t += root->val;\r         \r         sumAllNodes(root->left, t);\r         sumAllNodes(root->right, t);\r         \r         return;\r     }\r     \r     void dfs(TreeNode* root, int &sum) {\r         \r         if(root == NULL)                        return;\r         \r         int temp = 0, t = 0;\r         \r         // For every node\r         sumAllNodes(root->left, t);\r         temp = t;\r         \r         t = 0;\r         \r         sumAllNodes(root->right, t);\r         temp = abs(temp - t);\r         \r         sum += temp;\r         \r         dfs(root->left, sum);\r         dfs(root->right, sum);\r         \r         return;\r     }\r     \r     int findTilt(TreeNode* root) {\r     \r         int res = 0;\r         \r         if(root == NULL)                        return res;\r         \r         dfs(root, res);\r         \r         return res;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p95\\563-binary-tree-tilt\\563-binary-tree-tilt.cpp\\Solution\\dfs(TreeNode*,int&)"
    },
    {
        "f": [],
        "fm": "int findTilt(TreeNode* root) {\r     \r         int res = 0;\r         \r         if(root == NULL)                        return res;\r         \r         dfs(root, res);\r         \r         return res;\r     }",
        "datatest": [
            {
                "id": 0,
                "dt": {},
                "td": "void AKA_TEST_Solution_findTilt_TreeNodemul_random_2(void) {\n{\nAKA_test_case_name=\"Solution_findTilt_TreeNodemul_random_2\";\n\n// set up\n;\n\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\563-binary-tree-tilt.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=602991765;\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\563-binary-tree-tilt.cpp\\\\findTilt(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int,TreeNode*,TreeNode*) */\n/* NormalNumberDataNode x */\nint root1_x=1160075125;\n/* PointerStructureDataNode left */\nTreeNode* root1_left;\n/* PointerStructureDataNode right */\nTreeNode* root1_right;\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode(int,TreeNode*,TreeNode*)|ROOT\\\\563-binary-tree-tilt.cpp\\\\findTilt(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int,TreeNode*,TreeNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x,root1_left,root1_right);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\563-binary-tree-tilt.cpp\\\\findTilt(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n\n\nAKA_mark(\"<<PRE-CALLING>> Test Solution_findTilt_TreeNodemul_random_2\");int AKA_ACTUAL_OUTPUT=AKA_INSTANCE___Solution->findTilt(root);\nAKA_fCall++;AKA_mark(\"Return from: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\Solution\\\\findTilt(TreeNode*)\");\n\n\n\n\n// tear down\n;\n}\n}\n",
                "simplified_t": "\n\n/* SubClassDataNode AKA_INSTANCE___Solution */\n/* ConstructorDataNode Solution() */\nAKA_mark(\"Calling: \\\\Solution()|ROOT\\\\563-binary-tree-tilt.cpp\\\\GLOBAL\\\\AKA_INSTANCE___Solution\\\\AKA_INSTANCE___Solution\\\\Solution()\");AKA_fCall++;AKA_INSTANCE___Solution = new ::Solution();\n\n\nstd::vector<TreeNode*> AKA_VECTOR_INIT_root;\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int) */\n/* NormalNumberDataNode x */\nint root0_x=602991765;\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode(int)|ROOT\\\\563-binary-tree-tilt.cpp\\\\findTilt(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_0\\\\root\\\\TreeNode(int)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_0 = new ::TreeNode(root0_x);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_0).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_0).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_0);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode(int,TreeNode*,TreeNode*) */\n/* NormalNumberDataNode x */\nint root1_x=1160075125;\n/* PointerStructureDataNode left */\nTreeNode* root1_left;\n/* PointerStructureDataNode right */\nTreeNode* root1_right;\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode(int,TreeNode*,TreeNode*)|ROOT\\\\563-binary-tree-tilt.cpp\\\\findTilt(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_1\\\\root\\\\TreeNode(int,TreeNode*,TreeNode*)\");AKA_fCall++;auto AKA_VECTOR_INIT_root_1 = new ::TreeNode(root1_x,root1_left,root1_right);\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_1).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_1).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_1);\n\n\n/* SubStructDataNode root */\n/* ConstructorDataNode TreeNode() */\nAKA_mark(\"Calling: .\\\\p95\\\\563-binary-tree-tilt\\\\563-binary-tree-tilt.cpp\\\\TreeNode\\\\TreeNode()|ROOT\\\\563-binary-tree-tilt.cpp\\\\findTilt(TreeNode*)\\\\root\\\\AKA_VECTOR_INIT_root_2\\\\root\\\\TreeNode()\");AKA_fCall++;auto AKA_VECTOR_INIT_root_2 = new ::TreeNode();\n/* NormalNumberDataNode val */\n/* val : null value -> no code */\n/* PointerStructureDataNode left */\n(*AKA_VECTOR_INIT_root_2).left;\n/* PointerStructureDataNode right */\n(*AKA_VECTOR_INIT_root_2).right;\n\nAKA_VECTOR_INIT_root.push_back(AKA_VECTOR_INIT_root_2);\n\nTreeNode* root = AKA_VECTOR_INIT_root[0];\n\n\nint AKA_EXPECTED_OUTPUT;\n\n/* RootDataNode STATIC */\n/* PointerStructureDataNode root */\n/* NormalNumberDataNode RETURN */\n\n",
                "isAutomated": false,
                "testpath": [],
                "executed_fm": "",
                "executed_fm_masked": "",
                "executed_m": "",
                "executed_m_masked": ""
            }
        ],
        "m": {
            "called_m": [],
            "stub_called_m": [],
            "callee_m": []
        },
        "fc": "class Solution {\r public:\r \r     void sumAllNodes(TreeNode* root, int &t) {\r         \r         if(root == NULL)                        return;\r         \r         t += root->val;\r         \r         sumAllNodes(root->left, t);\r         sumAllNodes(root->right, t);\r         \r         return;\r     }\r     \r     void dfs(TreeNode* root, int &sum) {\r         \r         if(root == NULL)                        return;\r         \r         int temp = 0, t = 0;\r         \r         // For every node\r         sumAllNodes(root->left, t);\r         temp = t;\r         \r         t = 0;\r         \r         sumAllNodes(root->right, t);\r         temp = abs(temp - t);\r         \r         sum += temp;\r         \r         dfs(root->left, sum);\r         dfs(root->right, sum);\r         \r         return;\r     }\r     \r     int findTilt(TreeNode* root) {\r     \r         int res = 0;\r         \r         if(root == NULL)                        return res;\r         \r         dfs(root, res);\r         \r         return res;\r     }\r     \r };",
        "c": [
            ""
        ],
        "path_fm": "C:\\Users\\daidu\\Desktop\\Projects\\AKAUT\\prj-data\\Amanhacker_Aman-Barnwal-Leetcode-Solutions\\p95\\563-binary-tree-tilt\\563-binary-tree-tilt.cpp\\Solution\\findTilt(TreeNode*)"
    }
]